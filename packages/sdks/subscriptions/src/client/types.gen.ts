// This file is auto-generated by @hey-api/openapi-ts

/**
 * Whether a plan is active on a subscription using that offering. The `active_plan` attribute is null if a plan is not active in a subscription.
 */
export type ActivePlan = boolean

/**
 * A unique attribute that you could use to contain information from another company system, for example. The maximum length is 2048 characters.
 */
export type ExternalRef = string

/**
 * A unique attribute that you could use to contain information from another company system, for example. The maximum length is 2048 characters.
 */
export type ExternalRefUpdate = string | null

export type SubscriptionType = "subscription"

export type SubscriptionProductType = "subscription_product"

export type ProrationPolicyType = "subscription_proration_policy"

export type SubscriptionDunningRuleType = "subscription_dunning_rule"

export type SubscriptionPlanType = "subscription_plan"

export type SubscriptionFeatureType = "subscription_feature"

export type SubscriptionOfferingType = "subscription_offering"

export type SubscriptionOfferingFeatureType = "subscription_offering_feature"

export type SubscriptionOfferingProductType = "subscription_offering_product"

export type SubscriptionOfferingPlanType = "subscription_offering_plan"

export type SubscriptionJobType = "subscription_job"

export type SubscriptionImportType = "subscription_import"

export type SubscriptionImportErrorType = "subscription_import_error"

export type SubscriptionImportError = {
  id: Uuid
  type: SubscriptionImportErrorType
  meta: SubscriptionImportErrorMeta
}

export type SubscriptionImportErrorMeta = {
  owner: string
  timestamps: Timestamps
  error: string
  field: string
  /**
   * The line in the imported JSONL file at which the validation error occurred. Starts from 1.
   */
  line_number: number
  external_ref?: ExternalRef
}

/**
 * This represents the type of resource object being returned. Always `subscription_invoice`.
 */
export type SubscriptionInvoiceType = "subscription_invoice"

/**
 * This represents the type of resource object being returned. Always `subscription_invoice_payment`.
 */
export type SubscriptionInvoicePaymentType = "subscription_invoice_payment"

export type Links = {
  [key: string]: Link
}

export type Link = LinkUri | LinkObject

export type LinkUri = string | null

export type LinkObject = {
  href?: string
  title?: string
  describedby?: string
}

export type Timestamps = {
  /**
   * The date and time a resource was updated.
   */
  updated_at: string
  /**
   * The date and time a resource was created.
   */
  created_at: string
}

/**
 * The status of a subscription, either `active` or `inactive`.
 */
export type Status = "active" | "inactive"

/**
 * Relationships are established between different subscription entities. For example, a product and a plan are related to an offering, as both are attached to it.
 */
export type Relationships = unknown

export type Relationship = SingleRelationship | ManyRelationship

/**
 * The list of resources that are related.
 */
export type ManyRelationship = {
  data?: Array<RelationshipData>
  links?: RelationshipLinks
}

/**
 * The subscription resource that is related.
 */
export type SingleRelationship = {
  data?: RelationshipData
  links?: RelationshipLinks
}

export type RelationshipData = {
  id: Uuid
  /**
   * This represents the type of resource being returned.
   */
  type: string
}

/**
 * Links are used to allow you, as an API consumer, to move between requests. Single entities use a self parameter with a link to that specific resource. Sometimes, there arenâ€™t enough entities for a project to fill multiple pages. In this situation, we return some defaults, instead of expecting you to check for these special cases.
 *
 * - current - Always the current page.
 * - first - Always the first page.
 * - last - always `null`.
 * - next - `null` if the user is on the first page.
 * - previous - `null` if there is only one page.
 *
 */
export type RelationshipLinks = {
  related?: string
}

/**
 * A period of time between a start and end point.
 */
export type TimePeriod = {
  /**
   * The date and time a billing period started.
   */
  start: Date
  /**
   * The date and time a billing period ended.
   */
  end: Date
}

/**
 * A price in a single currency.
 */
export type SingleCurrencyPrice = {
  /**
   * The three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html) in uppercase, associated with a price.
   */
  currency: string
  /**
   * The value as a whole number of the currency's smallest subdivision.
   */
  amount: BigInt
  /**
   * Whether the amount includes any taxes.
   */
  includes_tax?: boolean
}

/**
 * A unit of time.
 */
export type Unit = "day" | "month"

/**
 * The timeframe during which the product price is applicable. For example, for a streaming service, the price is $12.99 and the `unit` is `months` and the `amount` is `1`. In other words, the streaming service is available for $12.99 a month. You may want to specify a unit price if you have many products that all have different prices. Rather than having to create separate plans for each product, you can specify the timeframe during which the product price is applicable and then create one plan that determines the billing frequency for those products.
 */
export type PriceUnits = {
  /**
   * A unit of time.
   */
  unit: "day" | "month"
  /**
   * The number of days or months the period covers.
   */
  amount: number
}

/**
 * The timeframe during which the product price is applicable. For example, for a streaming service, the price is $12.99 and the `unit` is `months` and the `amount` is `1`. In other words, the streaming service is available for $12.99 a month. You may want to specify a unit price if you have many products that all have different prices. Rather than having to create separate plans for each product, you can specify the timeframe during which the product price is applicable and then create one plan that determines the billing frequency for those products.
 */
export type NullablePriceUnits = {
  /**
   * A unit of time, either days or months.
   */
  unit: "day" | "month"
  /**
   * The number of days or months the period covers.
   */
  amount: number
} | null

export type Price = unknown

export type NullablePrice = {
  [key: string]: {
    /**
     * The value as a whole number of the currency's smallest subdivision.
     */
    amount: BigInt
    /**
     * Whether the amount includes any taxes.
     */
    includes_tax?: boolean
  } | null
} | null

export type DisplayPrice = {
  without_tax?: PriceFormatting
  with_tax?: PriceFormatting
}

export type PriceFormatting = {
  /**
   * The unformatted amount for the objects.
   */
  amount: BigInt
  /**
   * The three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html) in uppercase, associated with a price.
   */
  currency: string
  /**
   * The formatted amount for the objects.
   */
  formatted: string
}

export type Feature = {
  id?: Uuid
  type: SubscriptionFeatureType
  attributes: FeatureResponseAttributes
  meta: FeatureMeta
}

export type FeatureMeta = {
  owner: OwnerMeta
  timestamps: Timestamps
}

export type FeatureCreate = {
  type: SubscriptionFeatureType
  attributes: FeatureAttributes
}

export type FeatureUpdate = {
  id: Uuid
  type: SubscriptionFeatureType
  attributes: FeatureUpdateAttributes
}

export type FeatureResponseAttributes = FeatureAttributes

/**
 * A tag to add to the customer's account when entitled to the feature.
 */
export type FeatureTag = string

export type Type = "access"

export type FeatureAccessAttributes = {
  type: "access"
  tag: FeatureTag
}

export type FeaturePromotion = {
  /**
   * The name of the feature.
   */
  name: string
  tag: FeatureTag
  promotion_id?: Uuid
}

export type FeaturePromotionAttributes = {
  type: "promotion"
  promotions: Array<FeaturePromotion>
}

export type FeatureUsageAttributes = {
  type: "usage"
  tag: FeatureTag
  /**
   * The property that has a usage limit.
   */
  label: string
  /**
   * The default initial value
   */
  default_value: number
}

export type FeatureConfiguration = (
  | ({
      type?: "access"
    } & FeatureAccessAttributes)
  | ({
      type?: "promotion"
    } & FeaturePromotionAttributes)
  | ({
      type?: "usage"
    } & FeatureUsageAttributes)
) & {
  /**
   * The type of feature, one of access, promotion or usage.
   */
  type: "access" | "promotion" | "usage"
}

export type FeatureAttributes = {
  external_ref?: ExternalRef
  /**
   * The name of the feature.
   */
  name: string
  /**
   * The feature description to display to customers.
   */
  description?: string
  configuration: FeatureConfiguration
}

export type FeatureUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  /**
   * The name of the feature.
   */
  name?: string
  /**
   * The feature description to display to customers.
   */
  description?: string | null
  configuration?: FeatureConfiguration
}

export type Product = {
  id?: Uuid
  type: SubscriptionProductType
  attributes: ProductResponseAttributes
  meta: ProductMeta
}

export type ProductMeta = {
  display_price?: DisplayPrice
  owner: OwnerMeta
  timestamps: Timestamps
}

export type ProductCreate = {
  type: SubscriptionProductType
  attributes: ProductAttributes
}

export type ProductUpdate = {
  id: Uuid
  type: SubscriptionProductType
  attributes: ProductUpdateAttributes
}

export type OfferingProductResponseAttributes = ProductResponseAttributes &
  OfferingProductResponseExtraAttributes

export type OfferingProductResponseExtraAttributes = {
  /**
   * A map of configurations indicating which features are available for the product
   */
  feature_configurations: {
    [key: string]: FeatureProductConfiguration
  }
}

export type ProductResponseAttributes = ProductAttributes & Timestamps

export type ProductAttributes = {
  external_ref?: ExternalRef
  /**
   * The name of the product.
   */
  name: string
  /**
   * The product or service description to display to customers.
   */
  description?: string
  /**
   * A stock keeping unit for the product, if appropriate.
   */
  sku?: string
  /**
   * A URL from which an image or file for the product can be fetched. You can either upload your images and files to Commerce using the Commerce Files API or you can use your own content delivery network. If you are using the Commerce Files API, use [**Create a File**](/docs/api/pxm/files/create-a-file) to upload your file and return an HREF link in the response. An extensive range of [**media and file extensions**](/docs/api/pxm/files/files-service-api) are supported.
   */
  main_image?: string
  price?: Price
  price_units?: PriceUnits
}

export type OfferingProductUpdateAttributes = ProductUpdateAttributes &
  OfferingProductUpdateExtraAttributes

export type OfferingProductUpdateExtraAttributes = {
  /**
   * A map of configurations indicating which features are available for the product
   */
  feature_configurations?: {
    [key: string]: FeatureProductConfigurationUpdate
  }
}

export type ProductUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  /**
   * The name of the product.
   */
  name?: string
  /**
   * The product or service description to display to customers.
   */
  description?: string | null
  /**
   * A stock keeping unit for the product, if appropriate.
   */
  sku?: string | null
  /**
   * A URL from which an image or file for the product can be fetched. You can either upload your images and files to Commerce using the Commerce Files API or you can use your own content delivery network. If you are using the Commerce Files API, use [**Create a File**](/docs/api/pxm/files/create-a-file) to upload your file and return an HREF link in the response. An extensive range of [**media and file extensions**](/docs/api/pxm/files/files-service-api) are supported.
   */
  main_image?: string | null
  price?: NullablePrice
  price_units?: NullablePriceUnits
}

export type DunningRule = {
  id?: Uuid
  type: SubscriptionDunningRuleType
  attributes: DunningRuleAttributes
  meta: DunningRuleMeta
}

export type DunningRuleMeta = {
  owner: OwnerMeta
  timestamps: Timestamps
}

export type DunningRuleCreate = {
  type: SubscriptionDunningRuleType
  attributes: DunningRuleAttributes
}

export type DunningRuleUpdate = {
  id: Uuid
  type: SubscriptionDunningRuleType
  attributes: DunningRuleUpdateAttributes
}

/**
 * The strategy used to make payments. Always `fixed`. This means payments are retried on a fixed schedule as defined by the `payment_retry_unit` and `payment_retry_interval`, for example, every two days.
 *
 */
export type PaymentRetryType = "fixed" | "backoff" | "tiered"

/**
 * The unit of time used to measure the intervals between payment attempts or retries.
 */
export type PaymentRetryUnit = "day" | "week"

/**
 * The action to take after all payment attempts for an invoice have failed.
 *
 * - None - the subscription remains active and Subscriptions does not attempt to retry the payment. However, the subscription is still available for a subscriber to use.
 * - Suspend the subscription. Subscriptions does not attempt to retry the payment. A subscriber can choose to pay the outstanding invoice. However, a subscriber cannot renew their subscription; a merchandizer must renew the subscription on behalf of the subscriber.
 * - close a subscription. The subscription ends and it's status becomes `inactive`. However, a merchandizer can choose to resume the subscription if a subscriber pays the outstanding payment.
 *
 */
export type Action = "none" | "pause" | "close" | "suspend"

/**
 * The dunning rule attributes you can use to configure your payment retry strategy.
 *
 */
export type DunningRuleAttributes = {
  /**
   * The strategy used to make payments. Always `fixed`. This means payments are retried on a fixed schedule as defined by the `payment_retry_unit` and `payment_retry_interval`, for example, every two days.
   *
   */
  payment_retry_type: "fixed" | "backoff" | "tiered"
  /**
   * The number of `payment_interval_unit`s to wait between each payment retry attempt.
   */
  payment_retry_interval?: BigInt
  /**
   * The unit of time used to measure the intervals between payment attempts or retries.
   */
  payment_retry_unit?: "day" | "week"
  /**
   * The multiplier that increases the interval between consecutive each payment attempts or retries. This is typically used to gradually extend the time between retries. Allowing more time between attempts as failures persist, helps reduce the risk of triggering multiple failures in a short period and gives the subscriber more time to resolve the issue. Must only be set for backup types.
   */
  payment_retry_multiplier?: number
  /**
   * The number of times Subscriptions attempts payment retries before `action` is taken.
   */
  payment_retries_limit: BigInt
  /**
   * The action to take after all payment attempts for an invoice have failed.
   *
   * - None - the subscription remains active and Subscriptions does not attempt to retry the payment. However, the subscription is still available for a subscriber to use.
   * - Suspend the subscription. Subscriptions does not attempt to retry the payment. A subscriber can choose to pay the outstanding invoice. However, a subscriber cannot renew their subscription; a merchandizer must renew the subscription on behalf of the subscriber.
   * - close a subscription. The subscription ends and it's status becomes `inactive`. However, a merchandizer can choose to resume the subscription if a subscriber pays the outstanding payment.
   *
   */
  action: "none" | "pause" | "close" | "suspend"
  /**
   * Set to `true` if you want this rule to be the default for the store.
   */
  default?: boolean
}

export type DunningRuleUpdateAttributes = {
  /**
   * The strategy used to make payments. Always `fixed`. This means payments are retried on a fixed schedule as defined by the `payment_retry_unit` and `payment_retry_interval`, for example, every two days.
   *
   */
  payment_retry_type?: "fixed" | "backoff" | "tiered"
  /**
   * The number of `payment_interval_unit`s to wait between each payment retry attempt.
   */
  payment_retry_interval?: BigInt | null
  /**
   * The unit of time used to measure the intervals between payment attempts or retries.
   */
  payment_retry_unit?: "day" | "week"
  /**
   * The multiplier that increases the interval between consecutive each payment attempts or retries. This is typically used to gradually extend the time between retries. Allowing more time between attempts as failures persist, helps reduce the risk of triggering multiple failures in a short period and gives the subscriber more time to resolve the issue. Must only be set for backup types.
   */
  payment_retry_multiplier?: number | null
  /**
   * The number of times Subscriptions attempts payment retries before `action` is taken.
   */
  payment_retries_limit?: BigInt
  /**
   * The action to take after all payment attempts for an invoice have failed.
   */
  action?: "none" | "pause" | "close" | "suspend"
  /**
   * Set to `true` if you want this rule to be the default for the store.
   */
  default?: boolean
}

export type ProrationPolicy = {
  id?: Uuid
  type: ProrationPolicyType
  attributes: ProrationPolicyResponseAttributes
  meta: ProrationPolicyMeta
}

export type ProrationPolicyUpdate = {
  id: Uuid
  type: ProrationPolicyType
  attributes: ProrationPolicyUpdateAttributes
}

export type ProrationPolicyRelationshipAttributes = {
  type: ProrationPolicyType
  id: Uuid
}

export type ProrationPolicyUpdateRelationshipAttributes = {
  type: ProrationPolicyType
  id: Uuid
} | null

export type ProrationPolicyResponseAttributes = ProrationPolicyAttributes

export type ProrationPolicyCreate = {
  type: ProrationPolicyType
  attributes: ProrationPolicyAttributes
}

/**
 * When rounding in proration, you must decide how to round the units of time used to calculate the charges.
 *
 * - round up to the next unit, ensuring subscribers are charged slightly more to cover any partial use.
 * - round down to the previous whole unit, providing subscribers with a slight benefit by not charging for partial use.
 * - round to the nearest whole unit, whether up or down, based on standard rounding rules. For example, rounding 0.5 up and rounding 0.5 down.
 *
 */
export type Rounding = "up" | "down" | "nearest"

export type ProrationPolicyAttributes = {
  /**
   * A name for the proration policy.
   */
  name: string
  /**
   * When rounding in proration, you must decide how to round the units of time used to calculate the charges.
   *
   * - round up to the next unit, ensuring subscribers are charged slightly more to cover any partial use.
   * - round down to the previous whole unit, providing subscribers with a slight benefit by not charging for partial use.
   * - round to the nearest whole unit, whether up or down, based on standard rounding rules. For example, rounding 0.5 up and rounding 0.5 down.
   *
   */
  rounding: "up" | "down" | "nearest"
  external_ref?: ExternalRef
}

export type ProrationPolicyUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  /**
   * The name of the proration policy.
   */
  name?: string
  /**
   * Whether to round up or down
   */
  rounding?: "up" | "down" | "nearest"
}

export type ProrationPolicyMeta = {
  owner: OwnerMeta
  timestamps: Timestamps
}

export type Plan = {
  id?: Uuid
  type: SubscriptionPlanType
  attributes: PlanResponseAttributes
  meta: PlanMeta
}

export type PlanMeta = {
  owner: OwnerMeta
  timestamps: Timestamps
}

export type PlanCreate = {
  type: SubscriptionPlanType
  attributes: PlanAttributes
}

export type PlanUpdate = {
  id: Uuid
  type: SubscriptionPlanType
  attributes: PlanUpdateAttributes
}

export type PlanResponseAttributes = PlanAttributes & Timestamps

/**
 * The unit of time that billing intervals are measured.
 */
export type BillingIntervalType = "day" | "week" | "month" | "year"

/**
 * Enables you to specify recurring payments. If `end_behavior` is `roll`, customers pay regularly and repeatedly. If `end_behavior` is `close`, customers pay a total amount in a limited number of partial payments.
 */
export type EndBehavior = "close" | "roll"

export type PlanAttributes = {
  external_ref?: ExternalRef
  /**
   * A name for the plan.
   */
  name: string
  /**
   * The plan description to display to customers.
   */
  description?: string
  /**
   * The unit of time that billing intervals are measured.
   */
  billing_interval_type: "day" | "week" | "month" | "year"
  /**
   * The number of intervals between issuing bills.
   */
  billing_frequency: number
  /**
   * The number of intervals from the start of the subscription before billing starts. Used with `billing_interval_type`. For example, if `billing_interval_type` is `months`, and `trial_period` is `1`, the trial period is 1 month.
   */
  trial_period?: number
  /**
   * The number of intervals that the subscription runs for.
   */
  plan_length: number
  /**
   * Enables you to specify recurring payments. If `end_behavior` is `roll`, customers pay regularly and repeatedly. If `end_behavior` is `close`, customers pay a total amount in a limited number of partial payments.
   */
  end_behavior: "close" | "roll"
  /**
   * The subscriber can pause a subscription.
   */
  can_pause: boolean
  /**
   * The subscriber can resume a paused subscription.
   */
  can_resume: boolean
  /**
   * The subscriber can cancel a subscription.
   */
  can_cancel: boolean
  /**
   * A percentage discount on the total cost of any products within an offering. For example, you can configure a percentage that equates the cost of a plan to the total value of all products within the offering, reduced by a percentage. For example, if you specify `10`, a 10% discount is applied to the total value of all repeat products in an offering.
   */
  base_price_percentage?: number
  fixed_price?: Price
}

export type PlanUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  name?: string
  /**
   * The plan description to display to customers.
   */
  description?: string | null
  /**
   * The unit of time in which billing intervals are measured.
   */
  billing_interval_type?: "day" | "week" | "month" | "year"
  /**
   * The number of intervals between issuing bills.
   */
  billing_frequency?: number
  /**
   * The number of intervals from the start of the subscription before billing starts. Used with `billing_interval_type`. For example, if `billing_interval_type` is `months`, and `trial_period` is `1`, the trial period is 1 month.
   */
  trial_period?: number | null
  /**
   * The length of time for which a subscription plan is valid. For example, six months after which the plan is renewed.
   */
  plan_length?: number
  /**
   * Enables you to specify recurring payments. If `end_behavior` is `roll`, customers pay regularly and repeatedly. If `end_behavior` is `close`, customers pay a total amount in a limited number of partial payments.
   */
  end_behavior?: "close" | "roll"
  /**
   * The subscriber can pause a subscription.
   */
  can_pause?: boolean
  /**
   * The subscriber can resume a paused subscription.
   */
  can_resume?: boolean
  /**
   * The subscriber can cancel a subscription.
   */
  can_cancel?: boolean
  /**
   * A percentage discount on the total cost of any products within an offering. For example, you can configure a percentage that equates the cost of a plan to the total value of all products within the offering, reduced by a percentage. For example, if you specify `10`, a 10% discount is applied to the total value of all repeat products in an offering.
   */
  base_price_percentage?: number | null
  fixed_price?: NullablePrice
}

export type BuildOffering = {
  external_ref?: ExternalRef
  /**
   * The name of the offering.
   */
  name: string
  /**
   * The offering description to display to customers.
   */
  description?: string
  /**
   * The unique ID or external ref of the proration policy
   */
  proration_policy_id?: string
  /**
   * Either references of existing features (id or external_ref) to be attached to the offering or feature information to be created directly within the offering
   */
  features?: Array<ExternalRef | FeatureAttributes | Uuid>
  /**
   * Either references of existing products (id or external_ref) to be attached to the offering or product information to be created directly within the offering
   */
  products: Array<ExternalRef | ProductAttributes | Uuid>
  /**
   * Either references of existing plans (id or external_ref) to be attached to the offering or plan information to be created directly within the offering
   */
  plans: Array<ExternalRef | PlanAttributes | Uuid>
}

export type Offering = {
  id?: Uuid
  type: SubscriptionOfferingType
  attributes: OfferingResponseAttributes
  relationships?: Relationships
  meta: OfferingMeta
}

export type OfferingIncludes = {
  features?: Array<OfferingFeature>
  products?: Array<OfferingProduct>
  plans?: Array<OfferingPlan>
}

export type OfferingMeta = {
  external_product_refs: Array<OfferingProductExternalRefMeta>
  owner: OwnerMeta
  timestamps: Timestamps
}

export type OfferingCreate = {
  type: SubscriptionOfferingType
  attributes: OfferingAttributes
  relationships?: OfferingRelationships
}

export type OfferingProductUpdate = {
  id: Uuid
  type: SubscriptionOfferingProductType
  attributes: OfferingProductUpdateAttributes
}

/**
 * Configures an access feature against a product in an offering, indicating that the referenced feature is a benefit of that product.
 */
export type FeatureConfigAccessAttributes = {
  type: "access"
}

/**
 * Configures a promotion feature against a product in an offering, indicating that the referenced feature is a benefit of that product. The tag of the specific promotion that it to be made available must be supplied.
 */
export type FeatureConfigPromotionAttributes = {
  type: "promotion"
  tag: FeatureTag
}

/**
 * Configures a usgae feature against a product in an offering, indicating that the referenced feature is a benefit of that product. The default value that the usage metrics adopts must be supplied.
 */
export type FeatureConfigUsageAttributes = {
  type: "usage"
  /**
   * The default initial value
   */
  default_value: number
}

export type FeatureProductConfiguration = (
  | ({
      type?: "access"
    } & FeatureConfigAccessAttributes)
  | ({
      type?: "promotion"
    } & FeatureConfigPromotionAttributes)
  | ({
      type?: "usage"
    } & FeatureConfigUsageAttributes)
) & {
  /**
   * The type of feature, one of access, promotion or usage.
   */
  type: "access" | "promotion" | "usage"
}

export type FeatureProductConfigurationUpdate = (
  | ({
      type?: "access"
    } & FeatureConfigAccessAttributes)
  | ({
      type?: "promotion"
    } & FeatureConfigPromotionAttributes)
  | ({
      type?: "usage"
    } & FeatureConfigUsageAttributes)
  | null
) & {
  /**
   * The type of feature, one of access, promotion or usage.
   */
  type: "access" | "promotion" | "usage"
}

export type OfferingFeatureUpdate = {
  id: Uuid
  type: SubscriptionOfferingFeatureType
  attributes: FeatureUpdateAttributes
}

export type OfferingFeature = {
  id?: Uuid
  type: SubscriptionOfferingFeatureType
  attributes: FeatureResponseAttributes
  relationships?: Relationships
  meta: FeatureMeta
}

export type OfferingProduct = {
  id?: Uuid
  type: SubscriptionOfferingProductType
  attributes: OfferingProductResponseAttributes
  relationships?: Relationships
  meta: ProductMeta
}

export type OfferingPlanUpdate = {
  id: Uuid
  type: SubscriptionOfferingPlanType
  attributes: PlanUpdateAttributes
}

export type OfferingPlan = {
  id?: Uuid
  type: SubscriptionOfferingPlanType
  attributes: PlanResponseAttributes
  relationships?: Relationships
  meta: OfferingPlanMeta
}

export type OfferingPlanMeta = {
  price?: Price
  display_price?: DisplayPrice
  active_plan?: ActivePlan
  owner: OwnerMeta
  timestamps: Timestamps
}

/**
 * A list of feature IDs to attach to the offering. See [**List Features**](/docs/api/subscriptions/list-features).
 */
export type OfferingFeatureAttach = {
  features: Array<Uuid>
}

/**
 * A list of plan IDs to attach to the offering. See [**List Plans**](/docs/api/subscriptions/list-plans).
 */
export type OfferingPlanAttach = {
  plans: Array<Uuid>
}

/**
 * A list of product IDs to attach to the offering. See [**List Products**](/docs/api/subscriptions/list-products).
 */
export type OfferingProductAttach = {
  products: Array<Uuid>
}

/**
 * A list of product IDs to replace on the offering. See [**List Products**](/docs/api/subscriptions/list-products).
 */
export type OfferingProductReplace = {
  products: Array<Uuid>
}

export type OfferingUpdate = unknown & {
  id: Uuid
  type: SubscriptionOfferingType
  attributes?: OfferingUpdateAttributes
  relationships?: OfferingUpdateRelationships
}

export type OfferingResponseAttributes = OfferingAttributes & Timestamps

export type OfferingAttributes = {
  external_ref?: ExternalRef
  /**
   * The name of the offering.
   */
  name: string
  /**
   * The offering description to display to customers.
   */
  description?: string
}

export type OfferingUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  /**
   * The name of the offering.
   */
  name?: string
  /**
   * The offering description to display to customers.
   */
  description?: string | null
}

export type OfferingRelationships = {
  proration_policy?: ProrationPolicyRelationshipAttributes
}

export type OfferingUpdateRelationships = {
  proration_policy?: ProrationPolicyUpdateRelationshipAttributes
}

export type BuildSubscription = {
  external_ref?: ExternalRef
  account_id: Uuid
  address_id?: Uuid
  offering_external_ref?: ExternalRef
  offering_id?: Uuid
  plan_id?: Uuid
  currency: CurrencyIdentifier
  payment_authority?: PaymentAuthority
  manual_payments: ManualPayments
  name: string
  email: string
  /**
   * Whether a subscription is pending activation or not. See [Creating a pending subscription](/docs/api/subscriptions/subscriptions#creating-a-pending-subscription).
   */
  pending?: boolean
  /**
   * Indicates that payment for the first billing period of the subscription has already been taken. As well as creating the subscription a settled invoice is created to cover the first period.
   */
  first_invoice_paid?: boolean
  /**
   * When importing an active subscription from an existing system you can specify the date and time of the start of the most recent period. This may only be supplied when `first_invoice_paid` is true. As well as creating the subscription a settled invoice is created to cover the correct billing period.
   */
  started_at?: string
  offering?: OfferingAttributes
  products?: Array<ProductAttributes>
  plans?: Array<PlanAttributesAndSelectedMeta>
  selected_plan?: ExternalRef
  meta?: SubscriptionMeta
}

export type PlanAttributesAndSelectedMeta = PlanAttributes & SelectedPlanMeta

export type SelectedPlanMeta = {
  meta?: SelectedPlanMetaAttributes
}

export type SelectedPlanMetaAttributes = {
  /**
   * One plan must be selected for use in the subscription
   */
  selected?: boolean
}

export type Subscription = {
  id?: Uuid
  type: SubscriptionType
  attributes: SubscriptionAttributes
  relationships?: Relationships
  meta: SubscriptionMeta
}

export type ManageSubscriptionProducts = {
  type: "attach" | "detach" | "replace"
  products: Array<Uuid>
}

export type SubscriptionUpdate = {
  id: Uuid
  type: SubscriptionType
  attributes: SubscriptionUpdateAttributes
}

export type SubscriptionUpdateAttributes = {
  plan_id?: unknown
  address_id?: string | null
  payment_authority?: PaymentAuthority
  /**
   * The date and time a `pending` subscription goes live and becomes active. See [Creating a pending subscription](/docs/api/subscriptions/subscriptions#creating-a-pending-subscription).
   */
  go_live_after?: string | null
}

export type SubscriptionIncludes = {
  products?: Array<OfferingProduct>
  plans?: Array<OfferingPlan>
}

export type SubscriptionMeta = {
  owner: OwnerMeta
  timestamps: SubscriptionTimestamps
  status: Status
  state?: SubscriptionState
  manual_payments: ManualPayments
  /**
   * Indicates that the first billing period of this subscription was paid for outside of the subscriptions service.
   */
  first_invoice_prepaid: boolean
  /**
   * Whether a subscription is canceled or not.
   */
  canceled: boolean
  /**
   * Whether a subscription is paused or not.
   */
  paused: boolean
  /**
   * Whether a subscription is closed or not.
   */
  closed: boolean
  /**
   * Whether a subscription is suspended or not.
   */
  suspended: boolean
  /**
   * Whether a subscription is pending activation or not.
   */
  pending: boolean
  /**
   * The time when the subscription becomes eligible for a new invoice. The next invoice will be generated at the next billing run after this point.
   */
  invoice_after: string
}

export type SubscriptionTimestamps = Timestamps & {
  /**
   * The date and time a subscription was cancelled.
   */
  canceled_at?: string
  /**
   * The date and time a subscription was paused.
   */
  paused_at?: string
  /**
   * The date and time a subscription was resumed.
   */
  resumed_at?: string
  /**
   * The date and time a subscription will end.
   */
  end_date?: string
  /**
   * The date and time a subscription will go live and become active.
   */
  go_live_after?: string
  /**
   * The date and time a subscription was released from the pending state and made active.
   */
  go_live?: string
}

export type SubscriptionAttributes = {
  external_ref?: ExternalRef
  account_id: Uuid
  address_id?: Uuid
  offering: Offering
  plan_id: Uuid
  currency: CurrencyIdentifier
  payment_authority?: PaymentAuthority
}

export type ChangeState = {
  type: SubscriptionStateType
  attributes: SubscriptionStateAttributes
}

export type SubscriptionStateAttributes = {
  action: SubscriptionStateAction
}

/**
 * This represents the type of resource object being returned. Always `subscription_state`.
 */
export type SubscriptionStateType = "subscription_state"

/**
 * The subscription lifecycle is the states that a subscription can go through when a customer subscribes to a service or a product.
 *
 * A subscription can have the following states; `canceled`, `paused`, or `resumed`.
 *
 * See [**Managing the subscription lifecycle**](/docs/api/subscriptions/subscriptions#managing-the-subscription-lifecycle).
 *
 */
export type SubscriptionStateAction = "cancel" | "pause" | "resume" | "pending"

export type StateMeta = {
  /**
   * The date and time a resource was created.
   */
  created_at: string
}

export type SubscriptionState = {
  id?: Uuid
  type: SubscriptionStateType
  attributes: SubscriptionStateAttributes
  meta: StateMeta
}

/**
 * When configured to true, no payment gateway is used and a pending payment is created. See [External Payments](/docs/api/subscriptions/invoices#external-payments).
 */
export type ManualPayments = boolean

export type PaymentAuthority = (
  | ({
      type?: "elastic_path_payments_stripe"
    } & PaymentAuthorityStripe)
  | ({
      type?: "authorize_net"
    } & PaymentAuthorityAuthorizeNet)
) & {
  /**
   * The name of the payment gateway facilitating the secure transmission of payment data.
   */
  type: "authorize_net" | "elastic_path_payments_stripe"
}

export type NullablePaymentAuthority = (
  | ({
      type?: "elastic_path_payments_stripe"
    } & PaymentAuthorityStripe)
  | ({
      type?: "authorize_net"
    } & PaymentAuthorityAuthorizeNet)
  | null
) & {
  /**
   * The name of the payment gateway facilitating the secure transmission of payment data.
   */
  type: "authorize_net" | "elastic_path_payments_stripe"
}

export type PaymentAuthorityAuthorizeNet = {
  /**
   * The name of the payment gateway facilitating the secure transmission of payment data.
   */
  type: "authorize_net"
  /**
   * The customer's payment profile id, unique to Authorize.net, used to facilitate payment of the subscription.
   */
  payment_profile_id?: string
  /**
   * The customer's profile id, unique to Authorize.net, used to facilitate payment of the subscription.
   */
  customer_profile_id?: string
}

export type PaymentAuthorityStripe = {
  /**
   * The name of the payment gateway facilitating the secure transmission of payment data.
   */
  type: "elastic_path_payments_stripe"
  /**
   * The unique identifier for a customer.
   */
  customer_id?: string
  /**
   * The unique identifier of the card used to facilitate payment of the subscription. If a card payment fails, you can use the `card_id` and `customer_id` attributes to program your front-end implementation to allow your preferred payment service provider to update a subscription with new card details. See [Card declines](/docs/api/subscriptions/invoices#card-declines).
   */
  card_id?: string
}

export type Import = {
  id?: Uuid
  type: SubscriptionImportType
  attributes: ImportAttributes
  meta: ImportMeta
}

/**
 * The status of job.
 * - **pending** - Commerce has received the request but is currently busy processing other requests.
 * - **started** - Commerce has started processing the job.
 * - **success** - The job has successfully completed.
 * - **failed** - The job has failed.
 *
 */
export type Status2 = "pending" | "started" | "success" | "failed"

export type ImportAttributes = {
  external_ref?: ExternalRef
  /**
   * The status of job.
   * - **pending** - Commerce has received the request but is currently busy processing other requests.
   * - **started** - Commerce has started processing the job.
   * - **success** - The job has successfully completed.
   * - **failed** - The job has failed.
   *
   */
  status: "pending" | "started" | "success" | "failed"
}

export type ImportMeta = {
  owner: OwnerMeta
  timestamps: JobTimestamps
  records: ImportRecords
}

/**
 * You can track the number of records imported to ensure the completeness, accuracy and integrity of the import. Uploaded shows the number of records ready to be imported into Subscriptions. However, this does not mean they are valid subscription objects, only that they have the correct type and their JSON format is properly formatted. Imported shows the number of records that have been both validated and successfully added to Subscriptions.
 */
export type ImportRecords = {
  uploaded: {
    /**
     * The total number of products uploaded.
     */
    subscription_product: number
    /**
     * The total number of plans uploaded.
     */
    subscription_plan: number
    /**
     * The total number of subscribers uploaded.
     */
    subscription_subscriber: number
    /**
     * The total number of offerings uploaded.
     */
    subscription_offering: number
    /**
     * The total number of subscriptions uploaded.
     */
    subscription: number
  }
  imported: {
    /**
     * The total number of products imported.
     */
    subscription_product: number
    /**
     * The total number of plans imported.
     */
    subscription_plan: number
    /**
     * The total number of subscribers imported.
     */
    subscription_subscriber: number
    /**
     * The total number of offerings imported.
     */
    subscription_offering: number
    /**
     * The total number of subscriptions imported.
     */
    subscription: number
  }
}

export type Job = {
  id?: Uuid
  type: SubscriptionJobType
  attributes: JobResponseAttributes
  relationships?: Relationships
  meta: JobMeta
}

export type JobMeta = {
  owner: OwnerMeta
  timestamps: JobTimestamps
  report?: JobReport
}

/**
 * You can track your Subscriptions billing, tax, and payment operations using reports.
 */
export type JobReport = BillingRunReport | TaxRunReport | PaymentRunReport

export type BillingRunReport = {
  /**
   * The total number of invoices created that are ready for payment.
   */
  invoices_ready_for_payment: number
  /**
   * The total number of invoices created that need taxes to be applied before payment can be made.
   */
  invoices_tax_required: number
  /**
   * The total number of invoices that were scheduled but creation failed.
   */
  invoice_failures: number
  total_ready_for_payment: unknown & Price
  total_tax_required: unknown & Price
}

export type TaxRunReport = {
  /**
   * The total number of invoices to which tax was successfully added.
   */
  invoices_updated: number
  /**
   * The total number of invoices to which tax could not be added.
   */
  invoice_failures: number
}

export type PaymentRunReport = {
  /**
   * The total number of invoices for which payment was attempted.
   */
  total_payment_attempts: number
  /**
   * The number of failed payment attempts.
   */
  failed_payments: number
  total_collected: unknown & Price
}

export type JobTimestamps = Timestamps & {
  /**
   * The date and time a job is started.
   */
  started_at?: string
  /**
   * The date and time a job finished.
   */
  finished_at?: string
}

export type JobCreate = {
  type: SubscriptionJobType
  attributes: JobCreateAttributes
}

export type JobResponseAttributes = JobCreateAttributes &
  JobAttributes &
  Timestamps

/**
 * The type of job. One of the following:
 * - `billing_run` - a billing run job.
 * - `payment_run` - a payment run job.
 * - `tax_run` - a tax run job.
 *
 */
export type JobType = "billing-run" | "tax-run" | "payment-run" | "import"

export type JobCreateAttributes = {
  external_ref?: ExternalRef
  job_type: JobType
  taxes?: Array<InvoiceTaxItems>
}

export type JobAttributes = {
  external_ref?: ExternalRef
  /**
   * The status of job.
   */
  status: "pending" | "started" | "success" | "failed"
}

export type InvoiceTaxItems = {
  invoice_id: Uuid
  tax_items: Array<TaxItem>
}

export type TaxItem = {
  /**
   * This represents the type of resource object being returned. Always `tax_item`.
   */
  type: "tax_item"
  /**
   * The name that appears on your customer's invoice and usually describes the specific type of tax, for example, `Sales`, `VAT` or `GST`.
   */
  name?: string
  /**
   * The unique identifier assigned to goods and services for taxation purposes.
   */
  code?: string
  /**
   * The tax rate is the percentage of the subscription amount that is required to be paid as tax.
   */
  rate: number
  /**
   * The geographic area or political entity that has authority to levy and collect taxes.
   */
  jurisdiction?: string
}

export type SubscriptionInvoice = {
  id?: Uuid
  type: SubscriptionInvoiceType
  attributes: SubscriptionInvoiceAttributes
  meta: SubscriptionInvoiceMeta
}

export type UpdateInvoicePayment = {
  id: Uuid
  type: SubscriptionInvoicePaymentType
  attributes: UpdateInvoicePaymentAttributes
}

export type UpdateInvoicePaymentAttributes = {
  /**
   * Whether the payment was successful.
   */
  success: boolean
  /**
   * An optional external ID that is specific to the gateway used.
   */
  external_payment_id?: string
  /**
   * A message generated by an external payment method that describes why a payment fails.
   */
  failure_detail?: string
  /**
   * The date and time the invoice payment was taken at.
   */
  payment_taken_at?: string
}

export type SubscriptionInvoicePayment = {
  id: Uuid
  type: SubscriptionInvoicePaymentType
  attributes: SubscriptionInvoicePaymentAttributes
  meta: SubscriptionInvoicePaymentMeta
}

export type SubscriptionInvoiceMeta = {
  owner: OwnerMeta
  subscription_id?: Uuid
  subscriber_id?: Uuid
  price?: SingleCurrencyPrice
  timestamps: InvoiceTimestamps
  proration_events: Array<ProrationEvent>
}

export type ProrationEvent = {
  proration_policy_id: Uuid
  /**
   * The value as a whole number of the currency's smallest subdivision
   */
  billing_cost_before_proration: BigInt
  /**
   * The value as a whole number of the currency's smallest subdivision.
   */
  refunded_amount_for_unused_plan: BigInt
  /**
   * The value as a whole number of the currency's smallest subdivision.
   */
  new_plan_cost: BigInt
  /**
   * The date and time the subscription was prorated.
   */
  prorated_at: string
}

export type InvoiceTimestamps = Timestamps & {
  /**
   * The date and time taxes were added to an invoice.
   */
  taxes_added_at?: string
}

export type SubscriptionInvoicePaymentMeta = {
  owner: OwnerMeta
  subscription_id: Uuid
  invoice_id: Uuid
  job_id: Uuid
  timestamps: InvoicePaymentTimestamps
  /**
   * Whether manual payments are enabled or the payment will be handled by the configured gateway.
   */
  manual_payment: boolean
}

export type InvoicePaymentTimestamps = Timestamps & {
  /**
   * The date and time a payment was taken.
   */
  payment_taken_at?: string
}

export type SubscriptionInvoiceAttributes = {
  billing_period: TimePeriod
  invoice_items: Array<SubscriptionInvoiceItem>
  tax_items?: Array<TaxItem>
  /**
   * The invoice still requires payment if `true`.
   */
  outstanding: boolean
  /**
   * A sequential number assigned by the billing run.
   */
  number?: number
  /**
   * Whether tax is required for this invoice.
   */
  tax_required: boolean
  /**
   * Whether the limit of payment retries has been reached.
   */
  payment_retries_limit_reached: boolean
  /**
   * The date and time an invoice was updated.
   */
  updated_at?: string
  /**
   * The date and time an invoice was created.
   */
  created_at?: string
  /**
   * Whether there is a manual pending payment pending on the invoice.
   */
  manual_payment_pending: boolean
}

export type SubscriptionInvoicePaymentAttributes = {
  /**
   * Whether the payment was successful.
   */
  success: boolean
  /**
   * Whether the payment is pending (only for manual payments).
   */
  pending?: boolean
  /**
   * Specifies the payment gateway.
   */
  gateway: string
  /**
   * An optional external ID that is specific to the gateway used.
   */
  external_payment_id?: string
  failure_detail?: PaymentFailureDetail
  amount: SingleCurrencyPrice
}

/**
 * The reason the payment failed.
 */
export type PaymentFailureDetail = {
  reason?: string
}

export type SubscriptionInvoiceItem = {
  /**
   * A description of the subscribed item.
   */
  description: string
  price: SingleCurrencyPrice
  product_id?: Uuid
  /**
   * The start date and time of the billing period in this price
   */
  from_time_period?: string
  /**
   * The end date and time of the billing period in this price
   */
  until_time_period?: string
}

export type ErrorResponse = {
  errors: Array<_Error>
}

export type _Error = {
  /**
   * The HTTP response code of the error.
   */
  status: string
  /**
   * A brief summary of the error.
   */
  title: string
  /**
   * Optional additional detail about the error.
   */
  detail?: string
  /**
   * Additional supporting meta data for the error.
   */
  meta?: {
    [key: string]: unknown
  }
}

/**
 * The three-letter [**ISO currency code**](https://www.iso.org/iso-4217-currency-codes.html) in uppercase.
 */
export type CurrencyIdentifier = string

/**
 * The unique identifier.
 */
export type Uuid = string

/**
 * The owner of a resource, either `store` or `organization`.
 */
export type OwnerMeta = string

/**
 * The offerings product external_ref value
 */
export type OfferingProductExternalRefMeta = string

export type Subscriber = {
  id?: Uuid
  type: SubscriptionSubscriberType
  attributes: SubscriberResponseAttributes
  meta: SubscriberMeta
}

export type SubscriberMeta = {
  owner: OwnerMeta
  timestamps: Timestamps
}

export type SubscriptionSubscriberType = "subscription_subscriber"

export type SubscriberResponseAttributes = SubscriberAttributes & Timestamps

export type SubscriberAttributes = {
  account_id: Uuid
  /**
   * The name of the subscriber.
   */
  name: string
  /**
   * The email of the subscriber.
   */
  email: string
  payment_authority?: PaymentAuthority
}

export type SubscriberUpdateAttributes = {
  /**
   * The name of the subscriber.
   */
  name?: string
  /**
   * The email of the subscriber.
   */
  email?: string
  payment_authority?: NullablePaymentAuthority
}

export type SubscriberCreate = {
  type: SubscriptionSubscriberType
  attributes: SubscriberAttributes
}

export type SubscriberUpdate = {
  id: Uuid
  type: SubscriptionSubscriberType
  attributes: SubscriberUpdateAttributes
}

export type ScheduleCreate = {
  type: SubscriptionScheduleType
  attributes: ScheduleAttributes
}

export type Schedule = {
  id?: Uuid
  type: SubscriptionScheduleType
  attributes: ScheduleResponseAttributes
  meta: ScheduleMeta
}

export type ScheduleMeta = {
  scheduled_for?: Date
  owner: OwnerMeta
  timestamps: Timestamps
}

export type SubscriptionScheduleType = "subscription_schedule"

export type ScheduleResponseAttributes = ScheduleAttributes & Timestamps

export type ScheduleAttributes = {
  external_ref?: ExternalRef
  /**
   * The name of the schedule.
   */
  name?: string
  /**
   * A cron-style specification of when the jobs should be created. See [**Schedules**](/docs/api/subscriptions/schedules).
   */
  specification: string
  /**
   * The location of the time zone that the schedule operates in. Subscriptions runs on Coordinated Universal Time (UTC) time and conforms to [**RFC 3339**](https://www.rfc-editor.org/rfc/rfc3339).
   */
  location: string
  job: ScheduleJob
}

export type ScheduleUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  /**
   * The name of the schedule.
   */
  name?: string | null
  /**
   * A cron-style specification of when the jobs should be created.
   */
  specification?: string
  /**
   * The location of the time zone that the schedule operates in.
   */
  location?: string
  job?: ScheduleJob
}

export type ScheduleJob = {
  job_type: JobType
}

export type ScheduleUpdate = {
  id: Uuid
  type: SubscriptionScheduleType
  attributes: ScheduleUpdateAttributes
}

/**
 * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
 */
export type Include = string

/**
 * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
 *
 */
export type Filter = string

/**
 * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
 */
export type PageOffset = BigInt

/**
 * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
 */
export type PageLimit = BigInt

export type ListProductsData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/products"
}

export type ListProductsErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListProductsError = ListProductsErrors[keyof ListProductsErrors]

export type ListProductsResponses = {
  /**
   * Success. A list of products is returned.
   */
  200: {
    data?: Array<Product>
    links?: Links
  }
}

export type ListProductsResponse =
  ListProductsResponses[keyof ListProductsResponses]

export type CreateProductData = {
  body?: {
    data: ProductCreate
  }
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/subscriptions/products"
}

export type CreateProductErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateProductError = CreateProductErrors[keyof CreateProductErrors]

export type CreateProductResponses = {
  /**
   * Success. The product is created.
   */
  201: {
    data?: Product
  }
}

export type CreateProductResponse =
  CreateProductResponses[keyof CreateProductResponses]

export type DeleteProductData = {
  body?: never
  path: {
    /**
     * The unique identifier of a product.
     */
    product_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/products/{product_uuid}"
}

export type DeleteProductErrors = {
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type DeleteProductError = DeleteProductErrors[keyof DeleteProductErrors]

export type DeleteProductResponses = {
  /**
   * Success. The product details are removed.
   */
  204: void
}

export type DeleteProductResponse =
  DeleteProductResponses[keyof DeleteProductResponses]

export type GetProductData = {
  body?: never
  path: {
    /**
     * The unique identifier of a product.
     */
    product_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/products/{product_uuid}"
}

export type GetProductErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetProductError = GetProductErrors[keyof GetProductErrors]

export type GetProductResponses = {
  /**
   * Success. The product details are returned.
   */
  200: {
    data?: Product
  }
}

export type GetProductResponse = GetProductResponses[keyof GetProductResponses]

export type UpdateProductData = {
  body?: {
    data: ProductUpdate
  }
  path: {
    /**
     * The unique identifier of a product.
     */
    product_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/products/{product_uuid}"
}

export type UpdateProductErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateProductError = UpdateProductErrors[keyof UpdateProductErrors]

export type UpdateProductResponses = {
  /**
   * Success. The product details are updated.
   */
  200: {
    data?: Product
  }
}

export type UpdateProductResponse =
  UpdateProductResponses[keyof UpdateProductResponses]

export type ListPlansData = {
  body?: never
  path?: never
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/plans"
}

export type ListPlansErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListPlansError = ListPlansErrors[keyof ListPlansErrors]

export type ListPlansResponses = {
  /**
   * Success. A list of subscription plans is returned.
   */
  200: {
    data?: Array<Plan>
    links?: Links
  }
}

export type ListPlansResponse = ListPlansResponses[keyof ListPlansResponses]

export type CreatePlanData = {
  body?: {
    data: PlanCreate
  }
  path?: never
  query?: never
  url: "/subscriptions/plans"
}

export type CreatePlanErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreatePlanError = CreatePlanErrors[keyof CreatePlanErrors]

export type CreatePlanResponses = {
  /**
   * Success. The subscription plan is created.
   */
  201: {
    data?: Plan
  }
}

export type CreatePlanResponse = CreatePlanResponses[keyof CreatePlanResponses]

export type DeletePlanData = {
  body?: never
  path: {
    /**
     * The unique identifier of the plan.
     */
    plan_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/plans/{plan_uuid}"
}

export type DeletePlanResponses = {
  /**
   * Success. The subscription plan is removed.
   */
  204: void
}

export type DeletePlanResponse = DeletePlanResponses[keyof DeletePlanResponses]

export type GetPlanData = {
  body?: never
  path: {
    /**
     * The unique identifier of the plan.
     */
    plan_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/plans/{plan_uuid}"
}

export type GetPlanErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetPlanError = GetPlanErrors[keyof GetPlanErrors]

export type GetPlanResponses = {
  /**
   * Success. The details of the plan are returned.
   */
  200: {
    data?: Plan
  }
}

export type GetPlanResponse = GetPlanResponses[keyof GetPlanResponses]

export type UpdatePlanData = {
  body?: {
    data: PlanUpdate
  }
  path: {
    /**
     * The unique identifier of the plan.
     */
    plan_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/plans/{plan_uuid}"
}

export type UpdatePlanErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdatePlanError = UpdatePlanErrors[keyof UpdatePlanErrors]

export type UpdatePlanResponses = {
  /**
   * Success. The details of the plan are updated.
   */
  200: {
    data?: Plan
  }
}

export type UpdatePlanResponse = UpdatePlanResponses[keyof UpdatePlanResponses]

export type ListOfferingsData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
     */
    include?: string
  }
  url: "/subscriptions/offerings"
}

export type ListOfferingsErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListOfferingsError = ListOfferingsErrors[keyof ListOfferingsErrors]

export type ListOfferingsResponses = {
  /**
   * Success. A list of offerings is returned.
   */
  200: {
    data?: Array<Offering>
    included?: OfferingIncludes
    links?: Links
  }
}

export type ListOfferingsResponse =
  ListOfferingsResponses[keyof ListOfferingsResponses]

export type CreateOfferingData = {
  body?: {
    data: OfferingCreate
  }
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/subscriptions/offerings"
}

export type CreateOfferingErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateOfferingError =
  CreateOfferingErrors[keyof CreateOfferingErrors]

export type CreateOfferingResponses = {
  /**
   * Success. The offering is created.
   */
  201: {
    data?: Offering
  }
}

export type CreateOfferingResponse =
  CreateOfferingResponses[keyof CreateOfferingResponses]

export type BuildOfferingData = {
  body?: {
    data: BuildOffering
  }
  path?: never
  query?: never
  url: "/subscriptions/offerings/build"
}

export type BuildOfferingErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type BuildOfferingError = BuildOfferingErrors[keyof BuildOfferingErrors]

export type BuildOfferingResponses = {
  /**
   * Success. The new subscription offering is created with the specified subscription products and plans attached to the offering.
   */
  201: {
    data?: Offering
  }
}

export type BuildOfferingResponse =
  BuildOfferingResponses[keyof BuildOfferingResponses]

export type DeleteOfferingData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}"
}

export type DeleteOfferingErrors = {
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type DeleteOfferingError =
  DeleteOfferingErrors[keyof DeleteOfferingErrors]

export type DeleteOfferingResponses = {
  /**
   * Success. The subscription offering is removed.
   */
  204: void
}

export type DeleteOfferingResponse =
  DeleteOfferingResponses[keyof DeleteOfferingResponses]

export type GetOfferingData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: {
    /**
     * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
     */
    include?: string
  }
  url: "/subscriptions/offerings/{offering_uuid}"
}

export type GetOfferingErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetOfferingError = GetOfferingErrors[keyof GetOfferingErrors]

export type GetOfferingResponses = {
  /**
   * Success. The details of the subscription offering are returned.
   */
  200: {
    data?: Offering
    included?: OfferingIncludes
  }
}

export type GetOfferingResponse =
  GetOfferingResponses[keyof GetOfferingResponses]

export type UpdateOfferingData = {
  body?: {
    data: OfferingUpdate
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}"
}

export type UpdateOfferingErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateOfferingError =
  UpdateOfferingErrors[keyof UpdateOfferingErrors]

export type UpdateOfferingResponses = {
  /**
   * Success. The details of the subscription offering are updated.
   */
  200: {
    data?: Offering
  }
}

export type UpdateOfferingResponse =
  UpdateOfferingResponses[keyof UpdateOfferingResponses]

export type DeleteOfferingFeatureData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
    /**
     * The unique identifier of the feature.
     */
    feature_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/features/{feature_uuid}"
}

export type DeleteOfferingFeatureErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
}

export type DeleteOfferingFeatureError =
  DeleteOfferingFeatureErrors[keyof DeleteOfferingFeatureErrors]

export type DeleteOfferingFeatureResponses = {
  /**
   * Success. The subscription feature is removed from the offering.
   */
  204: void
}

export type DeleteOfferingFeatureResponse =
  DeleteOfferingFeatureResponses[keyof DeleteOfferingFeatureResponses]

export type UpdateOfferingFeatureData = {
  body?: {
    data: OfferingFeatureUpdate
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
    /**
     * The unique identifier of the feature.
     */
    feature_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/features/{feature_uuid}"
}

export type UpdateOfferingFeatureErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateOfferingFeatureError =
  UpdateOfferingFeatureErrors[keyof UpdateOfferingFeatureErrors]

export type UpdateOfferingFeatureResponses = {
  /**
   * Success. The feature details are updated on the offering.
   */
  200: {
    data?: Feature
  }
}

export type UpdateOfferingFeatureResponse =
  UpdateOfferingFeatureResponses[keyof UpdateOfferingFeatureResponses]

export type AttachOfferingFeatureData = {
  body?: {
    data: OfferingFeatureAttach
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/features/attach"
}

export type AttachOfferingFeatureErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type AttachOfferingFeatureError =
  AttachOfferingFeatureErrors[keyof AttachOfferingFeatureErrors]

export type AttachOfferingFeatureResponses = {
  /**
   * Success. The subscription feature is attached with the offering.
   */
  200: {
    data?: Array<OfferingFeature>
  }
}

export type AttachOfferingFeatureResponse =
  AttachOfferingFeatureResponses[keyof AttachOfferingFeatureResponses]

export type ListOfferingPlansData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/offerings/{offering_uuid}/plans"
}

export type ListOfferingPlansErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListOfferingPlansError =
  ListOfferingPlansErrors[keyof ListOfferingPlansErrors]

export type ListOfferingPlansResponses = {
  /**
   * Success. A list of plans attached with the offering is returned.
   */
  200: {
    data?: Array<OfferingPlan>
    links?: Links
  }
}

export type ListOfferingPlansResponse =
  ListOfferingPlansResponses[keyof ListOfferingPlansResponses]

export type AttachOfferingPlanData = {
  body?: {
    data: OfferingPlanAttach
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/plans/attach"
}

export type AttachOfferingPlanErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type AttachOfferingPlanError =
  AttachOfferingPlanErrors[keyof AttachOfferingPlanErrors]

export type AttachOfferingPlanResponses = {
  /**
   * Success. The subscription plan is attached with the offering.
   */
  200: {
    data?: Array<OfferingPlan>
  }
}

export type AttachOfferingPlanResponse =
  AttachOfferingPlanResponses[keyof AttachOfferingPlanResponses]

export type DeleteOfferingPlanData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
    /**
     * The unique identifier of the plan.
     */
    plan_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/plans/{plan_uuid}"
}

export type DeleteOfferingPlanErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
}

export type DeleteOfferingPlanError =
  DeleteOfferingPlanErrors[keyof DeleteOfferingPlanErrors]

export type DeleteOfferingPlanResponses = {
  /**
   * Success. The subscription plan is no longer associated with the offering.
   */
  204: void
}

export type DeleteOfferingPlanResponse =
  DeleteOfferingPlanResponses[keyof DeleteOfferingPlanResponses]

export type UpdateOfferingPlanData = {
  body?: {
    data: OfferingPlanUpdate
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
    /**
     * The unique identifier of the plan.
     */
    plan_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/plans/{plan_uuid}"
}

export type UpdateOfferingPlanErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateOfferingPlanError =
  UpdateOfferingPlanErrors[keyof UpdateOfferingPlanErrors]

export type UpdateOfferingPlanResponses = {
  /**
   * Success. The plan details are updated on the offering.
   */
  200: {
    data?: OfferingPlan
  }
}

export type UpdateOfferingPlanResponse =
  UpdateOfferingPlanResponses[keyof UpdateOfferingPlanResponses]

export type ListOfferingFeaturesData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/offerings/{offering_uuid}/features"
}

export type ListOfferingFeaturesErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListOfferingFeaturesError =
  ListOfferingFeaturesErrors[keyof ListOfferingFeaturesErrors]

export type ListOfferingFeaturesResponses = {
  /**
   * Success. A list of subscription features attached to the offering is returned.
   */
  200: {
    data?: Array<OfferingFeature>
    links?: Links
  }
}

export type ListOfferingFeaturesResponse =
  ListOfferingFeaturesResponses[keyof ListOfferingFeaturesResponses]

export type ListOfferingProductsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/offerings/{offering_uuid}/products"
}

export type ListOfferingProductsErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListOfferingProductsError =
  ListOfferingProductsErrors[keyof ListOfferingProductsErrors]

export type ListOfferingProductsResponses = {
  /**
   * Success. A list of subscription products attached to the offering is returned.
   */
  200: {
    data?: Array<OfferingProduct>
    links?: Links
  }
}

export type ListOfferingProductsResponse =
  ListOfferingProductsResponses[keyof ListOfferingProductsResponses]

export type AttachOfferingProductData = {
  body?: {
    data: OfferingProductAttach
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/products/attach"
}

export type AttachOfferingProductErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type AttachOfferingProductError =
  AttachOfferingProductErrors[keyof AttachOfferingProductErrors]

export type AttachOfferingProductResponses = {
  /**
   * Success. The subscription product is attached with the offering.
   */
  200: {
    data?: Array<OfferingProduct>
  }
}

export type AttachOfferingProductResponse =
  AttachOfferingProductResponses[keyof AttachOfferingProductResponses]

export type ReplaceOfferingProductData = {
  body?: {
    data: OfferingProductReplace
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/products/replace"
}

export type ReplaceOfferingProductErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ReplaceOfferingProductError =
  ReplaceOfferingProductErrors[keyof ReplaceOfferingProductErrors]

export type ReplaceOfferingProductResponses = {
  /**
   * Success. The subscription product is replaced on the offering.
   */
  200: {
    data?: Array<OfferingProduct>
  }
}

export type ReplaceOfferingProductResponse =
  ReplaceOfferingProductResponses[keyof ReplaceOfferingProductResponses]

export type DeleteOfferingProductData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
    /**
     * The unique identifier of the product.
     */
    product_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/products/{product_uuid}"
}

export type DeleteOfferingProductErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
}

export type DeleteOfferingProductError =
  DeleteOfferingProductErrors[keyof DeleteOfferingProductErrors]

export type DeleteOfferingProductResponses = {
  /**
   * Success. The subscription product is removed from the offering.
   */
  204: void
}

export type DeleteOfferingProductResponse =
  DeleteOfferingProductResponses[keyof DeleteOfferingProductResponses]

export type UpdateOfferingProductData = {
  body?: {
    data: OfferingProductUpdate
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
    /**
     * The unique identifier of the product.
     */
    product_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/products/{product_uuid}"
}

export type UpdateOfferingProductErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateOfferingProductError =
  UpdateOfferingProductErrors[keyof UpdateOfferingProductErrors]

export type UpdateOfferingProductResponses = {
  /**
   * Success. The product details are updated on the offering.
   */
  200: {
    data?: OfferingProduct
  }
}

export type UpdateOfferingProductResponse =
  UpdateOfferingProductResponses[keyof UpdateOfferingProductResponses]

export type ListSubscriptionsData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
     */
    include?: string
  }
  url: "/subscriptions/subscriptions"
}

export type ListSubscriptionsErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListSubscriptionsError =
  ListSubscriptionsErrors[keyof ListSubscriptionsErrors]

export type ListSubscriptionsResponses = {
  /**
   * Success. A list of subscriptions is returned.
   */
  200: {
    data?: Array<Subscription>
    included?: SubscriptionIncludes
    links?: Links
  }
}

export type ListSubscriptionsResponse =
  ListSubscriptionsResponses[keyof ListSubscriptionsResponses]

export type CreateSubscriptionData = {
  body?: {
    data: BuildSubscription
  }
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/subscriptions/subscriptions"
}

export type CreateSubscriptionErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateSubscriptionError =
  CreateSubscriptionErrors[keyof CreateSubscriptionErrors]

export type CreateSubscriptionResponses = {
  /**
   * Success. The subscription is created.
   */
  201: {
    data?: Subscription
  }
}

export type CreateSubscriptionResponse =
  CreateSubscriptionResponses[keyof CreateSubscriptionResponses]

export type DeleteSubscriptionData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}"
}

export type DeleteSubscriptionErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type DeleteSubscriptionError =
  DeleteSubscriptionErrors[keyof DeleteSubscriptionErrors]

export type DeleteSubscriptionResponses = {
  /**
   * Success. The subscription is removed.
   */
  204: void
}

export type DeleteSubscriptionResponse =
  DeleteSubscriptionResponses[keyof DeleteSubscriptionResponses]

export type GetSubscriptionData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: {
    /**
     * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
     */
    include?: string
  }
  url: "/subscriptions/subscriptions/{subscription_uuid}"
}

export type GetSubscriptionErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetSubscriptionError =
  GetSubscriptionErrors[keyof GetSubscriptionErrors]

export type GetSubscriptionResponses = {
  /**
   * Success. The details of a subscription are returned.
   */
  200: {
    data?: Subscription
    included?: SubscriptionIncludes
  }
}

export type GetSubscriptionResponse =
  GetSubscriptionResponses[keyof GetSubscriptionResponses]

export type UpdateSubscriptionData = {
  body?: {
    data: SubscriptionUpdate
  }
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}"
}

export type UpdateSubscriptionErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateSubscriptionError =
  UpdateSubscriptionErrors[keyof UpdateSubscriptionErrors]

export type UpdateSubscriptionResponses = {
  /**
   * Success. The subscription is updated.
   */
  200: {
    data?: Subscription
  }
}

export type UpdateSubscriptionResponse =
  UpdateSubscriptionResponses[keyof UpdateSubscriptionResponses]

export type ListSubscriptionProductsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/products"
}

export type ListSubscriptionProductsErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListSubscriptionProductsError =
  ListSubscriptionProductsErrors[keyof ListSubscriptionProductsErrors]

export type ListSubscriptionProductsResponses = {
  /**
   * Success. A list of subscription products is returned.
   */
  200: {
    data?: Array<OfferingProduct>
  }
}

export type ListSubscriptionProductsResponse =
  ListSubscriptionProductsResponses[keyof ListSubscriptionProductsResponses]

export type ManageSubscriptionProductsData = {
  body?: {
    /**
     * A list of product IDs to manage on the subscription.
     */
    data: Array<ManageSubscriptionProducts>
  }
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/products"
}

export type ManageSubscriptionProductsErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ManageSubscriptionProductsError =
  ManageSubscriptionProductsErrors[keyof ManageSubscriptionProductsErrors]

export type ManageSubscriptionProductsResponses = {
  /**
   * Success. The subscription's products have been updated.
   */
  204: void
}

export type ManageSubscriptionProductsResponse =
  ManageSubscriptionProductsResponses[keyof ManageSubscriptionProductsResponses]

export type ListSubscriptionPlansData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/plans"
}

export type ListSubscriptionPlansErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListSubscriptionPlansError =
  ListSubscriptionPlansErrors[keyof ListSubscriptionPlansErrors]

export type ListSubscriptionPlansResponses = {
  /**
   * Success. A list of subscription plans is returned.
   */
  200: {
    data?: Array<OfferingPlan>
  }
}

export type ListSubscriptionPlansResponse =
  ListSubscriptionPlansResponses[keyof ListSubscriptionPlansResponses]

export type ListSubscriptionStatesData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/states"
}

export type ListSubscriptionStatesErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListSubscriptionStatesError =
  ListSubscriptionStatesErrors[keyof ListSubscriptionStatesErrors]

export type ListSubscriptionStatesResponses = {
  /**
   * Success. A list of subscription states is returned.
   */
  200: {
    data?: Array<SubscriptionState>
  }
}

export type ListSubscriptionStatesResponse =
  ListSubscriptionStatesResponses[keyof ListSubscriptionStatesResponses]

export type CreateSubscriptionStateData = {
  body?: {
    data: ChangeState
  }
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/states"
}

export type CreateSubscriptionStateErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateSubscriptionStateError =
  CreateSubscriptionStateErrors[keyof CreateSubscriptionStateErrors]

export type CreateSubscriptionStateResponses = {
  /**
   * Success. The subscription's state has changed.
   */
  204: void
}

export type CreateSubscriptionStateResponse =
  CreateSubscriptionStateResponses[keyof CreateSubscriptionStateResponses]

export type GetSubscriptionStateData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
    /**
     * The unique identifier of the subscription state.
     */
    state_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/states/{state_uuid}"
}

export type GetSubscriptionStateErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetSubscriptionStateError =
  GetSubscriptionStateErrors[keyof GetSubscriptionStateErrors]

export type GetSubscriptionStateResponses = {
  /**
   * Success. A subscription state is returned.
   */
  200: {
    data?: SubscriptionState
  }
}

export type GetSubscriptionStateResponse =
  GetSubscriptionStateResponses[keyof GetSubscriptionStateResponses]

export type ListJobsData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/jobs"
}

export type ListJobsErrors = {
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListJobsError = ListJobsErrors[keyof ListJobsErrors]

export type ListJobsResponses = {
  /**
   * Success. A list of jobs is returned.
   */
  200: {
    data?: Array<Job>
    links?: Links
  }
}

export type ListJobsResponse = ListJobsResponses[keyof ListJobsResponses]

export type CreateJobData = {
  body?: {
    data: JobCreate
  }
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/subscriptions/jobs"
}

export type CreateJobErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateJobError = CreateJobErrors[keyof CreateJobErrors]

export type CreateJobResponses = {
  /**
   * Success. The job was created.
   */
  201: {
    data?: Job
  }
}

export type CreateJobResponse = CreateJobResponses[keyof CreateJobResponses]

export type DeleteJobData = {
  body?: never
  path: {
    /**
     * The unique identifier of the job.
     */
    job_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/jobs/{job_uuid}"
}

export type DeleteJobErrors = {
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
}

export type DeleteJobError = DeleteJobErrors[keyof DeleteJobErrors]

export type DeleteJobResponses = {
  /**
   * Success. The job was deleted.
   */
  204: void
}

export type DeleteJobResponse = DeleteJobResponses[keyof DeleteJobResponses]

export type GetJobData = {
  body?: never
  path: {
    /**
     * The unique identifier of the job.
     */
    job_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/jobs/{job_uuid}"
}

export type GetJobErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetJobError = GetJobErrors[keyof GetJobErrors]

export type GetJobResponses = {
  /**
   * Success. The job is returned.
   */
  200: {
    data?: Job
  }
}

export type GetJobResponse = GetJobResponses[keyof GetJobResponses]

export type ListImportJobsData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/imports"
}

export type ListImportJobsErrors = {
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListImportJobsError =
  ListImportJobsErrors[keyof ListImportJobsErrors]

export type ListImportJobsResponses = {
  /**
   * Success. A list of import jobs is returned.
   */
  200: {
    data?: Array<Import>
    links?: Links
  }
}

export type ListImportJobsResponse =
  ListImportJobsResponses[keyof ListImportJobsResponses]

export type CreateImportData = {
  body?: {
    external_ref?: ExternalRef
    /**
     * The JSONL file you want to upload.
     */
    import_file: Blob | File
  }
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/subscriptions/imports"
}

export type CreateImportErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateImportError = CreateImportErrors[keyof CreateImportErrors]

export type CreateImportResponses = {
  /**
   * Success. The import was started.
   */
  201: {
    data?: Import
  }
}

export type CreateImportResponse =
  CreateImportResponses[keyof CreateImportResponses]

export type GetImportData = {
  body?: never
  path: {
    /**
     * The unique identifier of the import.
     */
    import_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/imports/{import_uuid}"
}

export type GetImportErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetImportError = GetImportErrors[keyof GetImportErrors]

export type GetImportResponses = {
  /**
   * Success. The import is returned.
   */
  200: {
    data?: Import
  }
}

export type GetImportResponse = GetImportResponses[keyof GetImportResponses]

export type GetImportErrorsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the import.
     */
    import_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/imports/{import_uuid}/errors"
}

export type GetImportErrorsErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetImportErrorsError =
  GetImportErrorsErrors[keyof GetImportErrorsErrors]

export type GetImportErrorsResponses = {
  /**
   * Success. The import errors are returned.
   */
  200: {
    data?: Array<SubscriptionImportError>
    links?: Links
  }
}

export type GetImportErrorsResponse =
  GetImportErrorsResponses[keyof GetImportErrorsResponses]

export type ListSubscriptionInvoicesData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/subscriptions/{subscription_uuid}/invoices"
}

export type ListSubscriptionInvoicesErrors = {
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListSubscriptionInvoicesError =
  ListSubscriptionInvoicesErrors[keyof ListSubscriptionInvoicesErrors]

export type ListSubscriptionInvoicesResponses = {
  /**
   * Success. A list of invoices is returned.
   */
  200: {
    data?: Array<SubscriptionInvoice>
    links?: Links
  }
}

export type ListSubscriptionInvoicesResponse =
  ListSubscriptionInvoicesResponses[keyof ListSubscriptionInvoicesResponses]

export type ListSubscriptionInvoicePaymentsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/subscriptions/{subscription_uuid}/invoices/{invoice_uuid}/payments"
}

export type ListSubscriptionInvoicePaymentsResponses = {
  /**
   * Success. Payments for the invoice are returned.
   */
  200: {
    data?: Array<SubscriptionInvoicePayment>
    links?: Links
  }
}

export type ListSubscriptionInvoicePaymentsResponse =
  ListSubscriptionInvoicePaymentsResponses[keyof ListSubscriptionInvoicePaymentsResponses]

export type GetSubscriptionInvoicePaymentData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: Uuid
    /**
     * The unique identifier of the payment.
     */
    payment_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/invoices/{invoice_uuid}/payments/{payment_uuid}"
}

export type GetSubscriptionInvoicePaymentErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
}

export type GetSubscriptionInvoicePaymentError =
  GetSubscriptionInvoicePaymentErrors[keyof GetSubscriptionInvoicePaymentErrors]

export type GetSubscriptionInvoicePaymentResponses = {
  /**
   * Success. Specific payment for the invoice is returned.
   */
  200: {
    data?: SubscriptionInvoicePayment
  }
}

export type GetSubscriptionInvoicePaymentResponse =
  GetSubscriptionInvoicePaymentResponses[keyof GetSubscriptionInvoicePaymentResponses]

export type GetSubscriptionInvoiceData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/invoices/{invoice_uuid}"
}

export type GetSubscriptionInvoiceErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetSubscriptionInvoiceError =
  GetSubscriptionInvoiceErrors[keyof GetSubscriptionInvoiceErrors]

export type GetSubscriptionInvoiceResponses = {
  /**
   * Success. An invoice is returned.
   */
  200: {
    data?: SubscriptionInvoice
  }
}

export type GetSubscriptionInvoiceResponse =
  GetSubscriptionInvoiceResponses[keyof GetSubscriptionInvoiceResponses]

export type ListInvoicesData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/invoices"
}

export type ListInvoicesErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListInvoicesError = ListInvoicesErrors[keyof ListInvoicesErrors]

export type ListInvoicesResponses = {
  /**
   * Success. A list of invoices is returned.
   */
  200: {
    data?: Array<SubscriptionInvoice>
    links?: Links
  }
}

export type ListInvoicesResponse =
  ListInvoicesResponses[keyof ListInvoicesResponses]

export type GetInvoiceData = {
  body?: never
  path: {
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/invoices/{invoice_uuid}"
}

export type GetInvoiceErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetInvoiceError = GetInvoiceErrors[keyof GetInvoiceErrors]

export type GetInvoiceResponses = {
  /**
   * Success. The details of the invoice are returned.
   */
  200: {
    data?: SubscriptionInvoice
  }
}

export type GetInvoiceResponse = GetInvoiceResponses[keyof GetInvoiceResponses]

export type ListInvoicePaymentsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/invoices/{invoice_uuid}/payments"
}

export type ListInvoicePaymentsResponses = {
  /**
   * Success. Payments for the invoice are returned
   */
  200: {
    data?: Array<SubscriptionInvoicePayment>
    links?: Links
  }
}

export type ListInvoicePaymentsResponse =
  ListInvoicePaymentsResponses[keyof ListInvoicePaymentsResponses]

export type GetInvoicePaymentData = {
  body?: never
  path: {
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: Uuid
    /**
     * The unique identifier of the payment.
     */
    payment_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/invoices/{invoice_uuid}/payments/{payment_uuid}"
}

export type GetInvoicePaymentErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
}

export type GetInvoicePaymentError =
  GetInvoicePaymentErrors[keyof GetInvoicePaymentErrors]

export type GetInvoicePaymentResponses = {
  /**
   * Success. Specific payment for the invoice is returned
   */
  200: {
    data?: SubscriptionInvoicePayment
  }
}

export type GetInvoicePaymentResponse =
  GetInvoicePaymentResponses[keyof GetInvoicePaymentResponses]

export type UpdateInvoicePaymentData = {
  body?: {
    data: UpdateInvoicePayment
  }
  path: {
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: Uuid
    /**
     * The unique identifier of the payment.
     */
    payment_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/invoices/{invoice_uuid}/payments/{payment_uuid}"
}

export type UpdateInvoicePaymentErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateInvoicePaymentError =
  UpdateInvoicePaymentErrors[keyof UpdateInvoicePaymentErrors]

export type UpdateInvoicePaymentResponses = {
  /**
   * Success. Invoice payment has been updated.
   */
  200: {
    data: SubscriptionInvoicePayment
  }
}

export type UpdateInvoicePaymentResponse =
  UpdateInvoicePaymentResponses[keyof UpdateInvoicePaymentResponses]

export type ListSchedulesData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/schedules"
}

export type ListSchedulesErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListSchedulesError = ListSchedulesErrors[keyof ListSchedulesErrors]

export type ListSchedulesResponses = {
  /**
   * Success. A list of schedules is returned.
   */
  200: {
    data?: Array<Schedule>
    links?: Links
  }
}

export type ListSchedulesResponse =
  ListSchedulesResponses[keyof ListSchedulesResponses]

export type CreateScheduleData = {
  body?: {
    data: ScheduleCreate
  }
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/subscriptions/schedules"
}

export type CreateScheduleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateScheduleError =
  CreateScheduleErrors[keyof CreateScheduleErrors]

export type CreateScheduleResponses = {
  /**
   * Success. The schedule is created.
   */
  201: {
    data?: Schedule
  }
}

export type CreateScheduleResponse =
  CreateScheduleResponses[keyof CreateScheduleResponses]

export type DeleteScheduleData = {
  body?: never
  path: {
    /**
     * The unique identifier of the schedule.
     */
    schedule_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/schedules/{schedule_uuid}"
}

export type DeleteScheduleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type DeleteScheduleError =
  DeleteScheduleErrors[keyof DeleteScheduleErrors]

export type DeleteScheduleResponses = {
  /**
   * Success. The schedule is removed.
   */
  204: void
}

export type DeleteScheduleResponse =
  DeleteScheduleResponses[keyof DeleteScheduleResponses]

export type GetScheduleData = {
  body?: never
  path: {
    /**
     * The unique identifier of the schedule.
     */
    schedule_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/schedules/{schedule_uuid}"
}

export type GetScheduleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetScheduleError = GetScheduleErrors[keyof GetScheduleErrors]

export type GetScheduleResponses = {
  /**
   * Success. A schedule is returned.
   */
  200: {
    data?: Schedule
  }
}

export type GetScheduleResponse =
  GetScheduleResponses[keyof GetScheduleResponses]

export type UpdateScheduleData = {
  body?: {
    data: ScheduleUpdate
  }
  path: {
    /**
     * The unique identifier of the schedule.
     */
    schedule_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/schedules/{schedule_uuid}"
}

export type UpdateScheduleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateScheduleError =
  UpdateScheduleErrors[keyof UpdateScheduleErrors]

export type UpdateScheduleResponses = {
  /**
   * Success. The schedule details are returned.
   */
  200: {
    data?: Schedule
  }
}

export type UpdateScheduleResponse =
  UpdateScheduleResponses[keyof UpdateScheduleResponses]

export type ListSubscribersData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/subscribers"
}

export type ListSubscribersErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListSubscribersError =
  ListSubscribersErrors[keyof ListSubscribersErrors]

export type ListSubscribersResponses = {
  /**
   * Success. A list of subscribers is returned.
   */
  200: {
    data?: Array<Subscriber>
    links?: Links
  }
}

export type ListSubscribersResponse =
  ListSubscribersResponses[keyof ListSubscribersResponses]

export type CreateSubscriberData = {
  body?: {
    data: SubscriberCreate
  }
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/subscriptions/subscribers"
}

export type CreateSubscriberErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateSubscriberError =
  CreateSubscriberErrors[keyof CreateSubscriberErrors]

export type CreateSubscriberResponses = {
  /**
   * Success. The subscriber is created.
   */
  201: {
    data?: Subscriber
  }
}

export type CreateSubscriberResponse =
  CreateSubscriberResponses[keyof CreateSubscriberResponses]

export type DeleteSubscriberData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscriber.
     */
    subscriber_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscribers/{subscriber_uuid}"
}

export type DeleteSubscriberErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type DeleteSubscriberError =
  DeleteSubscriberErrors[keyof DeleteSubscriberErrors]

export type DeleteSubscriberResponses = {
  /**
   * Success. The subscriber is removed.
   */
  204: void
}

export type DeleteSubscriberResponse =
  DeleteSubscriberResponses[keyof DeleteSubscriberResponses]

export type GetSubscriberData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscriber.
     */
    subscriber_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscribers/{subscriber_uuid}"
}

export type GetSubscriberErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetSubscriberError = GetSubscriberErrors[keyof GetSubscriberErrors]

export type GetSubscriberResponses = {
  /**
   * Success. A subscriber is returned.
   */
  200: {
    data?: Subscriber
  }
}

export type GetSubscriberResponse =
  GetSubscriberResponses[keyof GetSubscriberResponses]

export type UpdateSubscriberData = {
  body?: {
    data: SubscriberUpdate
  }
  path: {
    /**
     * The unique identifier of the subscriber.
     */
    subscriber_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscribers/{subscriber_uuid}"
}

export type UpdateSubscriberErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateSubscriberError =
  UpdateSubscriberErrors[keyof UpdateSubscriberErrors]

export type UpdateSubscriberResponses = {
  /**
   * Success. The subscriber details are returned.
   */
  200: {
    data?: Subscriber
  }
}

export type UpdateSubscriberResponse =
  UpdateSubscriberResponses[keyof UpdateSubscriberResponses]

export type ListDunningRulesData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/dunning-rules"
}

export type ListDunningRulesErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListDunningRulesError =
  ListDunningRulesErrors[keyof ListDunningRulesErrors]

export type ListDunningRulesResponses = {
  /**
   * Success. A list of dunning rules is returned.
   */
  200: {
    data?: Array<DunningRule>
    links?: Links
  }
}

export type ListDunningRulesResponse =
  ListDunningRulesResponses[keyof ListDunningRulesResponses]

export type CreateDunningRuleData = {
  body?: {
    data: DunningRuleCreate
  }
  path?: never
  query?: never
  url: "/subscriptions/dunning-rules"
}

export type CreateDunningRuleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateDunningRuleError =
  CreateDunningRuleErrors[keyof CreateDunningRuleErrors]

export type CreateDunningRuleResponses = {
  /**
   * Success. The dunning rule set is created.
   */
  201: {
    data?: DunningRule
  }
}

export type CreateDunningRuleResponse =
  CreateDunningRuleResponses[keyof CreateDunningRuleResponses]

export type DeleteDunningRuleData = {
  body?: never
  path: {
    /**
     * The unique identifier of a dunning rule set.
     */
    dunning_rule_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/dunning-rules/{dunning_rule_uuid}"
}

export type DeleteDunningRuleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type DeleteDunningRuleError =
  DeleteDunningRuleErrors[keyof DeleteDunningRuleErrors]

export type DeleteDunningRuleResponses = {
  /**
   * Success. The dunning rule is removed.
   */
  204: void
}

export type DeleteDunningRuleResponse =
  DeleteDunningRuleResponses[keyof DeleteDunningRuleResponses]

export type GetDunningRuleData = {
  body?: never
  path: {
    /**
     * The unique identifier of a dunning rule set.
     */
    dunning_rule_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/dunning-rules/{dunning_rule_uuid}"
}

export type GetDunningRuleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetDunningRuleError =
  GetDunningRuleErrors[keyof GetDunningRuleErrors]

export type GetDunningRuleResponses = {
  /**
   * Success. The dunning rule details are returned.
   */
  200: {
    data?: DunningRule
  }
}

export type GetDunningRuleResponse =
  GetDunningRuleResponses[keyof GetDunningRuleResponses]

export type UpdateDunningRuleData = {
  body?: {
    data: DunningRuleUpdate
  }
  path: {
    /**
     * The unique identifier of a dunning rule set.
     */
    dunning_rule_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/dunning-rules/{dunning_rule_uuid}"
}

export type UpdateDunningRuleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateDunningRuleError =
  UpdateDunningRuleErrors[keyof UpdateDunningRuleErrors]

export type UpdateDunningRuleResponses = {
  /**
   * Success. The dunning rule set has been updated.
   */
  200: {
    data?: DunningRule
  }
}

export type UpdateDunningRuleResponse =
  UpdateDunningRuleResponses[keyof UpdateDunningRuleResponses]

export type ListProrationPoliciesData = {
  body?: never
  path?: never
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/proration-policies"
}

export type ListProrationPoliciesErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListProrationPoliciesError =
  ListProrationPoliciesErrors[keyof ListProrationPoliciesErrors]

export type ListProrationPoliciesResponses = {
  /**
   * Success. A list of proration policies is returned.
   */
  200: {
    data?: Array<ProrationPolicy>
    links?: Links
  }
}

export type ListProrationPoliciesResponse =
  ListProrationPoliciesResponses[keyof ListProrationPoliciesResponses]

export type CreateProrationPolicyData = {
  body?: {
    data: ProrationPolicyCreate
  }
  path?: never
  query?: never
  url: "/subscriptions/proration-policies"
}

export type CreateProrationPolicyErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateProrationPolicyError =
  CreateProrationPolicyErrors[keyof CreateProrationPolicyErrors]

export type CreateProrationPolicyResponses = {
  /**
   * Success. The proration policy is created.
   */
  201: {
    data?: ProrationPolicy
  }
}

export type CreateProrationPolicyResponse =
  CreateProrationPolicyResponses[keyof CreateProrationPolicyResponses]

export type DeleteProrationPolicyData = {
  body?: never
  path: {
    /**
     * The unique identifier of a proration policy.
     */
    proration_policy_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/proration-policies/{proration_policy_uuid}"
}

export type DeleteProrationPolicyErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type DeleteProrationPolicyError =
  DeleteProrationPolicyErrors[keyof DeleteProrationPolicyErrors]

export type DeleteProrationPolicyResponses = {
  /**
   * Success. The proration policy details are removed.
   */
  204: void
}

export type DeleteProrationPolicyResponse =
  DeleteProrationPolicyResponses[keyof DeleteProrationPolicyResponses]

export type GetProrationPolicyData = {
  body?: never
  path: {
    /**
     * The unique identifier of a proration policy.
     */
    proration_policy_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/proration-policies/{proration_policy_uuid}"
}

export type GetProrationPolicyErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetProrationPolicyError =
  GetProrationPolicyErrors[keyof GetProrationPolicyErrors]

export type GetProrationPolicyResponses = {
  /**
   * Success. The proration policy details are returned.
   */
  200: {
    data?: ProrationPolicy
  }
}

export type GetProrationPolicyResponse =
  GetProrationPolicyResponses[keyof GetProrationPolicyResponses]

export type UpdateProrationPolicyData = {
  body?: {
    data: ProrationPolicyUpdate
  }
  path: {
    /**
     * The unique identifier of a proration policy.
     */
    proration_policy_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/proration-policies/{proration_policy_uuid}"
}

export type UpdateProrationPolicyErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
}

export type UpdateProrationPolicyError =
  UpdateProrationPolicyErrors[keyof UpdateProrationPolicyErrors]

export type UpdateProrationPolicyResponses = {
  /**
   * Success. The proration policy details are updated.
   */
  200: {
    data?: ProrationPolicy
  }
}

export type UpdateProrationPolicyResponse =
  UpdateProrationPolicyResponses[keyof UpdateProrationPolicyResponses]

export type ListFeaturesData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/features"
}

export type ListFeaturesErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListFeaturesError = ListFeaturesErrors[keyof ListFeaturesErrors]

export type ListFeaturesResponses = {
  /**
   * Success. A list of features is returned.
   */
  200: {
    data?: Array<Feature>
    links?: Links
  }
}

export type ListFeaturesResponse =
  ListFeaturesResponses[keyof ListFeaturesResponses]

export type CreateFeatureData = {
  body?: {
    data: FeatureCreate
  }
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/subscriptions/features"
}

export type CreateFeatureErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateFeatureError = CreateFeatureErrors[keyof CreateFeatureErrors]

export type CreateFeatureResponses = {
  /**
   * Success. The feature is created.
   */
  201: {
    data?: Feature
  }
}

export type CreateFeatureResponse =
  CreateFeatureResponses[keyof CreateFeatureResponses]

export type DeleteFeatureData = {
  body?: never
  path: {
    /**
     * The unique identifier of a feature.
     */
    feature_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/features/{feature_uuid}"
}

export type DeleteFeatureErrors = {
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type DeleteFeatureError = DeleteFeatureErrors[keyof DeleteFeatureErrors]

export type DeleteFeatureResponses = {
  /**
   * Success. The feature is removed.
   */
  204: void
}

export type DeleteFeatureResponse =
  DeleteFeatureResponses[keyof DeleteFeatureResponses]

export type GetFeatureData = {
  body?: never
  path: {
    /**
     * The unique identifier of a feature.
     */
    feature_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/features/{feature_uuid}"
}

export type GetFeatureErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetFeatureError = GetFeatureErrors[keyof GetFeatureErrors]

export type GetFeatureResponses = {
  /**
   * Success. The feature details are returned.
   */
  200: {
    data?: Feature
  }
}

export type GetFeatureResponse = GetFeatureResponses[keyof GetFeatureResponses]

export type UpdateFeatureData = {
  body?: {
    data: FeatureUpdate
  }
  path: {
    /**
     * The unique identifier of a feature.
     */
    feature_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/features/{feature_uuid}"
}

export type UpdateFeatureErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateFeatureError = UpdateFeatureErrors[keyof UpdateFeatureErrors]

export type UpdateFeatureResponses = {
  /**
   * Success. The feature details are updated.
   */
  200: {
    data?: Feature
  }
}

export type UpdateFeatureResponse =
  UpdateFeatureResponses[keyof UpdateFeatureResponses]
