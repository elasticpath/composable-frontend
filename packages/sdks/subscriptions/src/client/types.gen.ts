// This file is auto-generated by @hey-api/openapi-ts

/**
 * Whether a pricing option is active on a subscription using that offering. The `active_pricing_option` attribute is null if a pricing option is not active in a subscription.
 */
export type ActivePricingOption = boolean

/**
 * Whether a plan is active on a subscription using that offering. The `active_plan` attribute is null if a plan is not active in a subscription.
 */
export type ActivePlan = boolean

/**
 * A unique attribute that you could use to contain information from another company system, for example. The maximum length is 2048 characters.
 */
export type ExternalRef = string

/**
 * A unique attribute that you could use to contain information from another company system, for example. The maximum length is 2048 characters.
 */
export type ExternalRefUpdate = string | null

export type SubscriptionType = "subscription"

export type ProrationPolicyType = "subscription_proration_policy"

export type SubscriptionDunningRuleType = "subscription_dunning_rule"

export type SubscriptionFeatureType = "subscription_feature"

export type SubscriptionOfferingType = "subscription_offering"

export type SubscriptionOfferingFeatureType = "subscription_offering_feature"

export type SubscriptionOfferingPlanType = "subscription_offering_plan"

export type SubscriptionOfferingPricingOptionType =
  "subscription_offering_pricing_option"

export type SubscriptionJobType = "subscription_job"

export type SubscriptionImportType = "subscription_import"

export type SubscriptionImportErrorType = "subscription_import_error"

export type SubscriptionImportError = {
  id: Uuid
  type: SubscriptionImportErrorType
  meta: SubscriptionImportErrorMeta
}

export type SubscriptionImportErrorMeta = {
  owner: string
  timestamps: Timestamps
  error: string
  field: string
  /**
   * The line in the imported JSONL file at which the validation error occurred. Starts from 1.
   */
  line_number: number
  external_ref?: ExternalRef
}

/**
 * This represents the type of resource object being returned. Always `subscription_invoice`.
 */
export type SubscriptionInvoiceType = "subscription_invoice"

/**
 * This represents the type of resource object being returned. Always `subscription_invoice_payment`.
 */
export type SubscriptionInvoicePaymentType = "subscription_invoice_payment"

export type Links = {
  [key: string]: Link
}

export type Link = LinkUri | LinkObject

export type LinkUri = string | null

export type LinkObject = {
  href?: string
  title?: string
  describedby?: string
}

export type Timestamps = {
  /**
   * The date and time a resource was updated.
   */
  updated_at: string
  /**
   * The date and time a resource was created.
   */
  created_at: string
}

/**
 * The status of a subscription, either `active` or `inactive`.
 */
export type Status = "active" | "inactive"

/**
 * Enumerates a list of resources that are related.
 */
export type RelationshipsRequest = {
  data: Array<RelationshipData>
}

/**
 * Relationships are established between different subscription entities. For example, a plan and a pricing option are related to an offering, as both are attached to it.
 */
export type Relationships = unknown

export type Relationship = SingleRelationship | ManyRelationship

/**
 * The list of resources that are related.
 */
export type ManyRelationship = {
  data?: Array<RelationshipData>
  links?: RelationshipLinks
}

/**
 * The subscription resource that is related.
 */
export type SingleRelationship = {
  data?: RelationshipData
  links?: RelationshipLinks
}

export type RelationshipData = {
  id: Uuid
  /**
   * This represents the type of resource being returned.
   */
  type: string
}

/**
 * Links are used to allow you, as an API consumer, to move between requests. Single entities use a self parameter with a link to that specific resource. Sometimes, there arenâ€™t enough entities for a project to fill multiple pages. In this situation, we return some defaults, instead of expecting you to check for these special cases.
 *
 * - current - Always the current page.
 * - first - Always the first page.
 * - last - always `null`.
 * - next - `null` if the user is on the first page.
 * - previous - `null` if there is only one page.
 *
 */
export type RelationshipLinks = {
  related?: string
}

/**
 * A period of time between a start and end point.
 */
export type TimePeriod = {
  /**
   * The date and time a billing period started.
   */
  start: Date
  /**
   * The date and time a billing period ended.
   */
  end: Date
}

/**
 * A price in a single currency.
 */
export type SingleCurrencyPrice = {
  /**
   * The three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html) in uppercase, associated with a price.
   */
  currency: string
  /**
   * The value as a whole number of the currency's smallest subdivision.
   */
  amount: BigInt
  /**
   * Whether the amount includes any taxes.
   */
  includes_tax?: boolean
}

/**
 * A unit of time.
 */
export type Unit = "day" | "month"

/**
 * The timeframe during which the plan price is applicable. For example, for a streaming service, the price is $12.99 and the `unit` is `months` and the `amount` is `1`. In other words, the streaming service is available for $12.99 a month. You may want to specify a unit price if you have many plans that all have different prices. Rather than having to create separate pricing options for each plan, you can specify the timeframe during which the plan price is applicable and then create one pricing option that determines the billing frequency for those plans.
 */
export type PriceUnits = {
  /**
   * A unit of time.
   */
  unit: "day" | "month"
  /**
   * The number of days or months the period covers.
   */
  amount: number
}

/**
 * The timeframe during which the plan price is applicable. For example, for a streaming service, the price is $12.99 and the `unit` is `months` and the `amount` is `1`. In other words, the streaming service is available for $12.99 a month. You may want to specify a unit price if you have many plans that all have different prices. Rather than having to create separate pricing options for each plan, you can specify the timeframe during which the plan price is applicable and then create one pricing option that determines the billing frequency for those plans.
 */
export type NullablePriceUnits = {
  /**
   * A unit of time, either days or months.
   */
  unit: "day" | "month"
  /**
   * The number of days or months the period covers.
   */
  amount: number
} | null

export type Price = unknown

export type NullablePrice = {
  [key: string]: {
    /**
     * The value as a whole number of the currency's smallest subdivision.
     */
    amount: BigInt
    /**
     * Whether the amount includes any taxes.
     */
    includes_tax?: boolean
  } | null
} | null

/**
 * A list of plan prices for each of its pricing options.
 */
export type OfferingPlanPrices = {
  [key: string]: OfferingPlanPriceForPricingOption
}

export type OfferingPlanPriceForPricingOption = {
  price?: Price
  display_price?: DisplayPrice
}

export type DisplayPrice = {
  without_tax?: PriceFormatting
  with_tax?: PriceFormatting
}

export type PriceFormatting = {
  /**
   * The unformatted amount for the objects.
   */
  amount: BigInt
  /**
   * The three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html) in uppercase, associated with a price.
   */
  currency: string
  /**
   * The formatted amount for the objects.
   */
  formatted: string
}

export type Feature = {
  id?: Uuid
  type: SubscriptionFeatureType
  attributes: FeatureResponseAttributes
  meta: FeatureMeta
}

export type FeatureMeta = {
  owner: OwnerMeta
  timestamps: Timestamps
}

export type FeatureCreate = {
  type: SubscriptionFeatureType
  attributes: FeatureAttributes
}

export type FeatureUpdate = {
  id: Uuid
  type: SubscriptionFeatureType
  attributes: FeatureUpdateAttributes
}

export type OfferingFeatureCreate = {
  type: SubscriptionOfferingFeatureType
  attributes: FeatureAttributes
}

export type FeatureResponseAttributes = FeatureAttributes

/**
 * A tag to add to the customer's account when entitled to the feature.
 */
export type FeatureTag = string

export type Type = "access"

export type FeatureAccessAttributes = {
  type: "access"
  tag: FeatureTag
}

export type FeaturePromotion = {
  /**
   * The name of the feature.
   */
  name: string
  tag: FeatureTag
  promotion_id?: Uuid
}

export type FeaturePromotionAttributes = {
  type: "promotion"
  promotions: Array<FeaturePromotion>
}

export type FeatureUsageAttributes = {
  type: "usage"
  tag: FeatureTag
  /**
   * The property that has a usage limit.
   */
  label: string
  /**
   * The default initial value
   */
  default_value: number
}

export type FeatureConfiguration = (
  | ({
      type?: "access"
    } & FeatureAccessAttributes)
  | ({
      type?: "promotion"
    } & FeaturePromotionAttributes)
  | ({
      type?: "usage"
    } & FeatureUsageAttributes)
) & {
  /**
   * The type of feature, one of access, promotion or usage.
   */
  type: "access" | "promotion" | "usage"
}

export type FeatureAttributes = {
  external_ref?: ExternalRef
  /**
   * The name of the feature.
   */
  name: string
  /**
   * The feature description to display to customers.
   */
  description?: string
  configuration: FeatureConfiguration
}

export type FeatureUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  /**
   * The name of the feature.
   */
  name?: string
  /**
   * The feature description to display to customers.
   */
  description?: string | null
  configuration?: FeatureConfiguration
}

export type PlanMeta = {
  prices?: OfferingPlanPrices
  display_price?: DisplayPrice
  owner: OwnerMeta
  timestamps: Timestamps
  active_plan?: ActivePlan
}

export type OfferingPlanCreate = {
  type: SubscriptionOfferingPlanType
  attributes: OfferingPlanAttributes
  relationships?: Relationships
}

export type OfferingPlanAttributes = PlanAttributes &
  OfferingPlanExtraAttributes

export type OfferingPlanResponseAttributes = PlanResponseAttributes &
  OfferingPlanResponseExtraAttributes

export type OfferingPlanExtraAttributes = {
  /**
   * A map of configurations indicating which features are available for the plan
   */
  feature_configurations?: {
    [key: string]: FeaturePlanConfiguration
  }
}

export type OfferingPlanResponseExtraAttributes = {
  /**
   * A map of configurations indicating which features are available for the plan
   */
  feature_configurations: {
    [key: string]: FeaturePlanConfiguration
  }
}

export type PlanResponseAttributes = PlanAttributes & Timestamps

export type PlanAttributes = {
  external_ref?: ExternalRef
  /**
   * The name of the plan.
   */
  name: string
  /**
   * The plan or service description to display to customers.
   */
  description?: string
  /**
   * A stock keeping unit for the plan, if appropriate.
   */
  sku?: string
  /**
   * A URL from which an image or file for the plan can be fetched. You can either upload your images and files to Commerce using the Commerce Files API or you can use your own content delivery network. If you are using the Commerce Files API, use [**Create a File**](/docs/api/pxm/files/create-a-file) to upload your file and return an HREF link in the response. An extensive range of [**media and file extensions**](/docs/api/pxm/files/files-service-api) are supported.
   */
  main_image?: string
  price?: Price
  price_units?: PriceUnits
}

export type OfferingPlanUpdateAttributes = PlanUpdateAttributes &
  OfferingPlanUpdateExtraAttributes

export type OfferingPlanUpdateExtraAttributes = {
  /**
   * A map of configurations indicating which features are available for the plan
   */
  feature_configurations?: {
    [key: string]: FeaturePlanConfigurationUpdate
  }
}

export type PlanUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  /**
   * The name of the plan.
   */
  name?: string
  /**
   * The plan or service description to display to customers.
   */
  description?: string | null
  /**
   * A stock keeping unit for the plan, if appropriate.
   */
  sku?: string | null
  /**
   * A URL from which an image or file for the plan can be fetched. You can either upload your images and files to Commerce using the Commerce Files API or you can use your own content delivery network. If you are using the Commerce Files API, use [**Create a File**](/docs/api/pxm/files/create-a-file) to upload your file and return an HREF link in the response. An extensive range of [**media and file extensions**](/docs/api/pxm/files/files-service-api) are supported.
   */
  main_image?: string | null
  price?: NullablePrice
  price_units?: NullablePriceUnits
}

export type DunningRule = {
  id?: Uuid
  type: SubscriptionDunningRuleType
  attributes: DunningRuleAttributes
  meta: DunningRuleMeta
}

export type DunningRuleMeta = {
  owner: OwnerMeta
  timestamps: Timestamps
}

export type DunningRuleCreate = {
  type: SubscriptionDunningRuleType
  attributes: DunningRuleAttributes
}

export type DunningRuleUpdate = {
  id: Uuid
  type: SubscriptionDunningRuleType
  attributes: DunningRuleUpdateAttributes
}

/**
 * The strategy used to make payments. Always `fixed`. This means payments are retried on a fixed schedule as defined by the `payment_retry_unit` and `payment_retry_interval`, for example, every two days.
 *
 */
export type PaymentRetryType = "fixed" | "backoff" | "tiered"

/**
 * The unit of time used to measure the intervals between payment attempts or retries.
 */
export type PaymentRetryUnit = "day" | "week"

/**
 * The action to take after all payment attempts for an invoice have failed.
 *
 * - None - the subscription remains active and Subscriptions does not attempt to retry the payment. However, the subscription is still available for a subscriber to use.
 * - Suspend the subscription. Subscriptions does not attempt to retry the payment. A subscriber can choose to pay the outstanding invoice. However, a subscriber cannot renew their subscription; a merchandizer must renew the subscription on behalf of the subscriber.
 * - close a subscription. The subscription ends and it's status becomes `inactive`. However, a merchandizer can choose to resume the subscription if a subscriber pays the outstanding payment.
 *
 */
export type Action = "none" | "pause" | "close" | "suspend"

/**
 * The dunning rule attributes you can use to configure your payment retry strategy.
 *
 */
export type DunningRuleAttributes = {
  /**
   * The strategy used to make payments. Always `fixed`. This means payments are retried on a fixed schedule as defined by the `payment_retry_unit` and `payment_retry_interval`, for example, every two days.
   *
   */
  payment_retry_type: "fixed" | "backoff" | "tiered"
  /**
   * The number of `payment_interval_unit`s to wait between each payment retry attempt.
   */
  payment_retry_interval?: BigInt
  /**
   * The unit of time used to measure the intervals between payment attempts or retries.
   */
  payment_retry_unit?: "day" | "week"
  /**
   * The multiplier that increases the interval between consecutive each payment attempts or retries. This is typically used to gradually extend the time between retries. Allowing more time between attempts as failures persist, helps reduce the risk of triggering multiple failures in a short period and gives the subscriber more time to resolve the issue. Must only be set for backup types.
   */
  payment_retry_multiplier?: number
  /**
   * The number of times Subscriptions attempts payment retries before `action` is taken.
   */
  payment_retries_limit: BigInt
  /**
   * The action to take after all payment attempts for an invoice have failed.
   *
   * - None - the subscription remains active and Subscriptions does not attempt to retry the payment. However, the subscription is still available for a subscriber to use.
   * - Suspend the subscription. Subscriptions does not attempt to retry the payment. A subscriber can choose to pay the outstanding invoice. However, a subscriber cannot renew their subscription; a merchandizer must renew the subscription on behalf of the subscriber.
   * - close a subscription. The subscription ends and it's status becomes `inactive`. However, a merchandizer can choose to resume the subscription if a subscriber pays the outstanding payment.
   *
   */
  action: "none" | "pause" | "close" | "suspend"
  /**
   * Set to `true` if you want this rule to be the default for the store.
   */
  default?: boolean
}

export type DunningRuleUpdateAttributes = {
  /**
   * The strategy used to make payments. Always `fixed`. This means payments are retried on a fixed schedule as defined by the `payment_retry_unit` and `payment_retry_interval`, for example, every two days.
   *
   */
  payment_retry_type?: "fixed" | "backoff" | "tiered"
  /**
   * The number of `payment_interval_unit`s to wait between each payment retry attempt.
   */
  payment_retry_interval?: BigInt | null
  /**
   * The unit of time used to measure the intervals between payment attempts or retries.
   */
  payment_retry_unit?: "day" | "week"
  /**
   * The multiplier that increases the interval between consecutive each payment attempts or retries. This is typically used to gradually extend the time between retries. Allowing more time between attempts as failures persist, helps reduce the risk of triggering multiple failures in a short period and gives the subscriber more time to resolve the issue. Must only be set for backup types.
   */
  payment_retry_multiplier?: number | null
  /**
   * The number of times Subscriptions attempts payment retries before `action` is taken.
   */
  payment_retries_limit?: BigInt
  /**
   * The action to take after all payment attempts for an invoice have failed.
   */
  action?: "none" | "pause" | "close" | "suspend"
  /**
   * Set to `true` if you want this rule to be the default for the store.
   */
  default?: boolean
}

export type ProrationPolicy = {
  id?: Uuid
  type: ProrationPolicyType
  attributes: ProrationPolicyResponseAttributes
  meta: ProrationPolicyMeta
}

export type ProrationPolicyUpdate = {
  id: Uuid
  type: ProrationPolicyType
  attributes: ProrationPolicyUpdateAttributes
}

export type ProrationPolicyRelationshipAttributes = {
  type: ProrationPolicyType
  id: Uuid
}

export type ProrationPolicyUpdateRelationshipAttributes = {
  type: ProrationPolicyType
  id: Uuid
} | null

export type ProrationPolicyResponseAttributes = ProrationPolicyAttributes

export type ProrationPolicyCreate = {
  type: ProrationPolicyType
  attributes: ProrationPolicyAttributes
}

/**
 * When rounding in proration, you must decide how to round the units of time used to calculate the charges.
 *
 * - round up to the next unit, ensuring subscribers are charged slightly more to cover any partial use.
 * - round down to the previous whole unit, providing subscribers with a slight benefit by not charging for partial use.
 * - round to the nearest whole unit, whether up or down, based on standard rounding rules. For example, rounding 0.5 up and rounding 0.5 down.
 *
 */
export type Rounding = "up" | "down" | "nearest"

export type ProrationPolicyAttributes = {
  /**
   * A name for the proration policy.
   */
  name: string
  /**
   * When rounding in proration, you must decide how to round the units of time used to calculate the charges.
   *
   * - round up to the next unit, ensuring subscribers are charged slightly more to cover any partial use.
   * - round down to the previous whole unit, providing subscribers with a slight benefit by not charging for partial use.
   * - round to the nearest whole unit, whether up or down, based on standard rounding rules. For example, rounding 0.5 up and rounding 0.5 down.
   *
   */
  rounding: "up" | "down" | "nearest"
  external_ref?: ExternalRef
}

export type ProrationPolicyUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  /**
   * The name of the proration policy.
   */
  name?: string
  /**
   * Whether to round up or down
   */
  rounding?: "up" | "down" | "nearest"
}

export type ProrationPolicyMeta = {
  owner: OwnerMeta
  timestamps: Timestamps
}

export type OfferingPricingOptionCreate = {
  type: SubscriptionOfferingPricingOptionType
  attributes: PricingOptionAttributes
}

export type PricingOptionResponseAttributes = PricingOptionAttributes &
  Timestamps

/**
 * The unit of time that billing intervals are measured.
 */
export type BillingIntervalType = "day" | "week" | "month" | "year"

/**
 * Enables you to specify recurring payments. If `end_behavior` is `roll`, customers pay regularly and repeatedly. If `end_behavior` is `close`, customers pay a total amount in a limited number of partial payments.
 */
export type EndBehavior = "close" | "roll"

export type PricingOptionAttributes = {
  external_ref?: ExternalRef
  /**
   * A name for the pricing option.
   */
  name: string
  /**
   * The pricing option description to display to customers.
   */
  description?: string
  /**
   * The unit of time that billing intervals are measured.
   */
  billing_interval_type: "day" | "week" | "month" | "year"
  /**
   * The number of intervals between issuing bills.
   */
  billing_frequency: number
  /**
   * The number of intervals from the start of the subscription before billing starts. Used with `billing_interval_type`. For example, if `billing_interval_type` is `months`, and `trial_period` is `1`, the trial period is 1 month.
   */
  trial_period?: number
  /**
   * The number of intervals that the subscription runs for.
   */
  plan_length: number
  /**
   * Enables you to specify recurring payments. If `end_behavior` is `roll`, customers pay regularly and repeatedly. If `end_behavior` is `close`, customers pay a total amount in a limited number of partial payments.
   */
  end_behavior: "close" | "roll"
  /**
   * The subscriber can pause a subscription.
   */
  can_pause: boolean
  /**
   * The subscriber can resume a paused subscription.
   */
  can_resume: boolean
  /**
   * The subscriber can cancel a subscription.
   */
  can_cancel: boolean
  /**
   * A percentage discount on the total cost of any plans within an offering. For example, you can configure a percentage that equates the cost of a pricing option to the total value of all plans within the offering, reduced by a percentage. For example, if you specify `10`, a 10% discount is applied to the total value of all repeat plans in an offering.
   */
  base_price_percentage?: number
  fixed_price?: Price
}

export type PricingOptionUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  name?: string
  /**
   * The pricing option description to display to customers.
   */
  description?: string | null
  /**
   * The unit of time in which billing intervals are measured.
   */
  billing_interval_type?: "day" | "week" | "month" | "year"
  /**
   * The number of intervals between issuing bills.
   */
  billing_frequency?: number
  /**
   * The number of intervals from the start of the subscription before billing starts. Used with `billing_interval_type`. For example, if `billing_interval_type` is `months`, and `trial_period` is `1`, the trial period is 1 month.
   */
  trial_period?: number | null
  /**
   * The length of time for which a subscription plan is valid. For example, six months after which the plan is renewed.
   */
  plan_length?: number
  /**
   * Enables you to specify recurring payments. If `end_behavior` is `roll`, customers pay regularly and repeatedly. If `end_behavior` is `close`, customers pay a total amount in a limited number of partial payments.
   */
  end_behavior?: "close" | "roll"
  /**
   * The subscriber can pause a subscription.
   */
  can_pause?: boolean
  /**
   * The subscriber can resume a paused subscription.
   */
  can_resume?: boolean
  /**
   * The subscriber can cancel a subscription.
   */
  can_cancel?: boolean
  /**
   * A percentage discount on the total cost of any plans within an offering. For example, you can configure a percentage that equates the cost of a pricing option to the total value of all plans within the offering, reduced by a percentage. For example, if you specify `10`, a 10% discount is applied to the total value of all repeat plans in an offering.
   */
  base_price_percentage?: number | null
  fixed_price?: NullablePrice
}

export type BuildOffering = {
  external_ref?: ExternalRef
  /**
   * The name of the offering.
   */
  name: string
  /**
   * The offering description to display to customers.
   */
  description?: string
  /**
   * The unique ID or external ref of the proration policy
   */
  proration_policy_id?: string
  configured_features?: OfferingBuildConfiguredFeatures
  pricing_option_associations?: OfferingBuildPricingOptionAssociations
  /**
   * Either references of existing features (id or external_ref) to be attached to the offering or feature information to be created directly within the offering
   */
  features?: Array<ExternalRef | FeatureAttributes | Uuid>
  /**
   * Plan information to be created within the offering
   */
  plans: Array<OfferingPlanAttributes>
  /**
   * Pricing options information to be created within the offering
   */
  pricing_options: Array<PricingOptionAttributes>
}

export type Offering = {
  id?: Uuid
  type: SubscriptionOfferingType
  attributes: OfferingResponseAttributes
  relationships?: Relationships
  meta: OfferingMeta
}

export type OfferingIncludes = {
  features?: Array<OfferingFeature>
  plans?: Array<OfferingPlan>
  pricing_options?: Array<OfferingPricingOption>
}

export type OfferingMeta = {
  external_plan_refs: Array<OfferingPlanExternalRefMeta>
  owner: OwnerMeta
  timestamps: Timestamps
}

export type OfferingCreate = {
  type: SubscriptionOfferingType
  attributes: OfferingAttributes
  relationships?: OfferingRelationships
}

export type OfferingPlanUpdate = {
  id: Uuid
  type: SubscriptionOfferingPlanType
  attributes: OfferingPlanUpdateAttributes
}

/**
 * Configures an access feature against a plan in an offering, indicating that the referenced feature is a benefit of that plan.
 */
export type FeatureConfigAccessAttributes = {
  type: "access"
}

/**
 * Configures a promotion feature against a plan in an offering, indicating that the referenced feature is a benefit of that plan. The tag of the specific promotion that it to be made available must be supplied.
 */
export type FeatureConfigPromotionAttributes = {
  type: "promotion"
  tag: FeatureTag
}

/**
 * Configures a usage feature against a plan in an offering, indicating that the referenced feature is a benefit of that plan. The default value that the usage metrics adopts must be supplied.
 */
export type FeatureConfigUsageAttributes = {
  type: "usage"
  /**
   * The default initial value
   */
  default_value: number
}

export type FeaturePlanConfiguration = (
  | ({
      type?: "access"
    } & FeatureConfigAccessAttributes)
  | ({
      type?: "promotion"
    } & FeatureConfigPromotionAttributes)
  | ({
      type?: "usage"
    } & FeatureConfigUsageAttributes)
) & {
  /**
   * The type of feature, one of access, promotion or usage.
   */
  type: "access" | "promotion" | "usage"
}

export type FeaturePlanConfigurationUpdate = (
  | ({
      type?: "access"
    } & FeatureConfigAccessAttributes)
  | ({
      type?: "promotion"
    } & FeatureConfigPromotionAttributes)
  | ({
      type?: "usage"
    } & FeatureConfigUsageAttributes)
  | null
) & {
  /**
   * The type of feature, one of access, promotion or usage.
   */
  type: "access" | "promotion" | "usage"
}

export type OfferingBuildPlanPricingOptions = Array<string>

/**
 * A map of plans keyed by plan UUID or external_ref to a list of associated pricing options, similarly keyed.
 */
export type OfferingBuildPricingOptionAssociations = {
  [key: string]: OfferingBuildPlanPricingOptions
}

/**
 * Map of feature configurations keyed by plan UUID or external_ref
 */
export type OfferingBuildConfiguredFeatures = {
  [key: string]: OfferingBuildPlanFeatures
}

/**
 * A map of configurations indicating which features are available for the plan
 */
export type OfferingBuildPlanFeatures = {
  [key: string]: FeaturePlanConfiguration
}

export type OfferingFeatureUpdate = {
  id: Uuid
  type: SubscriptionOfferingFeatureType
  attributes: FeatureUpdateAttributes
}

export type OfferingFeature = {
  id?: Uuid
  type: SubscriptionOfferingFeatureType
  attributes: FeatureResponseAttributes
  relationships?: Relationships
  meta: FeatureMeta
}

export type OfferingPlan = {
  id?: Uuid
  type: SubscriptionOfferingPlanType
  attributes: OfferingPlanResponseAttributes
  relationships?: Relationships
  meta: PlanMeta
}

export type OfferingPricingOptionUpdate = {
  id: Uuid
  type: SubscriptionOfferingPricingOptionType
  attributes: PricingOptionUpdateAttributes
}

export type OfferingPricingOption = {
  id?: Uuid
  type: SubscriptionOfferingPricingOptionType
  attributes: PricingOptionResponseAttributes
  relationships?: Relationships
  meta: OfferingPricingOptionMeta
}

export type OfferingPricingOptionMeta = {
  prices?: OfferingPricingOptionPrices
  price?: Price
  display_price?: DisplayPrice
  active_pricing_option?: ActivePricingOption
  owner: OwnerMeta
  timestamps: Timestamps
}

/**
 * The price of each plan within the offering that this pricing option may be applied to.
 */
export type OfferingPricingOptionPrices = {
  [key: string]: OfferingPricingOptionPriceForPlan
}

export type OfferingPricingOptionPriceForPlan = {
  price?: Price
  display_price?: DisplayPrice
}

/**
 * A list of feature IDs to attach to the offering. See [**List Features**](/docs/api/subscriptions/list-features).
 */
export type OfferingFeatureAttach = {
  features: Array<Uuid>
}

export type OfferingUpdate = unknown & {
  id: Uuid
  type: SubscriptionOfferingType
  attributes?: OfferingUpdateAttributes
  relationships?: OfferingUpdateRelationships
}

export type OfferingResponseAttributes = OfferingAttributes & Timestamps

export type OfferingAttributes = {
  external_ref?: ExternalRef
  /**
   * The name of the offering.
   */
  name: string
  /**
   * The offering description to display to customers.
   */
  description?: string
}

export type OfferingUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  /**
   * The name of the offering.
   */
  name?: string
  /**
   * The offering description to display to customers.
   */
  description?: string | null
}

export type OfferingRelationships = {
  proration_policy?: ProrationPolicyRelationshipAttributes
}

export type OfferingUpdateRelationships = {
  proration_policy?: ProrationPolicyUpdateRelationshipAttributes
}

/**
 * A subscription may optionally be associated with an item in an order by supplying both the order ID and the ID of the item within that order.
 */
export type BuildSubscriptionOrder = {
  order_id: Uuid
  order_item_id: Uuid
}

export type BuildSubscription = {
  external_ref?: ExternalRef
  account_id: Uuid
  address_id?: Uuid
  offering_external_ref?: ExternalRef
  offering_id?: Uuid
  plan_id?: Uuid
  pricing_option_id?: Uuid
  currency: CurrencyIdentifier
  payment_authority?: PaymentAuthority
  manual_payments: ManualPayments
  name: string
  email: string
  /**
   * Whether a subscription is pending activation or not. See [Creating a pending subscription](/docs/api/subscriptions/subscriptions#creating-a-pending-subscription).
   */
  pending?: boolean
  /**
   * Indicates that payment for the first billing period of the subscription has already been taken. As well as creating the subscription a settled invoice is created to cover the first period.
   */
  first_invoice_paid?: boolean
  /**
   * When importing an active subscription from an existing system you can specify the date and time of the start of the most recent period. This may only be supplied when `first_invoice_paid` is true. As well as creating the subscription a settled invoice is created to cover the correct billing period.
   */
  started_at?: string
  offering?: OfferingAttributes
  /**
   * Either references of existing features (id or external_ref) to be attached to the offering or feature information to be created directly within the offering
   */
  features?: Array<ExternalRef | FeatureAttributes | Uuid>
  plans?: Array<PlanAttributesAndSelectedMeta>
  pricing_options?: Array<PricingOptionAttributesAndSelectedMeta>
  configured_features?: OfferingBuildConfiguredFeatures
  pricing_option_associations?: OfferingBuildPricingOptionAssociations
  selected_plan?: ExternalRef
  selected_pricing_option?: ExternalRef
  order?: BuildSubscriptionOrder
  meta?: SubscriptionMeta
}

export type PricingOptionAttributesAndSelectedMeta = PricingOptionAttributes &
  SelectedMeta

export type PlanAttributesAndSelectedMeta = PlanAttributes & SelectedMeta

export type SelectedMeta = {
  meta?: SelectedMetaAttributes
}

export type SelectedMetaAttributes = {
  /**
   * One item must be selected for use in the subscription
   */
  selected?: boolean
}

export type Subscription = {
  id?: Uuid
  type: SubscriptionType
  attributes: SubscriptionAttributes
  relationships?: Relationships
  meta: SubscriptionMeta
}

export type ManageSubscriptionPlans = {
  type: "detach"
  plans: Array<Uuid>
}

export type SubscriptionUpdate = {
  id: Uuid
  type: SubscriptionType
  attributes: SubscriptionUpdateAttributes
}

export type SubscriptionUpdateAttributes = {
  pricing_option_id?: unknown
  plan_id?: unknown
  address_id?: string | null
  payment_authority?: PaymentAuthority
  /**
   * The date and time a `pending` subscription goes live and becomes active. See [Creating a pending subscription](/docs/api/subscriptions/subscriptions#creating-a-pending-subscription).
   */
  go_live_after?: string | null
}

export type SubscriptionIncludes = {
  plans?: Array<OfferingPlan>
  pricing_options?: Array<OfferingPricingOption>
}

export type SubscriptionMeta = {
  owner: OwnerMeta
  timestamps: SubscriptionTimestamps
  status: Status
  state?: SubscriptionState
  manual_payments: ManualPayments
  /**
   * Indicates that the first billing period of this subscription was paid for outside of the subscriptions service.
   */
  first_invoice_prepaid: boolean
  /**
   * Whether a subscription is canceled or not.
   */
  canceled: boolean
  /**
   * Whether a subscription is paused or not.
   */
  paused: boolean
  /**
   * Whether a subscription is closed or not.
   */
  closed: boolean
  /**
   * Whether a subscription is suspended or not.
   */
  suspended: boolean
  /**
   * Whether a subscription is pending activation or not.
   */
  pending: boolean
  /**
   * The time when the subscription becomes eligible for a new invoice. The next invoice will be generated at the next billing run after this point.
   */
  invoice_after: string
}

export type SubscriptionTimestamps = Timestamps & {
  /**
   * The date and time a subscription was cancelled.
   */
  canceled_at?: string
  /**
   * The date and time a subscription was paused.
   */
  paused_at?: string
  /**
   * The date and time a subscription was resumed.
   */
  resumed_at?: string
  /**
   * The date and time a subscription will end.
   */
  end_date?: string
  /**
   * The date and time a subscription will go live and become active.
   */
  go_live_after?: string
  /**
   * The date and time a subscription was released from the pending state and made active.
   */
  go_live?: string
}

export type SubscriptionAttributes = {
  external_ref?: ExternalRef
  account_id: Uuid
  address_id?: Uuid
  offering: Offering
  pricing_option_id: Uuid
  plan_id: Uuid
  currency: CurrencyIdentifier
  payment_authority?: PaymentAuthority
}

export type ChangeState = {
  type: SubscriptionStateType
  attributes: SubscriptionStateAttributes
}

export type SubscriptionStateAttributes = {
  action: SubscriptionStateAction
}

/**
 * This represents the type of resource object being returned. Always `subscription_state`.
 */
export type SubscriptionStateType = "subscription_state"

/**
 * The subscription lifecycle is the states that a subscription can go through when a customer subscribes to a service or a plan.
 *
 * A subscription can have the following states; `canceled`, `paused`, or `resumed`.
 *
 * See [**Managing the subscription lifecycle**](/docs/api/subscriptions/subscriptions#managing-the-subscription-lifecycle).
 *
 */
export type SubscriptionStateAction = "cancel" | "pause" | "resume" | "pending"

export type StateMeta = {
  /**
   * The date and time a resource was created.
   */
  created_at: string
}

export type SubscriptionState = {
  id?: Uuid
  type: SubscriptionStateType
  attributes: SubscriptionStateAttributes
  meta: StateMeta
}

/**
 * When configured to true, no payment gateway is used and a pending payment is created. See [External Payments](/docs/api/subscriptions/invoices#external-payments).
 */
export type ManualPayments = boolean

export type PaymentAuthority = (
  | ({
      type?: "elastic_path_payments_stripe"
    } & PaymentAuthorityStripe)
  | ({
      type?: "authorize_net"
    } & PaymentAuthorityAuthorizeNet)
) & {
  /**
   * The name of the payment gateway facilitating the secure transmission of payment data.
   */
  type: "authorize_net" | "elastic_path_payments_stripe"
}

export type NullablePaymentAuthority = (
  | ({
      type?: "elastic_path_payments_stripe"
    } & PaymentAuthorityStripe)
  | ({
      type?: "authorize_net"
    } & PaymentAuthorityAuthorizeNet)
  | null
) & {
  /**
   * The name of the payment gateway facilitating the secure transmission of payment data.
   */
  type: "authorize_net" | "elastic_path_payments_stripe"
}

export type PaymentAuthorityAuthorizeNet = {
  /**
   * The name of the payment gateway facilitating the secure transmission of payment data.
   */
  type: "authorize_net"
  /**
   * The customer's payment profile id, unique to Authorize.net, used to facilitate payment of the subscription.
   */
  payment_profile_id?: string
  /**
   * The customer's profile id, unique to Authorize.net, used to facilitate payment of the subscription.
   */
  customer_profile_id?: string
}

export type PaymentAuthorityStripe = {
  /**
   * The name of the payment gateway facilitating the secure transmission of payment data.
   */
  type: "elastic_path_payments_stripe"
  /**
   * The unique identifier for a customer.
   */
  customer_id?: string
  /**
   * The unique identifier of the card used to facilitate payment of the subscription. If a card payment fails, you can use the `card_id` and `customer_id` attributes to program your front-end implementation to allow your preferred payment service provider to update a subscription with new card details. See [Card declines](/docs/api/subscriptions/invoices#card-declines).
   */
  card_id?: string
}

export type Import = {
  id?: Uuid
  type: SubscriptionImportType
  attributes: ImportAttributes
  meta: ImportMeta
}

/**
 * The status of job.
 * - **pending** - Commerce has received the request but is currently busy processing other requests.
 * - **started** - Commerce has started processing the job.
 * - **success** - The job has successfully completed.
 * - **failed** - The job has failed.
 *
 */
export type Status2 = "pending" | "started" | "success" | "failed"

export type ImportAttributes = {
  external_ref?: ExternalRef
  /**
   * The status of job.
   * - **pending** - Commerce has received the request but is currently busy processing other requests.
   * - **started** - Commerce has started processing the job.
   * - **success** - The job has successfully completed.
   * - **failed** - The job has failed.
   *
   */
  status: "pending" | "started" | "success" | "failed"
}

export type ImportMeta = {
  owner: OwnerMeta
  timestamps: JobTimestamps
  records: ImportRecords
}

/**
 * You can track the number of records imported to ensure the completeness, accuracy and integrity of the import. Uploaded shows the number of records ready to be imported into Subscriptions. However, this does not mean they are valid subscription objects, only that they have the correct type and their JSON format is properly formatted. Imported shows the number of records that have been both validated and successfully added to Subscriptions.
 */
export type ImportRecords = {
  uploaded: {
    /**
     * The total number of features uploaded.
     */
    subscription_feature: number
    /**
     * The total number of subscribers uploaded.
     */
    subscription_subscriber: number
    /**
     * The total number of offerings uploaded.
     */
    subscription_offering: number
    /**
     * The total number of subscriptions uploaded.
     */
    subscription: number
  }
  imported: {
    /**
     * The total number of features uploaded.
     */
    subscription_feature: number
    /**
     * The total number of subscribers imported.
     */
    subscription_subscriber: number
    /**
     * The total number of offerings imported.
     */
    subscription_offering: number
    /**
     * The total number of subscriptions imported.
     */
    subscription: number
  }
}

export type Job = {
  id?: Uuid
  type: SubscriptionJobType
  attributes: JobResponseAttributes
  relationships?: Relationships
  meta: JobMeta
}

export type JobMeta = {
  owner: OwnerMeta
  timestamps: JobTimestamps
  report?: JobReport
}

/**
 * You can track your Subscriptions billing, tax, and payment operations using reports.
 */
export type JobReport = BillingRunReport | TaxRunReport | PaymentRunReport

export type BillingRunReport = {
  /**
   * The total number of invoices created that are ready for payment.
   */
  invoices_ready_for_payment: number
  /**
   * The total number of invoices created that need taxes to be applied before payment can be made.
   */
  invoices_tax_required: number
  /**
   * The total number of invoices that were scheduled but creation failed.
   */
  invoice_failures: number
  total_ready_for_payment: unknown & Price
  total_tax_required: unknown & Price
}

export type TaxRunReport = {
  /**
   * The total number of invoices to which tax was successfully added.
   */
  invoices_updated: number
  /**
   * The total number of invoices to which tax could not be added.
   */
  invoice_failures: number
}

export type PaymentRunReport = {
  /**
   * The total number of invoices for which payment was attempted.
   */
  total_payment_attempts: number
  /**
   * The number of failed payment attempts.
   */
  failed_payments: number
  total_collected: unknown & Price
}

export type JobTimestamps = Timestamps & {
  /**
   * The date and time a job is started.
   */
  started_at?: string
  /**
   * The date and time a job finished.
   */
  finished_at?: string
}

export type JobCreate = {
  type: SubscriptionJobType
  attributes: JobCreateAttributes
}

export type JobResponseAttributes = JobCreateAttributes &
  JobAttributes &
  Timestamps

/**
 * The type of job. One of the following:
 * - `billing_run` - a billing run job.
 * - `payment_run` - a payment run job.
 * - `tax_run` - a tax run job.
 *
 */
export type JobType = "billing-run" | "tax-run" | "payment-run" | "import"

export type JobCreateAttributes = {
  external_ref?: ExternalRef
  job_type: JobType
  taxes?: Array<InvoiceTaxItems>
}

export type JobAttributes = {
  external_ref?: ExternalRef
  /**
   * The status of job.
   */
  status: "pending" | "started" | "success" | "failed"
}

export type InvoiceTaxItems = {
  invoice_id: Uuid
  tax_items: Array<TaxItem>
}

export type TaxItem = {
  /**
   * This represents the type of resource object being returned. Always `tax_item`.
   */
  type: "tax_item"
  /**
   * The name that appears on your customer's invoice and usually describes the specific type of tax, for example, `Sales`, `VAT` or `GST`.
   */
  name?: string
  /**
   * The unique identifier assigned to goods and services for taxation purposes.
   */
  code?: string
  /**
   * The tax rate is the percentage of the subscription amount that is required to be paid as tax.
   */
  rate: number
  /**
   * The geographic area or political entity that has authority to levy and collect taxes.
   */
  jurisdiction?: string
}

export type SubscriptionInvoice = {
  id?: Uuid
  type: SubscriptionInvoiceType
  attributes: SubscriptionInvoiceAttributes
  relationships?: Relationships
  meta: SubscriptionInvoiceMeta
}

export type UpdateInvoicePayment = {
  id: Uuid
  type: SubscriptionInvoicePaymentType
  attributes: UpdateInvoicePaymentAttributes
}

export type UpdateInvoicePaymentAttributes = {
  /**
   * Whether the payment was successful.
   */
  success: boolean
  /**
   * An optional external ID that is specific to the gateway used.
   */
  external_payment_id?: string
  /**
   * A message generated by an external payment method that describes why a payment fails.
   */
  failure_detail?: string
  /**
   * The date and time the invoice payment was taken at.
   */
  payment_taken_at?: string
}

export type SubscriptionInvoicePayment = {
  id: Uuid
  type: SubscriptionInvoicePaymentType
  attributes: SubscriptionInvoicePaymentAttributes
  meta: SubscriptionInvoicePaymentMeta
}

export type SubscriptionInvoiceMeta = {
  owner: OwnerMeta
  subscription_id?: Uuid
  subscriber_id?: Uuid
  price?: SingleCurrencyPrice
  timestamps: InvoiceTimestamps
  proration_events: Array<ProrationEvent>
}

export type ProrationEvent = {
  proration_policy_id: Uuid
  /**
   * The value as a whole number of the currency's smallest subdivision
   */
  billing_cost_before_proration: BigInt
  /**
   * The value as a whole number of the currency's smallest subdivision.
   */
  refunded_amount_for_unused_pricing_option: BigInt
  /**
   * The value as a whole number of the currency's smallest subdivision.
   */
  new_pricing_option_cost: BigInt
  /**
   * The date and time the subscription was prorated.
   */
  prorated_at: string
}

export type InvoiceTimestamps = Timestamps & {
  /**
   * The date and time taxes were added to an invoice.
   */
  taxes_added_at?: string
}

export type SubscriptionInvoicePaymentMeta = {
  owner: OwnerMeta
  subscription_id: Uuid
  invoice_id: Uuid
  job_id: Uuid
  timestamps: InvoicePaymentTimestamps
  /**
   * Whether manual payments are enabled or the payment will be handled by the configured gateway.
   */
  manual_payment: boolean
}

export type InvoicePaymentTimestamps = Timestamps & {
  /**
   * The date and time a payment was taken.
   */
  payment_taken_at?: string
}

export type SubscriptionInvoiceAttributes = {
  billing_period: TimePeriod
  invoice_items: Array<SubscriptionInvoiceItem>
  tax_items?: Array<TaxItem>
  /**
   * The invoice still requires payment if `true`.
   */
  outstanding: boolean
  /**
   * A sequential number assigned by the billing run.
   */
  number?: number
  /**
   * Whether tax is required for this invoice.
   */
  tax_required: boolean
  /**
   * Whether the limit of payment retries has been reached.
   */
  payment_retries_limit_reached: boolean
  /**
   * The date and time an invoice was updated.
   */
  updated_at?: string
  /**
   * The date and time an invoice was created.
   */
  created_at?: string
  /**
   * Whether there is a manual pending payment pending on the invoice.
   */
  manual_payment_pending: boolean
}

export type SubscriptionInvoicePaymentAttributes = {
  /**
   * Whether the payment was successful.
   */
  success: boolean
  /**
   * Whether the payment is pending (only for manual payments).
   */
  pending?: boolean
  /**
   * Specifies the payment gateway.
   */
  gateway: string
  /**
   * An optional external ID that is specific to the gateway used.
   */
  external_payment_id?: string
  failure_detail?: PaymentFailureDetail
  amount: SingleCurrencyPrice
}

/**
 * The reason the payment failed.
 */
export type PaymentFailureDetail = {
  reason?: string
}

export type SubscriptionInvoiceItem = {
  /**
   * A description of the subscribed item.
   */
  description: string
  price: SingleCurrencyPrice
  plan_id?: Uuid
  /**
   * The start date and time of the billing period in this price
   */
  from_time_period?: string
  /**
   * The end date and time of the billing period in this price
   */
  until_time_period?: string
}

export type ErrorResponse = {
  errors: Array<_Error>
}

export type _Error = {
  /**
   * The HTTP response code of the error.
   */
  status: string
  /**
   * A brief summary of the error.
   */
  title: string
  /**
   * Optional additional detail about the error.
   */
  detail?: string
  /**
   * Additional supporting meta data for the error.
   */
  meta?: {
    [key: string]: unknown
  }
}

/**
 * The three-letter [**ISO currency code**](https://www.iso.org/iso-4217-currency-codes.html) in uppercase.
 */
export type CurrencyIdentifier = string

/**
 * The unique identifier.
 */
export type Uuid = string

/**
 * The owner of a resource, either `store` or `organization`.
 */
export type OwnerMeta = string

/**
 * The offerings plan external_ref value
 */
export type OfferingPlanExternalRefMeta = string

export type Subscriber = {
  id?: Uuid
  type: SubscriptionSubscriberType
  attributes: SubscriberResponseAttributes
  meta: SubscriberMeta
}

export type SubscriberMeta = {
  /**
   * A list of entitlement tags currently active for the subscriber
   */
  feature_entitlements?: Array<FeatureTag>
  owner: OwnerMeta
  timestamps: Timestamps
}

export type SubscriptionSubscriberType = "subscription_subscriber"

export type SubscriberResponseAttributes = SubscriberAttributes & Timestamps

export type SubscriberAttributes = {
  account_id: Uuid
  /**
   * The name of the subscriber.
   */
  name: string
  /**
   * The email of the subscriber.
   */
  email: string
  payment_authority?: PaymentAuthority
}

export type SubscriberUpdateAttributes = {
  /**
   * The name of the subscriber.
   */
  name?: string
  /**
   * The email of the subscriber.
   */
  email?: string
  payment_authority?: NullablePaymentAuthority
}

export type SubscriberCreate = {
  type: SubscriptionSubscriberType
  attributes: SubscriberAttributes
}

export type SubscriberUpdate = {
  id: Uuid
  type: SubscriptionSubscriberType
  attributes: SubscriberUpdateAttributes
}

export type ScheduleCreate = {
  type: SubscriptionScheduleType
  attributes: ScheduleAttributes
}

export type Schedule = {
  id?: Uuid
  type: SubscriptionScheduleType
  attributes: ScheduleResponseAttributes
  meta: ScheduleMeta
}

export type ScheduleMeta = {
  scheduled_for?: Date
  owner: OwnerMeta
  timestamps: Timestamps
}

export type SubscriptionScheduleType = "subscription_schedule"

export type ScheduleResponseAttributes = ScheduleAttributes & Timestamps

export type ScheduleAttributes = {
  external_ref?: ExternalRef
  /**
   * The name of the schedule.
   */
  name?: string
  /**
   * A cron-style specification of when the jobs should be created. See [**Schedules**](/docs/api/subscriptions/schedules).
   */
  specification: string
  /**
   * The location of the time zone that the schedule operates in. Subscriptions runs on Coordinated Universal Time (UTC) time and conforms to [**RFC 3339**](https://www.rfc-editor.org/rfc/rfc3339).
   */
  location: string
  job: ScheduleJob
}

export type ScheduleUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  /**
   * The name of the schedule.
   */
  name?: string | null
  /**
   * A cron-style specification of when the jobs should be created.
   */
  specification?: string
  /**
   * The location of the time zone that the schedule operates in.
   */
  location?: string
  job?: ScheduleJob
}

export type ScheduleJob = {
  job_type: JobType
}

export type ScheduleUpdate = {
  id: Uuid
  type: SubscriptionScheduleType
  attributes: ScheduleUpdateAttributes
}

/**
 * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
 */
export type OfferingInclude = Array<"plans" | "pricing_options" | "features">

/**
 * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
 */
export type SubscriptionInclude = Array<"plans" | "pricing_options">

/**
 * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
 *
 */
export type Filter = string

/**
 * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
 */
export type PageOffset = BigInt

/**
 * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
 */
export type PageLimit = BigInt

export type ListOfferingsData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
     */
    include?: Array<"plans" | "pricing_options" | "features">
  }
  url: "/subscriptions/offerings"
}

export type ListOfferingsErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListOfferingsError = ListOfferingsErrors[keyof ListOfferingsErrors]

export type ListOfferingsResponses = {
  /**
   * Success. A list of offerings is returned.
   */
  200: {
    data?: Array<Offering>
    included?: OfferingIncludes
    links?: Links
  }
}

export type ListOfferingsResponse =
  ListOfferingsResponses[keyof ListOfferingsResponses]

export type CreateOfferingData = {
  body?: {
    data: OfferingCreate
  }
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/subscriptions/offerings"
}

export type CreateOfferingErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateOfferingError =
  CreateOfferingErrors[keyof CreateOfferingErrors]

export type CreateOfferingResponses = {
  /**
   * Success. The offering is created.
   */
  201: {
    data?: Offering
  }
}

export type CreateOfferingResponse =
  CreateOfferingResponses[keyof CreateOfferingResponses]

export type BuildOfferingData = {
  body?: {
    data: BuildOffering
  }
  path?: never
  query?: never
  url: "/subscriptions/offerings/build"
}

export type BuildOfferingErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type BuildOfferingError = BuildOfferingErrors[keyof BuildOfferingErrors]

export type BuildOfferingResponses = {
  /**
   * Success. The new subscription offering is created with the specified subscription plans and pricing options attached to the offering.
   */
  201: {
    data?: Offering
  }
}

export type BuildOfferingResponse =
  BuildOfferingResponses[keyof BuildOfferingResponses]

export type DeleteOfferingData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}"
}

export type DeleteOfferingErrors = {
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type DeleteOfferingError =
  DeleteOfferingErrors[keyof DeleteOfferingErrors]

export type DeleteOfferingResponses = {
  /**
   * Success. The subscription offering is removed.
   */
  204: void
}

export type DeleteOfferingResponse =
  DeleteOfferingResponses[keyof DeleteOfferingResponses]

export type GetOfferingData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: {
    /**
     * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
     */
    include?: Array<"plans" | "pricing_options" | "features">
  }
  url: "/subscriptions/offerings/{offering_uuid}"
}

export type GetOfferingErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetOfferingError = GetOfferingErrors[keyof GetOfferingErrors]

export type GetOfferingResponses = {
  /**
   * Success. The details of the subscription offering are returned.
   */
  200: {
    data?: Offering
    included?: OfferingIncludes
  }
}

export type GetOfferingResponse =
  GetOfferingResponses[keyof GetOfferingResponses]

export type UpdateOfferingData = {
  body?: {
    data: OfferingUpdate
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}"
}

export type UpdateOfferingErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateOfferingError =
  UpdateOfferingErrors[keyof UpdateOfferingErrors]

export type UpdateOfferingResponses = {
  /**
   * Success. The details of the subscription offering are updated.
   */
  200: {
    data?: Offering
  }
}

export type UpdateOfferingResponse =
  UpdateOfferingResponses[keyof UpdateOfferingResponses]

export type DeleteOfferingFeatureData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
    /**
     * The unique identifier of the feature.
     */
    feature_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/features/{feature_uuid}"
}

export type DeleteOfferingFeatureErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
}

export type DeleteOfferingFeatureError =
  DeleteOfferingFeatureErrors[keyof DeleteOfferingFeatureErrors]

export type DeleteOfferingFeatureResponses = {
  /**
   * Success. The subscription feature is removed from the offering.
   */
  204: void
}

export type DeleteOfferingFeatureResponse =
  DeleteOfferingFeatureResponses[keyof DeleteOfferingFeatureResponses]

export type UpdateOfferingFeatureData = {
  body?: {
    data: OfferingFeatureUpdate
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
    /**
     * The unique identifier of the feature.
     */
    feature_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/features/{feature_uuid}"
}

export type UpdateOfferingFeatureErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateOfferingFeatureError =
  UpdateOfferingFeatureErrors[keyof UpdateOfferingFeatureErrors]

export type UpdateOfferingFeatureResponses = {
  /**
   * Success. The feature details are updated on the offering.
   */
  200: {
    data?: Feature
  }
}

export type UpdateOfferingFeatureResponse =
  UpdateOfferingFeatureResponses[keyof UpdateOfferingFeatureResponses]

export type AttachOfferingFeatureData = {
  body?: {
    data: OfferingFeatureAttach
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/features/attach"
}

export type AttachOfferingFeatureErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type AttachOfferingFeatureError =
  AttachOfferingFeatureErrors[keyof AttachOfferingFeatureErrors]

export type AttachOfferingFeatureResponses = {
  /**
   * Success. The subscription feature is attached with the offering.
   */
  200: {
    data?: Array<OfferingFeature>
  }
}

export type AttachOfferingFeatureResponse =
  AttachOfferingFeatureResponses[keyof AttachOfferingFeatureResponses]

export type ListOfferingPricingOptionsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/offerings/{offering_uuid}/pricing-options"
}

export type ListOfferingPricingOptionsErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListOfferingPricingOptionsError =
  ListOfferingPricingOptionsErrors[keyof ListOfferingPricingOptionsErrors]

export type ListOfferingPricingOptionsResponses = {
  /**
   * Success. A list of pricing options attached with the offering is returned.
   */
  200: {
    data?: Array<OfferingPricingOption>
    links?: Links
  }
}

export type ListOfferingPricingOptionsResponse =
  ListOfferingPricingOptionsResponses[keyof ListOfferingPricingOptionsResponses]

export type CreateOfferingPricingOptionData = {
  body?: {
    data: OfferingPricingOptionCreate
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/pricing-options"
}

export type CreateOfferingPricingOptionErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateOfferingPricingOptionError =
  CreateOfferingPricingOptionErrors[keyof CreateOfferingPricingOptionErrors]

export type CreateOfferingPricingOptionResponses = {
  /**
   * Success. The pricing option is created.
   */
  201: {
    data?: OfferingPricingOption
  }
}

export type CreateOfferingPricingOptionResponse =
  CreateOfferingPricingOptionResponses[keyof CreateOfferingPricingOptionResponses]

export type DeleteOfferingPricingOptionData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
    /**
     * The unique identifier of the pricing option.
     */
    pricing_option_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/pricing-options/{pricing_option_uuid}"
}

export type DeleteOfferingPricingOptionErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
}

export type DeleteOfferingPricingOptionError =
  DeleteOfferingPricingOptionErrors[keyof DeleteOfferingPricingOptionErrors]

export type DeleteOfferingPricingOptionResponses = {
  /**
   * Success. The subscription pricing option is no longer associated with the offering.
   */
  204: void
}

export type DeleteOfferingPricingOptionResponse =
  DeleteOfferingPricingOptionResponses[keyof DeleteOfferingPricingOptionResponses]

export type UpdateOfferingPricingOptionData = {
  body?: {
    data: OfferingPricingOptionUpdate
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
    /**
     * The unique identifier of the pricing option.
     */
    pricing_option_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/pricing-options/{pricing_option_uuid}"
}

export type UpdateOfferingPricingOptionErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateOfferingPricingOptionError =
  UpdateOfferingPricingOptionErrors[keyof UpdateOfferingPricingOptionErrors]

export type UpdateOfferingPricingOptionResponses = {
  /**
   * Success. The pricing option details are updated on the offering.
   */
  200: {
    data?: OfferingPricingOption
  }
}

export type UpdateOfferingPricingOptionResponse =
  UpdateOfferingPricingOptionResponses[keyof UpdateOfferingPricingOptionResponses]

export type ListOfferingFeaturesData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/offerings/{offering_uuid}/features"
}

export type ListOfferingFeaturesErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListOfferingFeaturesError =
  ListOfferingFeaturesErrors[keyof ListOfferingFeaturesErrors]

export type ListOfferingFeaturesResponses = {
  /**
   * Success. A list of subscription features attached to the offering is returned.
   */
  200: {
    data?: Array<OfferingFeature>
    links?: Links
  }
}

export type ListOfferingFeaturesResponse =
  ListOfferingFeaturesResponses[keyof ListOfferingFeaturesResponses]

export type CreateOfferingFeatureData = {
  body?: {
    data: OfferingFeatureCreate
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/features"
}

export type CreateOfferingFeatureErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateOfferingFeatureError =
  CreateOfferingFeatureErrors[keyof CreateOfferingFeatureErrors]

export type CreateOfferingFeatureResponses = {
  /**
   * Success. The feature is created.
   */
  201: {
    data?: OfferingFeature
  }
}

export type CreateOfferingFeatureResponse =
  CreateOfferingFeatureResponses[keyof CreateOfferingFeatureResponses]

export type ListOfferingPlansData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/offerings/{offering_uuid}/plans"
}

export type ListOfferingPlansErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListOfferingPlansError =
  ListOfferingPlansErrors[keyof ListOfferingPlansErrors]

export type ListOfferingPlansResponses = {
  /**
   * Success. A list of subscription plans attached to the offering is returned.
   */
  200: {
    data?: Array<OfferingPlan>
    links?: Links
  }
}

export type ListOfferingPlansResponse =
  ListOfferingPlansResponses[keyof ListOfferingPlansResponses]

export type CreateOfferingPlanData = {
  body?: {
    data: OfferingPlanCreate
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/plans"
}

export type CreateOfferingPlanErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateOfferingPlanError =
  CreateOfferingPlanErrors[keyof CreateOfferingPlanErrors]

export type CreateOfferingPlanResponses = {
  /**
   * Success. The plan is created.
   */
  201: {
    data?: OfferingPlan
  }
}

export type CreateOfferingPlanResponse =
  CreateOfferingPlanResponses[keyof CreateOfferingPlanResponses]

export type DeleteOfferingPlanData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
    /**
     * The unique identifier of the plan.
     */
    plan_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/plans/{plan_uuid}"
}

export type DeleteOfferingPlanErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
}

export type DeleteOfferingPlanError =
  DeleteOfferingPlanErrors[keyof DeleteOfferingPlanErrors]

export type DeleteOfferingPlanResponses = {
  /**
   * Success. The subscription plan is removed from the offering.
   */
  204: void
}

export type DeleteOfferingPlanResponse =
  DeleteOfferingPlanResponses[keyof DeleteOfferingPlanResponses]

export type UpdateOfferingPlanData = {
  body?: {
    data: OfferingPlanUpdate
  }
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
    /**
     * The unique identifier of the plan.
     */
    plan_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/plans/{plan_uuid}"
}

export type UpdateOfferingPlanErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateOfferingPlanError =
  UpdateOfferingPlanErrors[keyof UpdateOfferingPlanErrors]

export type UpdateOfferingPlanResponses = {
  /**
   * Success. The plan details are updated on the offering.
   */
  200: {
    data?: OfferingPlan
  }
}

export type UpdateOfferingPlanResponse =
  UpdateOfferingPlanResponses[keyof UpdateOfferingPlanResponses]

export type RemoveOfferingPlanPricingOptionsData = {
  body?: RelationshipsRequest
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
    /**
     * The unique identifier of the plan.
     */
    plan_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/plans/{plan_uuid}/relationships/pricing_options"
}

export type RemoveOfferingPlanPricingOptionsErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type RemoveOfferingPlanPricingOptionsError =
  RemoveOfferingPlanPricingOptionsErrors[keyof RemoveOfferingPlanPricingOptionsErrors]

export type RemoveOfferingPlanPricingOptionsResponses = {
  /**
   * Success. The pricing options are added to the plan
   */
  200: {
    data?: Array<RelationshipData>
  }
}

export type RemoveOfferingPlanPricingOptionsResponse =
  RemoveOfferingPlanPricingOptionsResponses[keyof RemoveOfferingPlanPricingOptionsResponses]

export type ListOfferingPlanPricingOptionsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
    /**
     * The unique identifier of the plan.
     */
    plan_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/plans/{plan_uuid}/relationships/pricing_options"
}

export type ListOfferingPlanPricingOptionsErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListOfferingPlanPricingOptionsError =
  ListOfferingPlanPricingOptionsErrors[keyof ListOfferingPlanPricingOptionsErrors]

export type ListOfferingPlanPricingOptionsResponses = {
  /**
   * Success. The pricing option relationships are returned
   */
  200: {
    data?: Array<RelationshipData>
  }
}

export type ListOfferingPlanPricingOptionsResponse =
  ListOfferingPlanPricingOptionsResponses[keyof ListOfferingPlanPricingOptionsResponses]

export type AddOfferingPlanPricingOptionsData = {
  body?: RelationshipsRequest
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: Uuid
    /**
     * The unique identifier of the plan.
     */
    plan_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/offerings/{offering_uuid}/plans/{plan_uuid}/relationships/pricing_options"
}

export type AddOfferingPlanPricingOptionsErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type AddOfferingPlanPricingOptionsError =
  AddOfferingPlanPricingOptionsErrors[keyof AddOfferingPlanPricingOptionsErrors]

export type AddOfferingPlanPricingOptionsResponses = {
  /**
   * Success. The pricing options are added to the plan
   */
  200: {
    data?: Array<RelationshipData>
  }
}

export type AddOfferingPlanPricingOptionsResponse =
  AddOfferingPlanPricingOptionsResponses[keyof AddOfferingPlanPricingOptionsResponses]

export type ListSubscriptionsData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
     */
    include?: Array<"plans" | "pricing_options">
  }
  url: "/subscriptions/subscriptions"
}

export type ListSubscriptionsErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListSubscriptionsError =
  ListSubscriptionsErrors[keyof ListSubscriptionsErrors]

export type ListSubscriptionsResponses = {
  /**
   * Success. A list of subscriptions is returned.
   */
  200: {
    data?: Array<Subscription>
    included?: SubscriptionIncludes
    links?: Links
  }
}

export type ListSubscriptionsResponse =
  ListSubscriptionsResponses[keyof ListSubscriptionsResponses]

export type CreateSubscriptionData = {
  body?: {
    data: BuildSubscription
  }
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/subscriptions/subscriptions"
}

export type CreateSubscriptionErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateSubscriptionError =
  CreateSubscriptionErrors[keyof CreateSubscriptionErrors]

export type CreateSubscriptionResponses = {
  /**
   * Success. The subscription is created.
   */
  201: {
    data?: Subscription
  }
}

export type CreateSubscriptionResponse =
  CreateSubscriptionResponses[keyof CreateSubscriptionResponses]

export type DeleteSubscriptionData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}"
}

export type DeleteSubscriptionErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type DeleteSubscriptionError =
  DeleteSubscriptionErrors[keyof DeleteSubscriptionErrors]

export type DeleteSubscriptionResponses = {
  /**
   * Success. The subscription is removed.
   */
  204: void
}

export type DeleteSubscriptionResponse =
  DeleteSubscriptionResponses[keyof DeleteSubscriptionResponses]

export type GetSubscriptionData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: {
    /**
     * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
     */
    include?: Array<"plans" | "pricing_options">
  }
  url: "/subscriptions/subscriptions/{subscription_uuid}"
}

export type GetSubscriptionErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetSubscriptionError =
  GetSubscriptionErrors[keyof GetSubscriptionErrors]

export type GetSubscriptionResponses = {
  /**
   * Success. The details of a subscription are returned.
   */
  200: {
    data?: Subscription
    included?: SubscriptionIncludes
  }
}

export type GetSubscriptionResponse =
  GetSubscriptionResponses[keyof GetSubscriptionResponses]

export type UpdateSubscriptionData = {
  body?: {
    data: SubscriptionUpdate
  }
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}"
}

export type UpdateSubscriptionErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateSubscriptionError =
  UpdateSubscriptionErrors[keyof UpdateSubscriptionErrors]

export type UpdateSubscriptionResponses = {
  /**
   * Success. The subscription is updated.
   */
  200: {
    data?: Subscription
  }
}

export type UpdateSubscriptionResponse =
  UpdateSubscriptionResponses[keyof UpdateSubscriptionResponses]

export type ListSubscriptionPlansData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/plans"
}

export type ListSubscriptionPlansErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListSubscriptionPlansError =
  ListSubscriptionPlansErrors[keyof ListSubscriptionPlansErrors]

export type ListSubscriptionPlansResponses = {
  /**
   * Success. A list of subscription plans is returned.
   */
  200: {
    data?: Array<OfferingPlan>
  }
}

export type ListSubscriptionPlansResponse =
  ListSubscriptionPlansResponses[keyof ListSubscriptionPlansResponses]

export type ManageSubscriptionPlansData = {
  body?: {
    /**
     * A list of plan IDs to manage on the subscription.
     */
    data: Array<ManageSubscriptionPlans>
  }
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/plans"
}

export type ManageSubscriptionPlansErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ManageSubscriptionPlansError =
  ManageSubscriptionPlansErrors[keyof ManageSubscriptionPlansErrors]

export type ManageSubscriptionPlansResponses = {
  /**
   * Success. The subscription's plans have been updated.
   */
  204: void
}

export type ManageSubscriptionPlansResponse =
  ManageSubscriptionPlansResponses[keyof ManageSubscriptionPlansResponses]

export type ListSubscriptionPricingOptionsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/pricing-options"
}

export type ListSubscriptionPricingOptionsErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListSubscriptionPricingOptionsError =
  ListSubscriptionPricingOptionsErrors[keyof ListSubscriptionPricingOptionsErrors]

export type ListSubscriptionPricingOptionsResponses = {
  /**
   * Success. A list of subscription pricing options is returned.
   */
  200: {
    data?: Array<OfferingPricingOption>
  }
}

export type ListSubscriptionPricingOptionsResponse =
  ListSubscriptionPricingOptionsResponses[keyof ListSubscriptionPricingOptionsResponses]

export type ListSubscriptionStatesData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/states"
}

export type ListSubscriptionStatesErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListSubscriptionStatesError =
  ListSubscriptionStatesErrors[keyof ListSubscriptionStatesErrors]

export type ListSubscriptionStatesResponses = {
  /**
   * Success. A list of subscription states is returned.
   */
  200: {
    data?: Array<SubscriptionState>
  }
}

export type ListSubscriptionStatesResponse =
  ListSubscriptionStatesResponses[keyof ListSubscriptionStatesResponses]

export type CreateSubscriptionStateData = {
  body?: {
    data: ChangeState
  }
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/states"
}

export type CreateSubscriptionStateErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateSubscriptionStateError =
  CreateSubscriptionStateErrors[keyof CreateSubscriptionStateErrors]

export type CreateSubscriptionStateResponses = {
  /**
   * Success. The subscription's state has changed.
   */
  204: void
}

export type CreateSubscriptionStateResponse =
  CreateSubscriptionStateResponses[keyof CreateSubscriptionStateResponses]

export type GetSubscriptionStateData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
    /**
     * The unique identifier of the subscription state.
     */
    state_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/states/{state_uuid}"
}

export type GetSubscriptionStateErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetSubscriptionStateError =
  GetSubscriptionStateErrors[keyof GetSubscriptionStateErrors]

export type GetSubscriptionStateResponses = {
  /**
   * Success. A subscription state is returned.
   */
  200: {
    data?: SubscriptionState
  }
}

export type GetSubscriptionStateResponse =
  GetSubscriptionStateResponses[keyof GetSubscriptionStateResponses]

export type ListJobsData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/jobs"
}

export type ListJobsErrors = {
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListJobsError = ListJobsErrors[keyof ListJobsErrors]

export type ListJobsResponses = {
  /**
   * Success. A list of jobs is returned.
   */
  200: {
    data?: Array<Job>
    links?: Links
  }
}

export type ListJobsResponse = ListJobsResponses[keyof ListJobsResponses]

export type CreateJobData = {
  body?: {
    data: JobCreate
  }
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/subscriptions/jobs"
}

export type CreateJobErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateJobError = CreateJobErrors[keyof CreateJobErrors]

export type CreateJobResponses = {
  /**
   * Success. The job was created.
   */
  201: {
    data?: Job
  }
}

export type CreateJobResponse = CreateJobResponses[keyof CreateJobResponses]

export type DeleteJobData = {
  body?: never
  path: {
    /**
     * The unique identifier of the job.
     */
    job_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/jobs/{job_uuid}"
}

export type DeleteJobErrors = {
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
}

export type DeleteJobError = DeleteJobErrors[keyof DeleteJobErrors]

export type DeleteJobResponses = {
  /**
   * Success. The job was deleted.
   */
  204: void
}

export type DeleteJobResponse = DeleteJobResponses[keyof DeleteJobResponses]

export type GetJobData = {
  body?: never
  path: {
    /**
     * The unique identifier of the job.
     */
    job_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/jobs/{job_uuid}"
}

export type GetJobErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetJobError = GetJobErrors[keyof GetJobErrors]

export type GetJobResponses = {
  /**
   * Success. The job is returned.
   */
  200: {
    data?: Job
  }
}

export type GetJobResponse = GetJobResponses[keyof GetJobResponses]

export type ListImportJobsData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/imports"
}

export type ListImportJobsErrors = {
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListImportJobsError =
  ListImportJobsErrors[keyof ListImportJobsErrors]

export type ListImportJobsResponses = {
  /**
   * Success. A list of import jobs is returned.
   */
  200: {
    data?: Array<Import>
    links?: Links
  }
}

export type ListImportJobsResponse =
  ListImportJobsResponses[keyof ListImportJobsResponses]

export type CreateImportData = {
  body?: {
    external_ref?: ExternalRef
    /**
     * The JSONL file you want to upload.
     */
    import_file: Blob | File
  }
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/subscriptions/imports"
}

export type CreateImportErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateImportError = CreateImportErrors[keyof CreateImportErrors]

export type CreateImportResponses = {
  /**
   * Success. The import was started.
   */
  201: {
    data?: Import
  }
}

export type CreateImportResponse =
  CreateImportResponses[keyof CreateImportResponses]

export type GetImportData = {
  body?: never
  path: {
    /**
     * The unique identifier of the import.
     */
    import_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/imports/{import_uuid}"
}

export type GetImportErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetImportError = GetImportErrors[keyof GetImportErrors]

export type GetImportResponses = {
  /**
   * Success. The import is returned.
   */
  200: {
    data?: Import
  }
}

export type GetImportResponse = GetImportResponses[keyof GetImportResponses]

export type GetImportErrorsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the import.
     */
    import_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/imports/{import_uuid}/errors"
}

export type GetImportErrorsErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetImportErrorsError =
  GetImportErrorsErrors[keyof GetImportErrorsErrors]

export type GetImportErrorsResponses = {
  /**
   * Success. The import errors are returned.
   */
  200: {
    data?: Array<SubscriptionImportError>
    links?: Links
  }
}

export type GetImportErrorsResponse =
  GetImportErrorsResponses[keyof GetImportErrorsResponses]

export type ListSubscriptionInvoicesData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/subscriptions/{subscription_uuid}/invoices"
}

export type ListSubscriptionInvoicesErrors = {
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListSubscriptionInvoicesError =
  ListSubscriptionInvoicesErrors[keyof ListSubscriptionInvoicesErrors]

export type ListSubscriptionInvoicesResponses = {
  /**
   * Success. A list of invoices is returned.
   */
  200: {
    data?: Array<SubscriptionInvoice>
    links?: Links
  }
}

export type ListSubscriptionInvoicesResponse =
  ListSubscriptionInvoicesResponses[keyof ListSubscriptionInvoicesResponses]

export type ListSubscriptionInvoicePaymentsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/subscriptions/{subscription_uuid}/invoices/{invoice_uuid}/payments"
}

export type ListSubscriptionInvoicePaymentsResponses = {
  /**
   * Success. Payments for the invoice are returned.
   */
  200: {
    data?: Array<SubscriptionInvoicePayment>
    links?: Links
  }
}

export type ListSubscriptionInvoicePaymentsResponse =
  ListSubscriptionInvoicePaymentsResponses[keyof ListSubscriptionInvoicePaymentsResponses]

export type GetSubscriptionInvoicePaymentData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: Uuid
    /**
     * The unique identifier of the payment.
     */
    payment_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/invoices/{invoice_uuid}/payments/{payment_uuid}"
}

export type GetSubscriptionInvoicePaymentErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
}

export type GetSubscriptionInvoicePaymentError =
  GetSubscriptionInvoicePaymentErrors[keyof GetSubscriptionInvoicePaymentErrors]

export type GetSubscriptionInvoicePaymentResponses = {
  /**
   * Success. Specific payment for the invoice is returned.
   */
  200: {
    data?: SubscriptionInvoicePayment
  }
}

export type GetSubscriptionInvoicePaymentResponse =
  GetSubscriptionInvoicePaymentResponses[keyof GetSubscriptionInvoicePaymentResponses]

export type GetSubscriptionInvoiceData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: Uuid
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscriptions/{subscription_uuid}/invoices/{invoice_uuid}"
}

export type GetSubscriptionInvoiceErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetSubscriptionInvoiceError =
  GetSubscriptionInvoiceErrors[keyof GetSubscriptionInvoiceErrors]

export type GetSubscriptionInvoiceResponses = {
  /**
   * Success. An invoice is returned.
   */
  200: {
    data?: SubscriptionInvoice
  }
}

export type GetSubscriptionInvoiceResponse =
  GetSubscriptionInvoiceResponses[keyof GetSubscriptionInvoiceResponses]

export type ListInvoicesData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/invoices"
}

export type ListInvoicesErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListInvoicesError = ListInvoicesErrors[keyof ListInvoicesErrors]

export type ListInvoicesResponses = {
  /**
   * Success. A list of invoices is returned.
   */
  200: {
    data?: Array<SubscriptionInvoice>
    links?: Links
  }
}

export type ListInvoicesResponse =
  ListInvoicesResponses[keyof ListInvoicesResponses]

export type GetInvoiceData = {
  body?: never
  path: {
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/invoices/{invoice_uuid}"
}

export type GetInvoiceErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetInvoiceError = GetInvoiceErrors[keyof GetInvoiceErrors]

export type GetInvoiceResponses = {
  /**
   * Success. The details of the invoice are returned.
   */
  200: {
    data?: SubscriptionInvoice
  }
}

export type GetInvoiceResponse = GetInvoiceResponses[keyof GetInvoiceResponses]

export type ListInvoicePaymentsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: Uuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/invoices/{invoice_uuid}/payments"
}

export type ListInvoicePaymentsResponses = {
  /**
   * Success. Payments for the invoice are returned
   */
  200: {
    data?: Array<SubscriptionInvoicePayment>
    links?: Links
  }
}

export type ListInvoicePaymentsResponse =
  ListInvoicePaymentsResponses[keyof ListInvoicePaymentsResponses]

export type GetInvoicePaymentData = {
  body?: never
  path: {
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: Uuid
    /**
     * The unique identifier of the payment.
     */
    payment_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/invoices/{invoice_uuid}/payments/{payment_uuid}"
}

export type GetInvoicePaymentErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
}

export type GetInvoicePaymentError =
  GetInvoicePaymentErrors[keyof GetInvoicePaymentErrors]

export type GetInvoicePaymentResponses = {
  /**
   * Success. Specific payment for the invoice is returned
   */
  200: {
    data?: SubscriptionInvoicePayment
  }
}

export type GetInvoicePaymentResponse =
  GetInvoicePaymentResponses[keyof GetInvoicePaymentResponses]

export type UpdateInvoicePaymentData = {
  body?: {
    data: UpdateInvoicePayment
  }
  path: {
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: Uuid
    /**
     * The unique identifier of the payment.
     */
    payment_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/invoices/{invoice_uuid}/payments/{payment_uuid}"
}

export type UpdateInvoicePaymentErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateInvoicePaymentError =
  UpdateInvoicePaymentErrors[keyof UpdateInvoicePaymentErrors]

export type UpdateInvoicePaymentResponses = {
  /**
   * Success. Invoice payment has been updated.
   */
  200: {
    data: SubscriptionInvoicePayment
  }
}

export type UpdateInvoicePaymentResponse =
  UpdateInvoicePaymentResponses[keyof UpdateInvoicePaymentResponses]

export type ListSchedulesData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/schedules"
}

export type ListSchedulesErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListSchedulesError = ListSchedulesErrors[keyof ListSchedulesErrors]

export type ListSchedulesResponses = {
  /**
   * Success. A list of schedules is returned.
   */
  200: {
    data?: Array<Schedule>
    links?: Links
  }
}

export type ListSchedulesResponse =
  ListSchedulesResponses[keyof ListSchedulesResponses]

export type CreateScheduleData = {
  body?: {
    data: ScheduleCreate
  }
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/subscriptions/schedules"
}

export type CreateScheduleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateScheduleError =
  CreateScheduleErrors[keyof CreateScheduleErrors]

export type CreateScheduleResponses = {
  /**
   * Success. The schedule is created.
   */
  201: {
    data?: Schedule
  }
}

export type CreateScheduleResponse =
  CreateScheduleResponses[keyof CreateScheduleResponses]

export type DeleteScheduleData = {
  body?: never
  path: {
    /**
     * The unique identifier of the schedule.
     */
    schedule_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/schedules/{schedule_uuid}"
}

export type DeleteScheduleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type DeleteScheduleError =
  DeleteScheduleErrors[keyof DeleteScheduleErrors]

export type DeleteScheduleResponses = {
  /**
   * Success. The schedule is removed.
   */
  204: void
}

export type DeleteScheduleResponse =
  DeleteScheduleResponses[keyof DeleteScheduleResponses]

export type GetScheduleData = {
  body?: never
  path: {
    /**
     * The unique identifier of the schedule.
     */
    schedule_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/schedules/{schedule_uuid}"
}

export type GetScheduleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetScheduleError = GetScheduleErrors[keyof GetScheduleErrors]

export type GetScheduleResponses = {
  /**
   * Success. A schedule is returned.
   */
  200: {
    data?: Schedule
  }
}

export type GetScheduleResponse =
  GetScheduleResponses[keyof GetScheduleResponses]

export type UpdateScheduleData = {
  body?: {
    data: ScheduleUpdate
  }
  path: {
    /**
     * The unique identifier of the schedule.
     */
    schedule_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/schedules/{schedule_uuid}"
}

export type UpdateScheduleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateScheduleError =
  UpdateScheduleErrors[keyof UpdateScheduleErrors]

export type UpdateScheduleResponses = {
  /**
   * Success. The schedule details are returned.
   */
  200: {
    data?: Schedule
  }
}

export type UpdateScheduleResponse =
  UpdateScheduleResponses[keyof UpdateScheduleResponses]

export type ListSubscribersData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/subscribers"
}

export type ListSubscribersErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListSubscribersError =
  ListSubscribersErrors[keyof ListSubscribersErrors]

export type ListSubscribersResponses = {
  /**
   * Success. A list of subscribers is returned.
   */
  200: {
    data?: Array<Subscriber>
    links?: Links
  }
}

export type ListSubscribersResponse =
  ListSubscribersResponses[keyof ListSubscribersResponses]

export type CreateSubscriberData = {
  body?: {
    data: SubscriberCreate
  }
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/subscriptions/subscribers"
}

export type CreateSubscriberErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateSubscriberError =
  CreateSubscriberErrors[keyof CreateSubscriberErrors]

export type CreateSubscriberResponses = {
  /**
   * Success. The subscriber is created.
   */
  201: {
    data?: Subscriber
  }
}

export type CreateSubscriberResponse =
  CreateSubscriberResponses[keyof CreateSubscriberResponses]

export type DeleteSubscriberData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscriber.
     */
    subscriber_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscribers/{subscriber_uuid}"
}

export type DeleteSubscriberErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type DeleteSubscriberError =
  DeleteSubscriberErrors[keyof DeleteSubscriberErrors]

export type DeleteSubscriberResponses = {
  /**
   * Success. The subscriber is removed.
   */
  204: void
}

export type DeleteSubscriberResponse =
  DeleteSubscriberResponses[keyof DeleteSubscriberResponses]

export type GetSubscriberData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscriber.
     */
    subscriber_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscribers/{subscriber_uuid}"
}

export type GetSubscriberErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetSubscriberError = GetSubscriberErrors[keyof GetSubscriberErrors]

export type GetSubscriberResponses = {
  /**
   * Success. A subscriber is returned.
   */
  200: {
    data?: Subscriber
  }
}

export type GetSubscriberResponse =
  GetSubscriberResponses[keyof GetSubscriberResponses]

export type UpdateSubscriberData = {
  body?: {
    data: SubscriberUpdate
  }
  path: {
    /**
     * The unique identifier of the subscriber.
     */
    subscriber_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/subscribers/{subscriber_uuid}"
}

export type UpdateSubscriberErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateSubscriberError =
  UpdateSubscriberErrors[keyof UpdateSubscriberErrors]

export type UpdateSubscriberResponses = {
  /**
   * Success. The subscriber details are returned.
   */
  200: {
    data?: Subscriber
  }
}

export type UpdateSubscriberResponse =
  UpdateSubscriberResponses[keyof UpdateSubscriberResponses]

export type ListDunningRulesData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/dunning-rules"
}

export type ListDunningRulesErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListDunningRulesError =
  ListDunningRulesErrors[keyof ListDunningRulesErrors]

export type ListDunningRulesResponses = {
  /**
   * Success. A list of dunning rules is returned.
   */
  200: {
    data?: Array<DunningRule>
    links?: Links
  }
}

export type ListDunningRulesResponse =
  ListDunningRulesResponses[keyof ListDunningRulesResponses]

export type CreateDunningRuleData = {
  body?: {
    data: DunningRuleCreate
  }
  path?: never
  query?: never
  url: "/subscriptions/dunning-rules"
}

export type CreateDunningRuleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateDunningRuleError =
  CreateDunningRuleErrors[keyof CreateDunningRuleErrors]

export type CreateDunningRuleResponses = {
  /**
   * Success. The dunning rule set is created.
   */
  201: {
    data?: DunningRule
  }
}

export type CreateDunningRuleResponse =
  CreateDunningRuleResponses[keyof CreateDunningRuleResponses]

export type DeleteDunningRuleData = {
  body?: never
  path: {
    /**
     * The unique identifier of a dunning rule set.
     */
    dunning_rule_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/dunning-rules/{dunning_rule_uuid}"
}

export type DeleteDunningRuleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type DeleteDunningRuleError =
  DeleteDunningRuleErrors[keyof DeleteDunningRuleErrors]

export type DeleteDunningRuleResponses = {
  /**
   * Success. The dunning rule is removed.
   */
  204: void
}

export type DeleteDunningRuleResponse =
  DeleteDunningRuleResponses[keyof DeleteDunningRuleResponses]

export type GetDunningRuleData = {
  body?: never
  path: {
    /**
     * The unique identifier of a dunning rule set.
     */
    dunning_rule_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/dunning-rules/{dunning_rule_uuid}"
}

export type GetDunningRuleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetDunningRuleError =
  GetDunningRuleErrors[keyof GetDunningRuleErrors]

export type GetDunningRuleResponses = {
  /**
   * Success. The dunning rule details are returned.
   */
  200: {
    data?: DunningRule
  }
}

export type GetDunningRuleResponse =
  GetDunningRuleResponses[keyof GetDunningRuleResponses]

export type UpdateDunningRuleData = {
  body?: {
    data: DunningRuleUpdate
  }
  path: {
    /**
     * The unique identifier of a dunning rule set.
     */
    dunning_rule_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/dunning-rules/{dunning_rule_uuid}"
}

export type UpdateDunningRuleErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateDunningRuleError =
  UpdateDunningRuleErrors[keyof UpdateDunningRuleErrors]

export type UpdateDunningRuleResponses = {
  /**
   * Success. The dunning rule set has been updated.
   */
  200: {
    data?: DunningRule
  }
}

export type UpdateDunningRuleResponse =
  UpdateDunningRuleResponses[keyof UpdateDunningRuleResponses]

export type ListProrationPoliciesData = {
  body?: never
  path?: never
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/proration-policies"
}

export type ListProrationPoliciesErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListProrationPoliciesError =
  ListProrationPoliciesErrors[keyof ListProrationPoliciesErrors]

export type ListProrationPoliciesResponses = {
  /**
   * Success. A list of proration policies is returned.
   */
  200: {
    data?: Array<ProrationPolicy>
    links?: Links
  }
}

export type ListProrationPoliciesResponse =
  ListProrationPoliciesResponses[keyof ListProrationPoliciesResponses]

export type CreateProrationPolicyData = {
  body?: {
    data: ProrationPolicyCreate
  }
  path?: never
  query?: never
  url: "/subscriptions/proration-policies"
}

export type CreateProrationPolicyErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateProrationPolicyError =
  CreateProrationPolicyErrors[keyof CreateProrationPolicyErrors]

export type CreateProrationPolicyResponses = {
  /**
   * Success. The proration policy is created.
   */
  201: {
    data?: ProrationPolicy
  }
}

export type CreateProrationPolicyResponse =
  CreateProrationPolicyResponses[keyof CreateProrationPolicyResponses]

export type DeleteProrationPolicyData = {
  body?: never
  path: {
    /**
     * The unique identifier of a proration policy.
     */
    proration_policy_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/proration-policies/{proration_policy_uuid}"
}

export type DeleteProrationPolicyErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type DeleteProrationPolicyError =
  DeleteProrationPolicyErrors[keyof DeleteProrationPolicyErrors]

export type DeleteProrationPolicyResponses = {
  /**
   * Success. The proration policy details are removed.
   */
  204: void
}

export type DeleteProrationPolicyResponse =
  DeleteProrationPolicyResponses[keyof DeleteProrationPolicyResponses]

export type GetProrationPolicyData = {
  body?: never
  path: {
    /**
     * The unique identifier of a proration policy.
     */
    proration_policy_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/proration-policies/{proration_policy_uuid}"
}

export type GetProrationPolicyErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetProrationPolicyError =
  GetProrationPolicyErrors[keyof GetProrationPolicyErrors]

export type GetProrationPolicyResponses = {
  /**
   * Success. The proration policy details are returned.
   */
  200: {
    data?: ProrationPolicy
  }
}

export type GetProrationPolicyResponse =
  GetProrationPolicyResponses[keyof GetProrationPolicyResponses]

export type UpdateProrationPolicyData = {
  body?: {
    data: ProrationPolicyUpdate
  }
  path: {
    /**
     * The unique identifier of a proration policy.
     */
    proration_policy_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/proration-policies/{proration_policy_uuid}"
}

export type UpdateProrationPolicyErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
}

export type UpdateProrationPolicyError =
  UpdateProrationPolicyErrors[keyof UpdateProrationPolicyErrors]

export type UpdateProrationPolicyResponses = {
  /**
   * Success. The proration policy details are updated.
   */
  200: {
    data?: ProrationPolicy
  }
}

export type UpdateProrationPolicyResponse =
  UpdateProrationPolicyResponses[keyof UpdateProrationPolicyResponses]

export type ListFeaturesData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/subscriptions/features"
}

export type ListFeaturesErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type ListFeaturesError = ListFeaturesErrors[keyof ListFeaturesErrors]

export type ListFeaturesResponses = {
  /**
   * Success. A list of features is returned.
   */
  200: {
    data?: Array<Feature>
    links?: Links
  }
}

export type ListFeaturesResponse =
  ListFeaturesResponses[keyof ListFeaturesResponses]

export type CreateFeatureData = {
  body?: {
    data: FeatureCreate
  }
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/subscriptions/features"
}

export type CreateFeatureErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type CreateFeatureError = CreateFeatureErrors[keyof CreateFeatureErrors]

export type CreateFeatureResponses = {
  /**
   * Success. The feature is created.
   */
  201: {
    data?: Feature
  }
}

export type CreateFeatureResponse =
  CreateFeatureResponses[keyof CreateFeatureResponses]

export type DeleteFeatureData = {
  body?: never
  path: {
    /**
     * The unique identifier of a feature.
     */
    feature_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/features/{feature_uuid}"
}

export type DeleteFeatureErrors = {
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type DeleteFeatureError = DeleteFeatureErrors[keyof DeleteFeatureErrors]

export type DeleteFeatureResponses = {
  /**
   * Success. The feature is removed.
   */
  204: void
}

export type DeleteFeatureResponse =
  DeleteFeatureResponses[keyof DeleteFeatureResponses]

export type GetFeatureData = {
  body?: never
  path: {
    /**
     * The unique identifier of a feature.
     */
    feature_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/features/{feature_uuid}"
}

export type GetFeatureErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type GetFeatureError = GetFeatureErrors[keyof GetFeatureErrors]

export type GetFeatureResponses = {
  /**
   * Success. The feature details are returned.
   */
  200: {
    data?: Feature
  }
}

export type GetFeatureResponse = GetFeatureResponses[keyof GetFeatureResponses]

export type UpdateFeatureData = {
  body?: {
    data: FeatureUpdate
  }
  path: {
    /**
     * The unique identifier of a feature.
     */
    feature_uuid: Uuid
  }
  query?: never
  url: "/subscriptions/features/{feature_uuid}"
}

export type UpdateFeatureErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: ErrorResponse
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  403: ErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: ErrorResponse
  /**
   * Write conflict. Unable to perform the operation at this time.
   */
  409: ErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: ErrorResponse
}

export type UpdateFeatureError = UpdateFeatureErrors[keyof UpdateFeatureErrors]

export type UpdateFeatureResponses = {
  /**
   * Success. The feature details are updated.
   */
  200: {
    data?: Feature
  }
}

export type UpdateFeatureResponse =
  UpdateFeatureResponses[keyof UpdateFeatureResponses]
