// This file is auto-generated by @hey-api/openapi-ts

export type Attributes = {
    /**
     * The name of the node, such as `Ranges` or `Refrigerators`. Names must be unique among sibling nodes in the hierarchy. Otherwise, a name can be non-unique within the hierarchy and across multiple hierarchies.
     */
    name?: string;
    /**
     * A description for a node.
     */
    description?: string;
    /**
     * A slug for the node. Slugs must be unique among sibling nodes in the hierarchy. Otherwise, a slug can be non-unique within the hierarchy and across multiple hierarchies.
     */
    slug?: string;
    /**
     * You can curate your products in your nodes product lists. Product curation allows you to promote specific products within each node in a hierarchy, enabling you to create unique product collections in your storefront.
     */
    curated_products?: Array<(string)>;
    /**
     * Product Experience Manager supports localization of hierarchies and nodes. If you store supports multiple languages, you can localize hierarchy and node names and descriptions.
     */
    locales?: {
        [key: string]: {
            /**
             * A localized hierarchy or node name.
             */
            name?: string;
            /**
             * A localized hierarchy or node description.
             */
            description?: string;
        };
    };
};

export type AttributesCustomRelationship = {
    /**
     * The name of the custom relationship, such as `Kitchen electrics`.
     */
    name?: string;
    /**
     * A description of the custom relationship.
     */
    description?: string;
    /**
     * A unique slug for the custom relationship.
     */
    slug?: string;
};

export type AttributesHierarchy = {
    /**
     * The name of a hierarchy, such as `Major Appliances`.
     */
    name?: string;
    /**
     * A description for a hierarchy.
     */
    description?: string;
    /**
     * A unique slug for a hierarchy.
     */
    slug?: string;
    /**
     * Product Experience Manager supports localization of hierarchies and nodes. If you store supports multiple languages, you can localize hierarchy and node names and descriptions.
     */
    locales?: {
        [key: string]: {
            /**
             * A localized hierarchy or node name.
             */
            name?: string;
            /**
             * A localized hierarchy or node description.
             */
            description?: string;
        };
    };
};

export type AttributesNodes = {
    /**
     * The name of the node, such as `Ranges` or `Refrigerators`. Names must be unique among sibling nodes in the hierarchy. Otherwise, a name can be non-unique within the hierarchy and across multiple hierarchies.
     */
    name?: string;
    /**
     * A description of the node.
     */
    description?: string;
    /**
     * A slug for the node. Slugs must be unique among sibling nodes in the hierarchy. Otherwise, a slug can be non-unique within the hierarchy and across multiple hierarchies.
     */
    slug?: string;
    /**
     * You can curate your products in your nodes product lists. Product curation allows you to promote specific products within each node in a hierarchy, enabling you to create unique product collections in your storefront. See [Curating Products in a node](/docs/api/pxm/products/create-node#curating-products-in-a-node).
     */
    curated_products?: Array<(string)>;
    /**
     * Product Experience Manager supports localization of products and hierarchies. If your store supports multiple languages, you can localize product names and descriptions. You can have as many locales as you want.
     */
    locales?: {
        [key: string]: {
            /**
             * A localized name for the node.
             */
            name?: string;
            /**
             * A localized description for the node.
             */
            description?: string;
        };
    };
};

export type ComponentProductsResponse = {
    data?: Array<{
        /**
         * The unique identifier of a product component generated when a product is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product`.
         */
        type?: 'product';
    }>;
};

export type CreateCustomRelationship = {
    data?: {
        /**
         * This represents the type of resource object being returned. Always `custom-relationship`.
         */
        type: 'custom-relationship';
        attributes: ReqAttributesCustomRelationship;
    };
};

/**
 * This represents the type of resource object being returned. Always `custom-relationship`.
 */
export type type = 'custom-relationship';

export type CreatedModifier = {
    data?: {
        /**
         * A unique identifier for a modifier that is generated automatically when a modifier is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation-modifier'.
         */
        type?: 'product-variation-modifier';
        attributes?: {
            /**
             * You can specify different modifiers for different options in a variation. When you build child products using options in variations, the properties of a child products depends on the modifier set for the options that are applied to the child product. The table below describes the different types of modifiers.
             *
             * | Modifier | Data Type | Effect |
             * | :--- | :--- | :--- |
             * | `name_equals` | `string` | Overrides the name of the child product with the name specified by the modifier. |
             * | `name_append` | `string` | Appends the string specified in the modifier to the name of the child product. |
             * | `name_prepend` | `string` | Prepends the string specified in the modifier to the name of the child product. |
             * | `description_equals` | `string` | Overrides the description of the child product. |
             * | `description_append` | `string` | Appends the string specified in the modifier to the description of the child product. |
             * | `description_prepend` | `string` | Prepends the string specified in the modifier to the product description of the child product. |
             * | `commodity_type` | `string` | Sets the commodity type of the child product, such as `physical` or `digital`. |
             * | `price` | `string` | Allows application of price modifiers (`price_increment`, `price_decrement`, and `price_equals`) to the child products. |
             * | `price_increment` | `string` | Increases the price of the child product. |
             * | `price_decrement` | `string` | Decreases the price of the child product. |
             * | `price_equals` | `string` | Sets the price of a child product to the amount you specify. |
             * | `slug_append` | `string` | Appends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_prepend` | `string` | Prepends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_builder` | `string`| Sets a part of the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `sku_equals` | `string` | Sets the SKU of the child product. |
             * | `sku_append` | `string` | Appends the string specified in the modifier to the SKU of the child product. |
             * | `sku_prepend` | `string` | Prepends the string specified in the modifier to the SKU of the child product. |
             * | `sku_builder` | `string` | Sets a part of the SKU of the child product. |
             * | `status` | `string` | Sets the status of the child product, such as `draft` or `live`. |
             *
             */
            type?: 'commodity_type' | 'status' | 'price' | 'name_append' | 'name_prepend' | 'name_equals' | 'sku_append' | 'sku_prepend' | 'sku_equals' | 'sku_builder' | 'slug_append' | 'slug_prepend' | 'slug_equals' | 'slug_builder' | 'description_append' | 'description_prepend' | 'description_equals' | 'custom_inputs_equals' | 'build_rules_equals' | 'locales_equals' | 'upc_ean_equals' | 'mpn_equals' | 'external_ref_equals';
            /**
             * Required for non-builder modifiers. The value of the modifier type.
             */
            value?: string;
            /**
             * Required for builder modifiers. The sub-string to find and replace enclosed in curly brackets for `slug_builder` and `sku_builder`.
             */
            seek?: string;
            /**
             * Required for builder modifiers. The value to replace matches the `seek` string for `slug_builder` and `sku_builder`.
             */
            set?: string;
            /**
             * The name of the modifier.
             */
            reference_name?: string;
        };
        meta?: {
            /**
             * The owner of the resource, either `organization` or `store`.
             */
            owner?: 'organization' | 'store';
        };
    };
};

/**
 * This represents the type of resource object being returned. Always `product-variation-modifier'.
 */
export type type2 = 'product-variation-modifier';

/**
 * The owner of the resource, either `organization` or `store`.
 */
export type owner = 'organization' | 'store';

export type CreatedOption = {
    data: {
        /**
         * A unique identifier that is generated when an option is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation-option`.
         */
        type: 'product-variation-option';
        attributes: {
            /**
             * A human-recognizable identifier for the option, also used in the SLUG for child products. Option names can only contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
             */
            name?: string;
            /**
             * A human-recognizable description for the option.
             */
            description?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             */
            sort_order?: number;
        };
        meta?: {
            /**
             * The owner of a resource, either `organization` or `store`.
             */
            owner?: 'organization' | 'store';
            /**
             * The date and time an option is created.
             */
            created_at?: Date;
            /**
             * The date and time an option is updated.
             */
            updated_at?: Date;
        };
    };
};

/**
 * This represents the type of resource object being returned. Always `product-variation-option`.
 */
export type type3 = 'product-variation-option';

export type CreatedVariation = {
    data: {
        /**
         * A unique identifier generated when a variation is created.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation`.
         */
        type: 'product-variation';
        attributes: {
            /**
             * A human-recognizable identifier for a variation.
             */
            name?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             */
            sort_order?: number;
        };
        meta: {
            /**
             * The owner of the resource, either `organization` or `store`.
             */
            owner?: 'organization' | 'store';
            /**
             * The date and time a variation is created.
             */
            created_at?: Date;
            /**
             * The date and time a variation is updated.
             */
            updated_at?: Date;
        };
    };
};

/**
 * This represents the type of resource object being returned. Always `product-variation`.
 */
export type type4 = 'product-variation';

export type CreateHierarchy = {
    data?: {
        /**
         * This represents the type of resource object being returned. Always `hierarchy`.
         */
        type: 'hierarchy';
        attributes: ReqAttributesHierarchy;
    };
};

/**
 * This represents the type of resource object being returned. Always `hierarchy`.
 */
export type type5 = 'hierarchy';

/**
 * Use modifiers to change the properties of child products that are inherited from a parent product. With modifiers, you only need to have one parent product with a variation attached to the product.
 */
export type CreateModifier = {
    data: {
        /**
         * This represents the type of resource object being returned. Always `product-variation-modifier`.
         */
        type: 'product-variation-modifier';
        attributes: {
            /**
             * You can specify different modifiers for different options in a variation. When you build child products using options in variations, the properties of a child products depends on the modifier set for the options that are applied to the child product. The table below describes the different types of modifiers.
             *
             * | Modifier | Data Type | Effect |
             * | :--- | :--- | :--- |
             * | `name_equals` | `string` | Overrides the name of the child product with the name specified by the modifier. |
             * | `name_append` | `string` | Appends the string specified in the modifier to the name of the child product. |
             * | `name_prepend` | `string` | Prepends the string specified in the modifier to the name of the child product. |
             * | `description_equals` | `string` | Overrides the description of the child product. |
             * | `description_append` | `string` | Appends the string specified in the modifier to the description of the child product. |
             * | `description_prepend` | `string` | Prepends the string specified in the modifier to the product description of the child product. |
             * | `commodity_type` | `string` | Sets the commodity type of the child product, such as `physical` or `digital`. |
             * | `price` | `string` | Allows application of price modifiers (`price_increment`, `price_decrement`, and `price_equals`) to the child products. |
             * | `price_increment` | `string` | Increases the price of the child product. |
             * | `price_decrement` | `string` | Decreases the price of the child product. |
             * | `price_equals` | `string` | Sets the price of a child product to the amount you specify. |
             * | `slug_append` | `string` | Appends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_prepend` | `string` | Prepends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_builder` | `string`| Sets a part of the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `sku_equals` | `string` | Sets the SKU of the child product. |
             * | `sku_append` | `string` | Appends the string specified in the modifier to the SKU of the child product. |
             * | `sku_prepend` | `string` | Prepends the string specified in the modifier to the SKU of the child product. |
             * | `sku_builder` | `string` | Sets a part of the SKU of the child product. |
             * | `status` | `string` | Sets the status of the child product, such as `draft` or `live`. |
             *
             */
            type: 'commodity_type' | 'status' | 'price' | 'name_append' | 'name_prepend' | 'name_equals' | 'sku_append' | 'sku_prepend' | 'sku_equals' | 'sku_builder' | 'slug_append' | 'slug_prepend' | 'slug_equals' | 'slug_builder' | 'description_append' | 'description_prepend' | 'description_equals' | 'custom_inputs_equals' | 'build_rules_equals' | 'locales_equals' | 'upc_ean_equals' | 'mpn_equals' | 'external_ref_equals';
            /**
             * Required for non-builder modifiers. The value of the modifier type.
             */
            value?: string;
            /**
             * Required for builder modifiers. The sub-string to find and replace enclosed in curly brackets for `slug_builder` and `sku_builder`.
             */
            seek?: string;
            /**
             * Required for builder modifiers. The value to replace matches the `seek` string for `slug_builder` and `sku_builder`.
             */
            set?: string;
            /**
             * A name for the modifier.
             */
            reference_name?: string;
        };
    };
};

export type CreateNode = {
    data?: {
        /**
         * This represents the type of resource object being returned. Always `node`.
         */
        type: 'node';
        attributes: AttributesNodes;
        meta?: {
            /**
             * You can sort the order of your nodes, regardless of where the nodes are in the hierarchy. The `sort_order` for each node. This value determines the order of nodes in the response for the `Get a Node’s Children` request. The node with the highest value of sort_order is displayed first. For example, a node with a sort_order value of 3 appears before a node with a sort_order value of 2.
             *
             * - If you don’t provide `sort_order` when creating nodes, all child nodes in the response for `Get a Node’s Children` request are ordered by the `updated_at` time in descending order, with the most recently updated child node first.
             * - If you set `sort_order` for only a few child nodes or not all, the child nodes with a `sort_order` value appear first and then other child nodes appear in the order of `updated_at` time. See [Sorting Nodes in a hierarchy]().
             *
             */
            sort_order?: number;
        };
    };
};

/**
 * This represents the type of resource object being returned. Always `node`.
 */
export type type6 = 'node';

export type CreateOption = {
    data: {
        /**
         * This represents the type of resource object being returned. Always `product-variation-option`.
         */
        type: 'product-variation-option';
        attributes: {
            /**
             * A human recognizable identifier for the option, also used in the SLUG for child products. Option names can only contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
             */
            name?: string;
            /**
             * By default, variations and variation options are sorted alphabetically. You can use the `sort_order` attribute to sort the order of your variation and variation options in the `variation_matrix`.
             *
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want.
             *
             * The variation option with the highest value of `sort_order` is displayed first. For example, a variation option with a `sort_order` value of `3` appears before a variation option with a `sort_order` value of `2`. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, and so on, zero or negative numbers.
             *
             * You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             *
             * You must rebuild your products for the sort order changes to take effect.
             *
             */
            sort_order?: number;
            /**
             * A description of a product variation option.
             */
            description?: string;
        };
    };
};

export type CreateProductRequest = {
    data: {
        /**
         * This represents the type of resource being returned. Always `product`.
         */
        type: 'product';
        attributes: ProductAttributes;
        /**
         * Relationships are established between different product entities.
         */
        relationships?: {
            variations?: {
                data?: Array<{
                    /**
                     * A unique identifier for a resource.
                     */
                    id?: string;
                    /**
                     * This represents the type of resource object being returned.
                     */
                    type?: string;
                }>;
            };
        };
    };
};

/**
 * This represents the type of resource being returned. Always `product`.
 */
export type type7 = 'product';

export type CreateVariation = {
    data: {
        /**
         * This represents the type of resource object being returned. Always `product-variation`.
         */
        type: 'product-variation';
        attributes: {
            /**
             * The variation name.
             */
            name?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want.
             *
             * The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2.
             *
             * You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             *
             * You must rebuild your products for the sort order changes to take effect.
             *
             */
            sort_order?: number;
        };
    };
};

export type CustomRelationship = {
    /**
     * A unique identifier generated when a custom relationship is created.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned. Always `hierarchy`.
     */
    type?: 'custom-relationship';
    attributes?: AttributesCustomRelationship;
    meta?: {
        /**
         * The owner of the resource.
         */
        owner?: string;
        timestamps?: {
            /**
             * The date and time the resource is created.
             */
            created_at?: Date;
            /**
             * The date and time the resource is updated.
             */
            updated_at?: Date;
        };
    };
};

export type DuplicateJob = {
    data?: {
        /**
         * This represents the type of resource object being returned. Always `hierarchy`.
         */
        type?: 'hierarchy';
        attributes?: {
            /**
             * The name of the duplicate hierarchy. The maximum length is 1000 characters.
             */
            name?: string;
            /**
             * A description of the duplicate hierarchy.
             */
            description?: string;
            /**
             * Specify `true` if you want the product associations in the existing nodes associated in your duplicated hierarchy. If not, specify `false`.
             */
            include_products?: boolean;
        };
    };
};

export type Error = {
    errors: Array<{
        /**
         * The HTTP response code of the error.
         */
        status: string;
        /**
         * A brief summary of the error.
         */
        title: string;
        /**
         * Optional additional detail about the error.
         */
        detail?: string;
        /**
         * Internal request ID.
         */
        request_id?: string;
        /**
         * Additional supporting meta data for the error.
         */
        meta?: {
            [key: string]: unknown;
        };
    }>;
};

export type Errors = {
    /**
     * An array of job errors.
     */
    data?: Array<{
        /**
         * This represents the type of resource object being returned. Always `pim-job-error`.
         */
        type?: 'pim-job-error';
        /**
         * A unique identifier for a job error generated when a job error is created.
         */
        id?: string;
        attributes?: {
            /**
             * A description of an error message.
             */
            message?: string;
        };
    }>;
};

export type FileResponse = {
    data?: Array<{
        /**
         * The unique identifier of the new file.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `file`.
         */
        type?: 'file';
    }>;
};

export type Hierarchy = {
    /**
     * A unique identifier generated when a hierarchy is created.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned. Always `hierarchy`.
     */
    type?: 'hierarchy';
    attributes?: AttributesHierarchy;
    relationships?: RelationshipsHierarchy;
    meta?: {
        /**
         * The date and time a hierarchy is created.
         */
        created_at?: Date;
        /**
         * The date and time a hierarchy is updated.
         */
        updated_at?: Date;
        /**
         * The owner of a resource, either `organization` or `store`.
         */
        owner?: 'store' | 'organization';
    };
};

export type Job = {
    /**
     * A unique identifier generated when a job is created.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned. Always `pim-job`.
     */
    type?: 'pim-job';
    attributes?: {
        /**
         * The date and time a job is started.
         */
        started_at?: (Date) | null;
        /**
         * The date and time a job is completed.
         */
        completed_at?: (Date) | null;
        /**
         * The date and time a job is created.
         */
        created_at?: Date;
        /**
         * The date and time a job is updated.
         */
        updated_at?: Date;
        /**
         * The status of a job.
         *
         * * `pending` - Commerce has received the request but is currently busy processing other requests.
         * * `started` - Commerce has started processing the job.
         * * `success` - The job has successfully completed.
         * * `failed` - The job has failed.
         *
         */
        type?: 'child-products' | 'product-import' | 'product-export' | 'hierarchy-duplicate' | 'price-import';
        status?: 'pending' | 'cancelled' | 'started' | 'success' | 'failed';
    };
    meta?: {
        /**
         * Applies to all job types. A unique request ID is generated when a job is created.
         */
        x_request_id?: string;
        /**
         * Applies to `hierarchy-duplicate` job types. The ID of the original hierarchy that you duplicated.
         */
        copied_from?: string;
        /**
         * Applies to `hierarchy-duplicate` job types. The duplicated hierarchy ID.
         */
        hierarchy_id?: string;
        /**
         * If the job type is `product_export`, a link to the file is created when running a job.
         */
        file_locations?: Array<(string)> | null;
        /**
         * The entities included in the job. For example, if the job type is `product-export`, the PXM products included in the export.
         */
        filter?: string;
    };
};

/**
 * This represents the type of resource object being returned. Always `pim-job`.
 */
export type type8 = 'pim-job';

export type status = 'pending' | 'cancelled' | 'started' | 'success' | 'failed';

export type MainImageRequest = {
    data?: {
        /**
         * The ID of the image file.
         */
        id?: string;
        /**
         * This represents the type of resource being returned. Always `file`.
         */
        type?: 'file';
    };
};

/**
 * This represents the type of resource being returned. Always `file`.
 */
export type type9 = 'file';

export type MainImageResponse = {
    data?: Array<{
        /**
         * A unique identifier for the image file generated automatically when a file is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `file`.
         */
        type?: string;
    }>;
};

export type Multi = {
    /**
     * An array of jobs.
     */
    data?: Array<Job>;
    meta?: {
        /**
         * Contains the results for the entire collection.
         */
        results?: {
            /**
             * Total number of results for the entire collection.
             */
            total?: number;
        };
    };
};

export type MultiHierarchy = {
    data?: Array<Hierarchy>;
    links?: MultiLinks;
    meta?: MultiMeta;
};

/**
 * Links are used to allow you to move between requests.
 */
export type MultiLinks = {
    /**
     * Always the first page.
     */
    first?: string;
    /**
     * This is `null` if there is only one page.
     */
    last?: string;
    /**
     * This is `null` if there is only one page.
     */
    next?: string;
    /**
     * This is `null` if you on the first page.
     */
    prev?: string;
};

export type MultiMeta = {
    /**
     * Contains the results for the entire collection.
     */
    results?: {
        /**
         * Total number of results for the entire collection.
         */
        total?: number;
    };
};

export type MultiModifiers = {
    data?: Array<{
        /**
         * A unique identifier for a modifier that is generated automatically when a modifier is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation-modifier'.
         */
        type?: 'product-variation-modifier';
        attributes?: {
            /**
             * You can specify different modifiers for different options in a variation. When you build child products using options in variations, the properties of a child products depends on the modifier set for the options that are applied to the child product. The table below describes the different types of modifiers.
             *
             * | Modifier | Data Type | Effect |
             * | :--- | :--- | :--- |
             * | `name_equals` | `string` | Overrides the name of the child product with the name specified by the modifier. |
             * | `name_append` | `string` | Appends the string specified in the modifier to the name of the child product. |
             * | `name_prepend` | `string` | Prepends the string specified in the modifier to the name of the child product. |
             * | `description_equals` | `string` | Overrides the description of the child product. |
             * | `description_append` | `string` | Appends the string specified in the modifier to the description of the child product. |
             * | `description_prepend` | `string` | Prepends the string specified in the modifier to the product description of the child product. |
             * | `commodity_type` | `string` | Sets the commodity type of the child product, such as `physical` or `digital`. |
             * | `price` | `string` | Allows application of price modifiers (`price_increment`, `price_decrement`, and `price_equals`) to the child products. |
             * | `price_increment` | `string` | Increases the price of the child product. |
             * | `price_decrement` | `string` | Decreases the price of the child product. |
             * | `price_equals` | `string` | Sets the price of a child product to the amount you specify. |
             * | `slug_append` | `string` | Appends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_prepend` | `string` | Prepends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_builder` | `string`| Sets a part of the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `sku_equals` | `string` | Sets the SKU of the child product. |
             * | `sku_append` | `string` | Appends the string specified in the modifier to the SKU of the child product. |
             * | `sku_prepend` | `string` | Prepends the string specified in the modifier to the SKU of the child product. |
             * | `sku_builder` | `string` | Sets a part of the SKU of the child product. |
             * | `status` | `string` | Sets the status of the child product, such as `draft` or `live`. |
             *
             */
            type?: 'commodity_type' | 'status' | 'price' | 'name_append' | 'name_prepend' | 'name_equals' | 'sku_append' | 'sku_prepend' | 'sku_equals' | 'sku_builder' | 'slug_append' | 'slug_prepend' | 'slug_equals' | 'slug_builder' | 'description_append' | 'description_prepend' | 'description_equals' | 'custom_inputs_equals' | 'build_rules_equals' | 'locales_equals' | 'upc_ean_equals' | 'mpn_equals' | 'external_ref_equals';
            /**
             * Required for non-builder modifiers. The value of the modifier type.
             */
            value?: string;
            /**
             * Required for builder modifiers. The sub-string to find and replace enclosed in curly brackets for `slug_builder` and `sku_builder`.
             */
            seek?: string;
            /**
             * Required for builder modifiers. The value to replace matches the `seek` string for `slug_builder` and `sku_builder`.
             */
            set?: string;
            /**
             * The name of the modifier.
             */
            reference_name?: string;
        };
        meta?: {
            /**
             * The owner of a resource, either `organization` or `store`.
             */
            owner?: 'store' | 'organization';
        };
    }>;
    meta?: {
        /**
         * Contains the results for the entire collection.
         */
        results?: {
            /**
             * Total number of results for the entire collection.
             */
            total?: number;
        };
    };
};

export type MultiNodes = {
    /**
     * An array of nodes.
     */
    data?: Array<Node>;
    meta?: MultiMeta;
    links?: MultiLinks;
};

export type MultiOptions = {
    data?: Array<{
        /**
         * A unique identifier generated when an option is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation-option`.
         */
        type?: 'product-variation-option';
        attributes?: {
            /**
             * A human-recognizable identifier for the option, also used in the SLUG for child products. Option names can only contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
             */
            name?: string;
            /**
             * A human-recognizable description for the option.
             */
            description?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             */
            sort_order?: number;
        };
        meta?: {
            /**
             * The owner of a resource, either `organization` or `store`.
             */
            owner?: 'organization' | 'store';
            /**
             * The date and time an option is created.
             */
            created_at?: Date;
            /**
             * The date and time an option is updated.
             */
            updated_at?: Date;
        };
    }>;
    meta?: {
        /**
         * Contains the results for the entire collection.
         */
        results?: {
            /**
             * Total number of results for the entire collection.
             */
            total?: number;
        };
    };
};

export type MultiProductResponse = {
    data?: Array<ProductResponse>;
    /**
     * Returns a list of component products in a product bundle. If a bundle has no component products (in other words, is not a product bundle), an empty array is returned.
     */
    included?: {
        /**
         * Returns a list of component products in a product bundle. If a bundle has no component products (in other words, is not a product bundle), an empty array is returned.
         */
        component_products?: Array<ProductResponse>;
    };
    meta?: {
        /**
         * Contains the results for the entire collection.
         */
        results?: {
            /**
             * Total number of results for the entire collection.
             */
            total?: number;
        };
    };
};

export type MultiTag = {
    /**
     * An array of tags.
     */
    data?: Array<Tag>;
    meta?: {
        /**
         * Contains the results for the entire collection.
         */
        results?: {
            /**
             * Total number of results for the entire collection.
             */
            total?: number;
        };
    };
};

export type MultiVariations = {
    data?: Array<{
        /**
         * A unique identifier for a variation.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation`.
         */
        type?: 'product-variation';
        attributes?: {
            /**
             * The name of a variation.
             */
            name?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             */
            sort_order?: number;
        };
        meta?: {
            options?: Array<{
                /**
                 * A unique ID that is generated when an option is created.
                 */
                id?: string;
                /**
                 * A human recognizable identifier for the option, also used in the SLUG for child products. Option names can only contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
                 */
                name?: string;
                /**
                 * A human recognizable description of the option.
                 */
                description?: string;
                /**
                 * The date and time an option is created.
                 */
                created_at?: Date;
                /**
                 * The date and time an option is updated.
                 */
                updated_at?: Date;
                /**
                 * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
                 */
                sort_order?: number;
            }>;
            /**
             * The owner of the resource, either `organization` or `store`.
             */
            owner?: 'organization' | 'store';
            /**
             * The date and time a variation is created.
             */
            created_at?: Date;
            /**
             * The date and time a variation is updated.
             */
            updated_at?: Date;
        };
    }>;
    meta?: {
        /**
         * Contains the results for the entire collection.
         */
        results?: {
            /**
             * Total number of results for the entire collection.
             */
            total?: number;
        };
    };
};

export type Node = {
    /**
     * The unique identifier of a node.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned. Always `node`.
     */
    type?: 'node';
    attributes?: Attributes;
    relationships?: Relationships;
    meta?: {
        /**
         * The sort order value. The node with the highest value of `sort_order` is displayed first. For example, a node with a `sort_order` value of `3` appears before a node with a `sort_order` value of `2`. See [Sorting Nodes in a hierarchy](/docs/api/pxm/products/create-node#sorting-nodes-in-a-hierarchy).
         */
        sort_order?: number;
        /**
         * The date and time a node is created.
         */
        created_at?: Date;
        /**
         * The date and time a node was updated.
         */
        updated_at?: Date;
        /**
         * The name of the parent of the node if one exists.
         */
        parent_name?: string;
        /**
         * The node owner, either `organization` or `store`.
         */
        owner?: 'store' | 'organization';
    };
};

export type NodeChildren = {
    data?: Array<{
        /**
         * The unique identifier of the child node. Must not match the node ID specified in the request path.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `node`.
         */
        type: 'node';
    }>;
};

export type NodeParent = {
    data?: {
        /**
         * The unique identifier of the new parent node. Must not match the node ID specified in the request path.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `node`.
         */
        type: 'node';
    };
};

export type NodeProducts = {
    data?: Array<{
        /**
         * The unique identifier of the product to be attached to the node.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `product`.
         */
        type: 'product';
    }>;
};

/**
 * A custom relationship slug.
 */
export type ParameterCustomRelationshipSlug = string;

/**
 *
 * Many Commerce API endpoints support filtering. The general syntax is described [**here**](/docs/commerce-cloud/api-overview/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
 *
 * For more information about the attributes and operators that this endpoint supports, see [Export Products](/docs/api/pxm/products/export-products).
 *
 */
export type ParameterFilterexport = string;

/**
 * Many Commerce API endpoints support filtering. The general syntax is described [**here**](/docs/commerce-cloud/api-overview/filtering).
 *
 * For more information about the attributes and operators that are supported, see [Get all products](/docs/api/pxm/products/get-all-products).
 *
 */
export type ParameterFilterproduct = string;

/**
 * A unique identifier for the hierarchy.
 */
export type ParameterHierarchyId = string;

/**
 * Using the include parameter, you can retrieve top-level resources.
 *
 * - Files or main image. For example, `include=files,main_image`.
 * - Component product data. For example, `include=component_products`.
 * - Key attribute data, such as SKU or slug.
 *
 */
export type ParameterInclude = string;

/**
 * A unique identifier for the job.
 */
export type ParameterJobId = string;

/**
 * A unique identifier for the modifier.
 */
export type ParameterModifierId = string;

/**
 * A unique identifier for the node.
 */
export type ParameterNodeId = string;

/**
 * A unique identifier for the option.
 */
export type ParameterOptionId = string;

/**
 * The number of records per page. The maximum limit is 100.
 */
export type ParameterPageLimit = number;

/**
 * The number of records to offset the results by.
 */
export type ParameterPageOffset = number;

/**
 * A unique identifier for the product.
 */
export type ParameterProductId = string;

/**
 * A unique identifier for the tag.
 */
export type ParameterTagId = string;

/**
 * Set to `true` if you want to use a template slug instead of a template ID when exporting products that have custom data.
 */
export type ParameterUseTemplateSlugs = boolean;

/**
 * A unique identifier for the variation.
 */
export type ParameterVariationId = string;

export type ProductAttributes = {
    /**
     * The unique attribute associated with the product. This could be an external reference from a separate company system, for example. The maximum length is 2048 characters.
     */
    external_ref?: string;
    /**
     * The product name to display to customers.
     */
    name?: string;
    /**
     * A description for the product.
     */
    description?: string;
    /**
     * The unique slug of the product. A slug can contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
     */
    slug?: string;
    /**
     * The unique stock keeping unit of the product.
     */
    sku?: string;
    /**
     * The status for the product, either `draft` or `live`. Default is `draft`.
     */
    status?: 'live' | 'draft';
    /**
     * The commodity type, either `physical` or `digital`.
     */
    commodity_type?: 'physical' | 'digital';
    /**
     * The universal product code or european article number of the product.
     */
    upc_ean?: string;
    /**
     * The manufacturer part number of the product.
     */
    mpn?: string;
    /**
     * You can use product tags to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. A product can have up to 20 tags. A product tag can be up to 255 characters. Product tags must not contain any spaces or commas. See [Product Tags](/docs/api/pxm/products/product-tags).
     */
    tags?: Array<(string)>;
    build_rules?: ProductBuildRules;
    locales?: ProductLocales;
    custom_inputs?: ProductCustomInputs;
    components?: ProductBundleComponents;
};

/**
 * The status for the product, either `draft` or `live`. Default is `draft`.
 */
export type status2 = 'live' | 'draft';

/**
 * The commodity type, either `physical` or `digital`.
 */
export type commodity_type = 'physical' | 'digital';

/**
 * You can build a combination of child products associated with a product, based on build rules that you specify. This is useful, for example, if you have a variation option that you do not sell. This makes managing and building your child products quick and easy. See [Using Build Rules](/docs/api/pxm/products/build-child-products#using-build-rules).
 */
export type ProductBuildRules = {
    /**
     * Specifies the default behaviour, either `include` or `exclude`.
     */
    default?: 'include' | 'exclude';
    /**
     * An array of option IDs to include when child products are built. Each combination consists of a nested array of option IDs from one or more variations. Combinations of option IDs in the nested arrays must come from different variations.
     */
    include?: Array<Array<(string)>>;
    /**
     * An array of option IDs to exclude when child products are built. Each combination consists of a nested array of option IDs from one or more variations. Combinations of option IDs in the nested arrays must come from different variations.
     */
    exclude?: Array<Array<(string)>>;
};

/**
 * Specifies the default behaviour, either `include` or `exclude`.
 */
export type default = 'include' | 'exclude';

/**
 * With Product Experience Manager, you can create and manage bundles. A bundle is a purchasable product, comprising of one or more products that you want to sell together. You can create multiple components within a bundle. Each component must have at least one or more options. Each option is a product and a quantity. See [Bundles](/docs/api/pxm/products/products#bundles).
 */
export type ProductBundleComponents = {
    [key: string]: {
        /**
         * The component name. The component name is the name that is displayed in your storefront.
         */
        name?: string;
        /**
         * The product options included in a component. This can be the ID of another bundle.
         */
        options?: Array<{
            /**
             * The unique ID of the product you want to add to a component.
             */
            id?: string;
            /**
             * This represents the type of object being returned. Always `product`.
             */
            type?: string;
            /**
             * The number of this product option that a shopper must purchase.
             */
            quantity?: number;
            /**
             * The sort order of the options. The `create a bundle` and `update a bundle` endpoints do not sort the options. You can use the `sort_order` attribute when programming your storefront to display the options in the order that you want.
             */
            sort_order?: number;
            /**
             * Whether the product option is a default option in a bundle. Shoppers can select a bundle that specifies a default list of product options. See [Dynamic Bundles](/docs/api/pxm/products/products#dynamic-bundles).
             */
            default?: boolean;
        }>;
        /**
         * The minimum number of product options a shopper can select from this component.
         */
        min?: number;
        /**
         * The maximum number of product options a shopper can select from this component.
         */
        max?: number;
        /**
         * The sort order of the components. The `create a bundle` and `update a bundle` endpoints do not sort the components. You can use the `sort_order` attribute when programming your storefront to display the components in the order that you want.
         */
        sort_order?: number;
    };
};

/**
 * You use the `custom_inputs` attribute to allow your shoppers to add custom text to a product when adding product items to their carts. This is useful, for example, if you have a product like a T-shirt that can be personalized or you sell greetings cards that can be printed with your shoppers personalized messages. See [Personalizing Products](/docs/api/pxm/products/create-product#personalizing-products).
 */
export type ProductCustomInputs = {
    [key: string]: {
        /**
         * A name for the custom text field.
         */
        name?: string;
        /**
         * The validation rules for the custom text.
         */
        validation_rules?: unknown[];
        /**
         * This represents the type of the resource being returned.
         */
        type?: string;
        /**
         * The length of the custom input text field.
         */
        options?: {
            [key: string]: unknown;
        };
        /**
         * The number of characters the custom text field can be. You can specify a maximum length up to 255 characters, as the limit is 255 characters.
         */
        max_length?: number;
        /**
         * `true` or `false` depending on whether the custom text is required.
         */
        required?: boolean;
    };
};

export type ProductFilesRequest = {
    data?: Array<{
        /**
         * A unique identifier for a file generated when a file is created.
         */
        id?: string;
        /**
         * This represents the type of resource being returned. Always `file`.
         */
        type?: 'file';
        meta?: {
            /**
             * The files associated with a product.
             */
            tags?: Array<(string)>;
        };
    }>;
};

/**
 * Product Experience Manager supports localization of products and hierarchies. If your store supports multiple languages, you can localize product names and descriptions. You can have as many locales as you want.
 */
export type ProductLocales = {
    [key: string]: {
        /**
         * A localized name for the product.
         */
        name: string;
        /**
         * A localized description for the product.
         */
        description?: string;
    };
};

export type ProductResponse = {
    /**
     * A unique product ID that is generated when you create the product.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned. Always `product`.
     */
    type?: 'product';
    attributes?: {
        /**
         * A name for the product.
         */
        name?: string;
        /**
         * A description for the product.
         */
        description?: string;
        /**
         * A label for the product that is used in the URL paths. A slug can contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. By default, the product name is used as the slug.
         */
        slug?: string;
        /**
         * The unique stock keeping unit of the product.
         */
        sku?: string;
        /**
         * The status for the product, either `draft` or `live`.
         */
        status?: 'live' | 'draft';
        /**
         * The commodity type, either `physical` or `digital`.
         */
        commodity_type?: 'physical' | 'digital';
        /**
         * The universal product code or european article number of the product.
         */
        upc_ean?: string;
        /**
         * The manufacturer part number of the product.
         */
        mpn?: string;
        /**
         * The unique attribute associated with the product. This could be an external reference from a separate company system, for example. The maximum length is 2048 characters.
         */
        external_ref?: string;
        /**
         * Product Experience Manager supports localization of products and hierarchies. If your store supports multiple languages, you can localize product names and descriptions. You can have as many locales as you want.
         */
        locales?: {
            [key: string]: unknown;
        };
        /**
         * You can use product tags to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. A product can have up to 20 tags. A product tag can be up to 255 characters. Product tags must not contain any spaces or commas.
         */
        tags?: Array<(string)>;
        extensions?: {
            [key: string]: {
                [key: string]: ((string) | null | number | boolean);
            };
        };
        custom_inputs?: ProductCustomInputs;
        build_rules?: ProductBuildRules;
        components?: ProductBundleComponents;
    };
    meta?: {
        /**
         * The date and time a product is created.
         */
        created_at?: Date;
        /**
         * The date and time a product is updated.
         */
        updated_at?: Date;
        /**
         * The resource owner, either `organization` or `store`.
         */
        owner?: 'organization' | 'store';
        /**
         * A product's variations and the options defined for each variation. If you have specified `build_rules`, only the child products included in the `build_rules` are specified.
         */
        variations?: Array<{
            /**
             * A unique ID generated when a variation is created.
             */
            id?: string;
            /**
             * The name of a variation.
             */
            name?: string;
            options?: Array<{
                /**
                 * A unique ID that is generated an option is created.
                 */
                id?: string;
                /**
                 * The name of an option.
                 */
                name?: string;
                /**
                 * A description of an option.
                 */
                description?: string;
            }>;
        }>;
        /**
         * One of the following product types:
         *
         * - `standard` - A `standard` product is a standalone product.
         * - `parent` - A `parent` product is a product that has child products that have been built using the `Build Child Products` endpoint.
         * - `child` - When you configure product variations and variation options for `parent` products, the `child` products derived from the `parent` products are automatically created in Commerce.
         * - `bundle` - A `bundle` is a purchasable product, comprising one or more standalone products (in other words, components) to be sold together.
         *
         */
        product_types?: Array<('parent' | 'child' | 'bundle' | 'standard')>;
        /**
         * The child products defined for a product. The order of the variations in the `variation_matrix` is the order of the variations in the array when the variations were linked to the product. For example, the first variation in the `variation_matrix` corresponds to the first variation in the array, and so on. You can use the `sort_order`attribute to sort the order of your variation and variation options in the `variation_matrix` object. See [Sorting the Order of Variations and Options](/docs/api/pxm/products/variations#sorting-the-order-of-variations-and-options) If no variations are defined for a product, the `variation_matrix` is empty.
         */
        variation_matrix?: {
            [key: string]: unknown;
        };
    };
    /**
     * Relationships are established between different product entities. For example, a `bundle` product and a `child` product are related to a `parent` product, as both are associated with it.
     */
    relationships?: {
        [key: string]: {
            data?: (Array<{
    /**
     * A unique identifier for a resource.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned.
     */
    type?: string;
}> | {
    /**
     * A unique identifier for a resource.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned.
     */
    type?: string;
} | null);
            /**
             * Links are used to allow you to move between requests. Single entities use a `self` parameter with a link to that specific resource. Sometimes, there are not enough entities for a project to fill multiple pages. In this situation, we return some defaults.
             *
             * | Property | Description |
             * | :--- | :--- |
             * | `current` | Always the current page. |
             * | `first` | Always the first page. |
             * | `last` | `null` if there is only one page. |
             * | `prev` | `null` if the user is on the first page. |
             * | `next` | `null` if there is only one page. |
             *
             */
            links?: {
                [key: string]: (string);
            };
        };
    };
};

export type ProductTemplatesRequest = {
    data?: Array<{
        /**
         * The unique identifier of a template.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `template'.
         */
        type?: 'template';
    }>;
};

export type ProductVariationsRequest = {
    data?: Array<{
        /**
         * The ID of the product variation.
         */
        id?: string;
        /**
         * This represents the type of resource being returned. Always `product-variation`.
         */
        type?: 'product-variation';
    }>;
};

/**
 * Relationships allow you to move between requests. Includes links to the child nodes and products associated with a hierarchy or node.
 */
export type Relationships = {
    /**
     * The child nodes related to the resource.
     */
    children?: {
        /**
         * An array of child nodes.
         */
        data?: unknown[];
        /**
         * Links allow you to move between requests.
         */
        links?: {
            /**
             * A link to a related resource.
             */
            related?: string;
        };
    };
    /**
     * The parent node related to the resource
     */
    parent?: {
        /**
         * The parent node
         */
        data?: {
            /**
             * This represents the type of resource object being returned. Always `node`.
             */
            type: 'node';
            /**
             * The unique identifier of a node.
             */
            id: string;
        };
    };
    /**
     * The products related to the resource.
     */
    products?: {
        /**
         * An array of products.
         */
        data?: unknown[];
        /**
         * Links allow you to move between requests.
         */
        links?: {
            /**
             * A link to a related resource.
             */
            related?: string;
        };
    };
};

export type RelationshipsHierarchy = {
    /**
     * The child nodes related to the hierarchy.
     */
    children?: {
        /**
         * An array of child nodes.
         */
        data?: unknown[];
        /**
         * Links allow you to move between requests.
         */
        links?: {
            /**
             * A link to a related resource.
             */
            related?: string;
        };
    };
};

export type ReplaceMainImageRequest = {
    data?: Array<{
        /**
         * The ID of the new image file.
         */
        id?: string;
        type?: 'file';
    }>;
};

export type ReqAttributesCustomRelationship = {
    /**
     * The name of the custom relationship, such as `Kitchen electrics`.
     */
    name?: string;
    /**
     * A description of the custom relationship.
     */
    description?: string;
    /**
     * A unique slug for the custom relationship. Must match the slug specified in the request path.
     */
    slug?: string;
};

export type ReqAttributesHierarchy = {
    /**
     * The name of the hierarchy, such as `Major Appliances`.
     */
    name?: string;
    /**
     * A description of the hierarchy.
     */
    description?: string;
    /**
     * A unique slug for the hierarchy.
     */
    slug?: string;
    /**
     * Product Experience Manager supports localization of products and hierarchies. If your store supports multiple languages, you can localize product names and descriptions. You can have as many locales as you want.
     */
    locales?: {
        [key: string]: {
            /**
             * A localized name for the hierarchy.
             */
            name?: string;
            /**
             * A localized description for the hierarchy.
             */
            description?: string;
        };
    };
};

export type Single = {
    data?: Job;
};

export type SingleCustomRelationship = {
    data?: CustomRelationship;
};

export type SingleHierarchy = {
    data?: Hierarchy;
};

export type SingleModifier = {
    data?: {
        /**
         * A unique identifier for a modifier that is generated automatically when a modifier is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation-modifier'.
         */
        type?: 'product-variation-modifier';
        attributes?: {
            /**
             * You can specify different modifiers for different options in a variation. When you build child products using options in variations, the properties of a child products depends on the modifier set for the options that are applied to the child product. The table below describes the different types of modifiers.
             *
             * | Modifier | Data Type | Effect |
             * | :--- | :--- | :--- |
             * | `name_equals` | `string` | Overrides the name of the child product with the name specified by the modifier. |
             * | `name_append` | `string` | Appends the string specified in the modifier to the name of the child product. |
             * | `name_prepend` | `string` | Prepends the string specified in the modifier to the name of the child product. |
             * | `description_equals` | `string` | Overrides the description of the child product. |
             * | `description_append` | `string` | Appends the string specified in the modifier to the description of the child product. |
             * | `description_prepend` | `string` | Prepends the string specified in the modifier to the product description of the child product. |
             * | `commodity_type` | `string` | Sets the commodity type of the child product, such as `physical` or `digital`. |
             * | `price` | `string` | Allows application of price modifiers (`price_increment`, `price_decrement`, and `price_equals`) to the child products. |
             * | `price_increment` | `string` | Increases the price of the child product. |
             * | `price_decrement` | `string` | Decreases the price of the child product. |
             * | `price_equals` | `string` | Sets the price of a child product to the amount you specify. |
             * | `slug_append` | `string` | Appends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_prepend` | `string` | Prepends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_builder` | `string`| Sets a part of the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `sku_equals` | `string` | Sets the SKU of the child product. |
             * | `sku_append` | `string` | Appends the string specified in the modifier to the SKU of the child product. |
             * | `sku_prepend` | `string` | Prepends the string specified in the modifier to the SKU of the child product. |
             * | `sku_builder` | `string` | Sets a part of the SKU of the child product. |
             * | `status` | `string` | Sets the status of the child product, such as `draft` or `live`. |
             *
             */
            type?: 'commodity_type' | 'status' | 'price' | 'name_append' | 'name_prepend' | 'name_equals' | 'sku_append' | 'sku_prepend' | 'sku_equals' | 'sku_builder' | 'slug_append' | 'slug_prepend' | 'slug_equals' | 'slug_builder' | 'description_append' | 'description_prepend' | 'description_equals' | 'custom_inputs_equals' | 'build_rules_equals' | 'locales_equals' | 'upc_ean_equals' | 'mpn_equals' | 'external_ref_equals';
            /**
             * Required for non-builder modifiers. The value of the modifier type.
             */
            value?: string;
            /**
             * Required for builder modifiers. The sub-string to find and replace enclosed in curly brackets for `slug_builder` and `sku_builder`.
             */
            seek?: string;
            /**
             * Required for builder modifiers. The value to replace matches the `seek` string for `slug_builder` and `sku_builder`.
             */
            set?: string;
            /**
             * The name of the modifier.
             */
            reference_name?: string;
        };
        /**
         * The owner of the resource, either `organization` or `store`.
         */
        meta?: {
            owner?: 'organization' | 'store';
        };
    };
};

export type SingleNode = {
    data?: Node;
};

export type SingleOption = {
    data: {
        /**
         * The unique identifier generated when an option is created.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation-option`.
         */
        type: 'product-variation-option';
        /**
         * A variation option represents an option for selection for a single product-variation. For example, if your variation is `color`, you might have three possible options; red, green, and blue.
         */
        attributes: {
            /**
             * A human-recognizable identifier for the option, also used in the SLUG for child products. Option names can only contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
             */
            name?: string;
            /**
             * A human-recognizable description for the option.
             */
            description?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             */
            sort_order?: number;
        };
        meta: {
            /**
             * The owner of a resource, either `organization` or `store`.
             */
            owner?: 'organization' | 'store';
            /**
             * The date and time an option is created.
             */
            created_at?: Date;
            /**
             * The date and time an option is updated.
             */
            updated_at?: Date;
        };
    };
};

export type SingleProductResponse = {
    data?: ProductResponse;
    /**
     * Returns a list of component products in a product bundle. If a bundle has no component products (in other words, is not a product bundle), an empty array is returned.
     */
    included?: {
        /**
         * A list of component products in a product bundle. If a bundle has no component products (in other words, is not a product bundle), an empty array is returned.
         */
        component_products?: Array<ProductResponse>;
    };
};

export type SingleTag = {
    data?: Tag;
};

export type SingleVariation = {
    data: {
        /**
         * A unique identifier for a variation.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation`.
         */
        type: 'product-variation';
        attributes: {
            /**
             * The name for a variation.
             */
            name?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             */
            sort_order?: number;
        };
        meta: {
            /**
             * A variation option represents an option for selection for a single product-variation. For example, if your variation is `color`, you might have three possible options; red, green, and blue.
             */
            options?: Array<{
                /**
                 * A unique ID that is generated an option is created.
                 */
                id?: string;
                /**
                 * A human-recognizable identifier for the option, also used in the SLUG for child products. Option names can only contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
                 */
                name?: string;
                /**
                 * A description for an option.
                 */
                description?: string;
                /**
                 * The date and time an option is created.
                 */
                created_at?: Date;
                /**
                 * The date and time an option is updated.
                 */
                updated_at?: Date;
                /**
                 * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
                 */
                sort_order?: number;
            }>;
            /**
             * The owner of the resource, either `organization` or `store`.
             */
            owner?: 'organization' | 'store';
            /**
             * The date and time a variation is created.
             */
            created_at?: string;
            /**
             * The date and time a variation is updated.
             */
            updated_at?: string;
        };
    };
};

export type Tag = {
    /**
     * A unique identifier generated when a tag is created.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned. Always `tag`.
     */
    type?: 'tag';
    attributes?: {
        /**
         * The text value of the tag.
         */
        value?: string;
    };
    meta?: {
        /**
         * A unique request ID is generated when a tag is created.
         */
        x_request_id?: string;
        /**
         * The date and time a tag is created.
         */
        created_at?: Date;
        /**
         * The date and time a tag is updated.
         */
        updated_at?: Date;
        /**
         * The owner of a resource, either `organization` or `store`.
         */
        owner?: 'store' | 'organization';
    };
};

/**
 * This represents the type of resource object being returned. Always `tag`.
 */
export type type10 = 'tag';

export type TemplateResponse = {
    data?: Array<{
        /**
         * A unique identifier for a template generated when a template is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `template`.
         */
        type?: 'template';
    }>;
};

export type UpdateCustomRelationship = {
    data: {
        /**
         * The unique identifier of the custom relationship.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `custom-relationship`.
         */
        type: 'custom-relationship';
        attributes: ReqAttributesCustomRelationship;
    };
};

export type UpdateHierarchy = {
    data: {
        /**
         * The unique identifier of the hierarchy. Must match the hierarchy ID specified in the request path.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `hierarchy`.
         */
        type: 'hierarchy';
        attributes: ReqAttributesHierarchy;
    };
};

export type UpdateModifier = {
    data: {
        /**
         * This represents the type of resource object being returned. Always `product-variation-modifier`.
         */
        type: 'product-variation-modifier';
        attributes: {
            /**
             * You can specify different modifiers for different options in a variation. When you build child products using options in variations, the properties of a child products depends on the modifier set for the options that are applied to the child product. The table below describes the different types of modifiers.
             *
             * | Modifier | Data Type | Effect |
             * | :--- | :--- | :--- |
             * | `name_equals` | `string` | Overrides the name of the child product with the name specified by the modifier. |
             * | `name_append` | `string` | Appends the string specified in the modifier to the name of the child product. |
             * | `name_prepend` | `string` | Prepends the string specified in the modifier to the name of the child product. |
             * | `description_equals` | `string` | Overrides the description of the child product. |
             * | `description_append` | `string` | Appends the string specified in the modifier to the description of the child product. |
             * | `description_prepend` | `string` | Prepends the string specified in the modifier to the product description of the child product. |
             * | `commodity_type` | `string` | Sets the commodity type of the child product, such as `physical` or `digital`. |
             * | `price` | `string` | Allows application of price modifiers (`price_increment`, `price_decrement`, and `price_equals`) to the child products. |
             * | `price_increment` | `string` | Increases the price of the child product. |
             * | `price_decrement` | `string` | Decreases the price of the child product. |
             * | `price_equals` | `string` | Sets the price of a child product to the amount you specify. |
             * | `slug_append` | `string` | Appends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_prepend` | `string` | Prepends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_builder` | `string`| Sets a part of the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `sku_equals` | `string` | Sets the SKU of the child product. |
             * | `sku_append` | `string` | Appends the string specified in the modifier to the SKU of the child product. |
             * | `sku_prepend` | `string` | Prepends the string specified in the modifier to the SKU of the child product. |
             * | `sku_builder` | `string` | Sets a part of the SKU of the child product. |
             * | `status` | `string` | Sets the status of the child product, such as `draft` or `live`. |
             *
             */
            type: 'commodity_type' | 'status' | 'price' | 'name_append' | 'name_prepend' | 'name_equals' | 'sku_append' | 'sku_prepend' | 'sku_equals' | 'sku_builder' | 'slug_append' | 'slug_prepend' | 'slug_equals' | 'slug_builder' | 'description_append' | 'description_prepend' | 'description_equals' | 'custom_inputs_equals' | 'build_rules_equals' | 'locales_equals' | 'upc_ean_equals' | 'mpn_equals' | 'external_ref_equals';
            /**
             * Required for non-builder modifiers. The value of the modifier type.
             */
            value?: string;
            /**
             * Required for builder modifiers. The sub-string to find and replace enclosed in curly brackets for `slug_builder` and `sku_builder`.
             */
            seek?: string;
            /**
             * Required for builder modifiers. The value to replace matches the `seek` string for `slug_builder` and `sku_builder`.
             */
            set?: string;
            /**
             * The name of the modifier.
             */
            reference_name?: string;
        };
        /**
         * The unique identifier of the modifier. Must match the modifier ID specified in the request path.
         */
        id: string;
    };
};

export type UpdateNode = {
    data?: {
        /**
         * The unique identifier of the node. Must match the node ID specified in the request path.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `node`.
         */
        type: 'node';
        attributes: AttributesNodes;
        meta?: {
            /**
             * You can sort the order of your nodes, regardless of where the nodes are in the hierarchy. The `sort_order` for each node. This value determines the order of nodes in the response for the `Get a Node’s Children` request. The node with the highest value of sort_order is displayed first. For example, a node with a sort_order value of 3 appears before a node with a sort_order value of 2.
             *
             * - If you don’t provide `sort_order` when creating nodes, all child nodes in the response for `Get a Node’s Children` request are ordered by the `updated_at` time in descending order, with the most recently updated child node first.
             * - If you set `sort_order` for only a few child nodes or not all, the child nodes with a `sort_order` value appear first and then other child nodes appear in the order of `updated_at` time.
             *
             */
            sort_order?: number;
        };
    };
};

export type UpdateOption = {
    data: {
        /**
         * This represents the type of resource object being returned. Always `product-variation-option`.
         */
        type: 'product-variation-option';
        attributes: {
            /**
             * A human recognizable identifier for the option, also used in the SLUG for child products. Option names can only contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
             */
            name?: string;
            /**
             * The description of the option.
             */
            description?: string;
            /**
             * By default, variations and variation options are sorted alphabetically. You can use the `sort_order` attribute to sort the order of your variation and variation options in the `variation_matrix`. The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want.
             *
             * The variation option with the highest value of `sort_order` is displayed first. For example, a variation option with a `sort_order` value of `3` appears before a variation option with a `sort_order` value of `2`.
             *
             * You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, and so on, zero or negative numbers.
             *
             * You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             *
             * You must rebuild your products for the sort order changes to take effect.
             *
             */
            sort_order?: number;
        };
        /**
         * The unique identifier of the option. Must match the option ID specified in the request path.
         */
        id: string;
    };
};

export type UpdateProductRequest = {
    data: {
        /**
         * This represents the type of resource object being returned. Always `product`.
         */
        type: 'product';
        /**
         * The unique identifier of the product. Must match the product ID specified in the request path.
         */
        id: string;
        attributes: ProductAttributes;
    };
};

export type UpdateVariation = {
    data: {
        /**
         * This represents the type of resource object being returned. Always `product-variation`.
         */
        type: 'product-variation';
        attributes: {
            /**
             * The variation name.
             */
            name?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want.
             *
             * The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2.
             *
             * You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             *
             * You must rebuild your products for the sort order changes to take effect.
             *
             */
            sort_order?: number;
        };
        /**
         * The unique identifier of the variation. Must match the variation ID specified in the request path.
         */
        id: string;
    };
};

export type VariationsResponse = {
    data?: Array<{
        /**
         * A unique identifier generated when a variation is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation`.
         */
        type?: 'product-variation';
        meta?: {
            /**
             * The date and time a resource is created.
             */
            created_at?: Date;
        };
    }>;
};

export type GetAllJobsResponse = (Multi);

export type GetAllJobsError = (Error);

export type GetJobData = {
    path: {
        /**
         * A unique identifier for the job.
         */
        jobID: string;
    };
};

export type GetJobResponse = (Single);

export type GetJobError = (Error);

export type CancelJobData = {
    body?: {
        [key: string]: unknown;
    };
    path: {
        /**
         * A unique identifier for the job.
         */
        jobID: string;
    };
};

export type CancelJobResponse = (Single);

export type CancelJobError = (Error);

export type GetJobErrorsData = {
    path: {
        /**
         * A unique identifier for the job.
         */
        jobID: string;
    };
};

export type GetJobErrorsResponse = (Errors);

export type GetJobErrorsError = (Error);

export type CreateProductData = {
    body: CreateProductRequest;
};

export type CreateProductResponse = (SingleProductResponse);

export type CreateProductError = (Error);

export type GetAllProductsData = {
    query?: {
        /**
         * Many Commerce API endpoints support filtering. The general syntax is described [**here**](/docs/commerce-cloud/api-overview/filtering).
         *
         * For more information about the attributes and operators that are supported, see [Get all products](/docs/api/pxm/products/get-all-products).
         *
         */
        filter?: string;
        /**
         * Using the include parameter, you can retrieve top-level resources.
         *
         * - Files or main image. For example, `include=files,main_image`.
         * - Component product data. For example, `include=component_products`.
         * - Key attribute data, such as SKU or slug.
         *
         */
        include?: string;
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetAllProductsResponse = (MultiProductResponse);

export type GetAllProductsError = (Error);

export type ImportProductsData = {
    body?: {
        /**
         * The file you want to upload. Ensure that the file format is Comma Separated Values (CSV).
         */
        file?: (Blob | File);
    };
};

export type ImportProductsResponse = (Single);

export type ImportProductsError = (Error);

export type ExportProductsData = {
    body?: {
        [key: string]: unknown;
    };
    query?: {
        /**
         *
         * Many Commerce API endpoints support filtering. The general syntax is described [**here**](/docs/commerce-cloud/api-overview/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
         *
         * For more information about the attributes and operators that this endpoint supports, see [Export Products](/docs/api/pxm/products/export-products).
         *
         */
        filter?: string;
        /**
         * Set to `true` if you want to use a template slug instead of a template ID when exporting products that have custom data.
         */
        useTemplateSlugs?: boolean;
    };
};

export type ExportProductsResponse = (Single);

export type ExportProductsError = (Error);

export type GetProductData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
    query?: {
        /**
         * Using the include parameter, you can retrieve top-level resources.
         *
         * - Files or main image. For example, `include=files,main_image`.
         * - Component product data. For example, `include=component_products`.
         * - Key attribute data, such as SKU or slug.
         *
         */
        include?: string;
    };
};

export type GetProductResponse = (SingleProductResponse);

export type GetProductError = (Error);

export type UpdateProductData = {
    body?: UpdateProductRequest;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type UpdateProductResponse = (SingleProductResponse);

export type UpdateProductError = (Error);

export type DeleteProductData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type DeleteProductResponse = (void);

export type DeleteProductError = (Error);

export type AttachNodesData = {
    body: {
        data: {
            /**
             * Filters applied to search for appropriate products to attach to a node. See [Attach multiple nodes](/docs/api/pxm/products/attach-nodes).
             *
             */
            filter: string;
            /**
             * A list of node unique identifiers that you want to assign to the products.
             */
            node_ids: Array<(string)>;
        };
    };
};

export type AttachNodesResponse = ({
    meta?: {
        /**
         * Number of nodes assigned to the products.
         */
        nodes_attached?: number;
        /**
         * A list of node unique identifiers that could not be identified.
         */
        nodes_not_found?: Array<(string)>;
    };
});

export type AttachNodesError = (Error);

export type DetachNodesData = {
    body: {
        data: {
            /**
             * You can apply filters to search for the appropriate products to detach. See [Detach multiple nodes](/docs/api/pxm/products/detach-nodes).
             *
             */
            filter: string;
            /**
             * A list of node unique identifiers that you want to assign to the products.
             */
            node_ids: Array<(string)>;
        };
    };
};

export type DetachNodesResponse = ({
    meta?: {
        /**
         * Number of nodes dissociated from the products.
         */
        nodes_detached?: number;
        /**
         * A list of node unique identifiers that could not be identified.
         */
        nodes_not_found?: Array<(string)>;
    };
});

export type DetachNodesError = (Error);

export type GetProductsNodesData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetProductsNodesResponse = (MultiNodes);

export type GetProductsNodesError = (Error);

export type BuildChildProductsData = {
    body?: {
        [key: string]: unknown;
    };
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type BuildChildProductsResponse = (unknown);

export type BuildChildProductsError = (Error);

export type GetChildProductsData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type GetChildProductsResponse = (MultiProductResponse);

export type GetChildProductsError = (Error);

export type CreateProductTemplateRelationshipData = {
    body?: ProductTemplatesRequest;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type CreateProductTemplateRelationshipResponse = (TemplateResponse);

export type CreateProductTemplateRelationshipError = (Error);

export type GetProductTemplateRelationshipsData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type GetProductTemplateRelationshipsResponse = (TemplateResponse);

export type GetProductTemplateRelationshipsError = (Error);

export type DeleteProductTemplateRelationshipData = {
    body?: ProductTemplatesRequest;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type DeleteProductTemplateRelationshipResponse = (void);

export type DeleteProductTemplateRelationshipError = (Error);

export type GetProductComponentProductsRelationshipsData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type GetProductComponentProductsRelationshipsResponse = (ComponentProductsResponse);

export type GetProductComponentProductsRelationshipsError = (Error);

export type GetProductFileRelationshipsData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type GetProductFileRelationshipsResponse = (FileResponse);

export type GetProductFileRelationshipsError = (Error);

export type CreateProductFileRelationshipsData = {
    body?: ProductFilesRequest;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type CreateProductFileRelationshipsResponse = (void);

export type CreateProductFileRelationshipsError = (Error);

export type UpdateProductFileRelationshipsData = {
    body?: ProductFilesRequest;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type UpdateProductFileRelationshipsResponse = (void);

export type UpdateProductFileRelationshipsError = (Error);

export type DeleteProductFileRelationshipsData = {
    body?: ProductFilesRequest;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type DeleteProductFileRelationshipsResponse = (void);

export type DeleteProductFileRelationshipsError = (Error);

export type CreateProductVariationRelationshipsData = {
    body?: ProductVariationsRequest;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type CreateProductVariationRelationshipsResponse = (void);

export type CreateProductVariationRelationshipsError = (Error);

export type GetProductVariationRelationshipsData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type GetProductVariationRelationshipsResponse = (VariationsResponse);

export type GetProductVariationRelationshipsError = (Error);

export type UpdateProductVariationRelationshipsData = {
    body?: ProductVariationsRequest;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type UpdateProductVariationRelationshipsResponse = (void);

export type UpdateProductVariationRelationshipsError = (Error);

export type DeleteProductVariationRelationshipsData = {
    body?: ProductVariationsRequest;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type DeleteProductVariationRelationshipsResponse = (void);

export type DeleteProductVariationRelationshipsError = (Error);

export type CreateProductMainImageRelationshipsData = {
    body?: MainImageRequest;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type CreateProductMainImageRelationshipsResponse = (void);

export type CreateProductMainImageRelationshipsError = (Error);

export type GetProductMainImageRelationshipsData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type GetProductMainImageRelationshipsResponse = (MainImageResponse);

export type GetProductMainImageRelationshipsError = (Error);

export type UpdateProductMainImageRelationshipsData = {
    body?: ReplaceMainImageRequest;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type UpdateProductMainImageRelationshipsResponse = (void);

export type UpdateProductMainImageRelationshipsError = (Error);

export type DeleteProductMainImageRelationshipsData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type DeleteProductMainImageRelationshipsResponse = (void);

export type DeleteProductMainImageRelationshipsError = (Error);

export type CreateVariationData = {
    body: CreateVariation;
};

export type CreateVariationResponse = (CreatedVariation);

export type CreateVariationError = (Error);

export type GetAllVariationsData = {
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetAllVariationsResponse = (MultiVariations);

export type GetAllVariationsError = (Error);

export type GetVariationData = {
    path: {
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type GetVariationResponse = (SingleVariation);

export type GetVariationError = (Error);

export type UpdateVariationData = {
    body?: UpdateVariation;
    path: {
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type UpdateVariationResponse = (SingleVariation);

export type UpdateVariationError = (Error);

export type DeleteVariationData = {
    path: {
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type DeleteVariationResponse = (void);

export type DeleteVariationError = (Error);

export type CreateVariationOptionData = {
    body?: CreateOption;
    path: {
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type CreateVariationOptionResponse = (CreatedOption);

export type CreateVariationOptionError = (Error);

export type GetAllVariationOptionsData = {
    path: {
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetAllVariationOptionsResponse = (MultiOptions);

export type GetAllVariationOptionsError = (Error);

export type GetVariationOptionData = {
    path: {
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type GetVariationOptionResponse = (SingleOption);

export type GetVariationOptionError = (Error);

export type UpdateVariationOptionData = {
    body?: UpdateOption;
    path: {
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type UpdateVariationOptionResponse = (SingleOption);

export type UpdateVariationOptionError = (Error);

export type DeleteVariationOptionData = {
    path: {
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type DeleteVariationOptionResponse = (void);

export type DeleteVariationOptionError = (Error);

export type CreateModifierData = {
    body?: CreateModifier;
    path: {
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type CreateModifierResponse = (CreatedModifier);

export type CreateModifierError = (Error);

export type GetAllModifiersData = {
    path: {
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetAllModifiersResponse = (MultiModifiers);

export type GetAllModifiersError = (Error);

export type GetModifierData = {
    path: {
        /**
         * A unique identifier for the modifier.
         */
        modifierID: string;
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type GetModifierResponse = (SingleModifier);

export type GetModifierError = (Error);

export type UpdateModifierData = {
    body?: UpdateModifier;
    path: {
        /**
         * A unique identifier for the modifier.
         */
        modifierID: string;
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type UpdateModifierResponse = (SingleModifier);

export type UpdateModifierError = (Error);

export type DeleteModifierData = {
    path: {
        /**
         * A unique identifier for the modifier.
         */
        modifierID: string;
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type DeleteModifierResponse = (void);

export type DeleteModifierError = (Error);

export type CreateHierarchyData = {
    body: CreateHierarchy;
};

export type CreateHierarchyResponse = (SingleHierarchy);

export type CreateHierarchyError = (Error);

export type GetHierarchyData = {
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetHierarchyResponse = (MultiHierarchy);

export type GetHierarchyError = (Error);

export type GetHierarchyChildData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
    };
};

export type GetHierarchyChildResponse = (SingleHierarchy);

export type GetHierarchyChildError = (Error);

export type UpdateHierarchyData = {
    body: UpdateHierarchy;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
    };
};

export type UpdateHierarchyResponse = (SingleHierarchy);

export type UpdateHierarchyError = (Error);

export type DeleteHierarchyData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
    };
};

export type DeleteHierarchyResponse = (void);

export type DeleteHierarchyError = (Error);

export type CreateNodeData = {
    body?: CreateNode;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
    };
};

export type CreateNodeResponse = (SingleNode);

export type CreateNodeError = (Error);

export type GetAllNodesInHierarchyData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
    };
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetAllNodesInHierarchyResponse = (MultiNodes);

export type GetAllNodesInHierarchyError = (Error);

export type GetHierarchyNodeData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type GetHierarchyNodeResponse = (SingleNode);

export type GetHierarchyNodeError = (Error);

export type UpdateNodeData = {
    body?: UpdateNode;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type UpdateNodeResponse = (SingleNode);

export type UpdateNodeError = (Error);

export type DeleteNodeData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type DeleteNodeResponse = (void);

export type DeleteNodeError = (Error);

export type GetAllChildrenData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
    };
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetAllChildrenResponse = (MultiNodes);

export type GetAllChildrenError = (Error);

export type CreateNodeChildRelationshipsData = {
    body?: NodeChildren;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type CreateNodeChildRelationshipsResponse = (SingleNode);

export type CreateNodeChildRelationshipsError = (Error);

export type GetAllNodeChildrenData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetAllNodeChildrenResponse = (MultiNodes);

export type GetAllNodeChildrenError = (Error);

export type UpdateNodeParentData = {
    body?: NodeParent;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type UpdateNodeParentResponse = (void);

export type UpdateNodeParentError = (Error);

export type DeleteNodeParentData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type DeleteNodeParentResponse = (void);

export type DeleteNodeParentError = (Error);

export type CreateNodeProductRelationshipData = {
    body?: NodeProducts;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type CreateNodeProductRelationshipResponse = (SingleNode);

export type CreateNodeProductRelationshipError = (Error);

export type DeleteNodeProductRelationshipsData = {
    body?: NodeProducts;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type DeleteNodeProductRelationshipsResponse = (SingleNode);

export type DeleteNodeProductRelationshipsError = (Error);

export type GetNodeProductsData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetNodeProductsResponse = (MultiProductResponse);

export type GetNodeProductsError = (Error);

export type DuplicateHierarchyData = {
    body: DuplicateJob;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
    };
};

export type DuplicateHierarchyResponse = (Single);

export type DuplicateHierarchyError = (Error);

export type GetAllProductTagsResponse = (MultiTag);

export type GetAllProductTagsError = (Error);

export type GetProductTagData = {
    path: {
        /**
         * A unique identifier for the tag.
         */
        tagID: string;
    };
};

export type GetProductTagResponse = (SingleTag);

export type GetProductTagError = (Error);

export type CreateCustomRelationshipData = {
    body: CreateCustomRelationship;
};

export type CreateCustomRelationshipResponse = (SingleCustomRelationship);

export type CreateCustomRelationshipError = (Error);

export type UpdateCustomRelationshipData = {
    body: UpdateCustomRelationship;
    path: {
        /**
         * A custom relationship slug.
         */
        customRelationshipSlug: string;
    };
};

export type UpdateCustomRelationshipResponse = (SingleCustomRelationship);

export type UpdateCustomRelationshipError = (Error);

export type GetAllJobsResponseTransformer = (data: any) => Promise<GetAllJobsResponse>;

export type MultiModelResponseTransformer = (data: any) => Multi;

export type JobModelResponseTransformer = (data: any) => Job;

export const JobModelResponseTransformer: JobModelResponseTransformer = data => {
    if (data?.attributes?.started_at) {
        data.attributes.started_at = new Date(data.attributes.started_at);
    }
    if (data?.attributes?.completed_at) {
        data.attributes.completed_at = new Date(data.attributes.completed_at);
    }
    if (data?.attributes?.created_at) {
        data.attributes.created_at = new Date(data.attributes.created_at);
    }
    if (data?.attributes?.updated_at) {
        data.attributes.updated_at = new Date(data.attributes.updated_at);
    }
    return data;
};

export const MultiModelResponseTransformer: MultiModelResponseTransformer = data => {
    if (Array.isArray(data?.data)) {
        data.data.forEach(JobModelResponseTransformer);
    }
    return data;
};

export const GetAllJobsResponseTransformer: GetAllJobsResponseTransformer = async (data) => {
    MultiModelResponseTransformer(data);
    return data;
};

export type GetJobResponseTransformer = (data: any) => Promise<GetJobResponse>;

export type SingleModelResponseTransformer = (data: any) => Single;

export const SingleModelResponseTransformer: SingleModelResponseTransformer = data => {
    if (data?.data) {
        JobModelResponseTransformer(data.data);
    }
    return data;
};

export const GetJobResponseTransformer: GetJobResponseTransformer = async (data) => {
    SingleModelResponseTransformer(data);
    return data;
};

export type CancelJobResponseTransformer = (data: any) => Promise<CancelJobResponse>;

export const CancelJobResponseTransformer: CancelJobResponseTransformer = async (data) => {
    SingleModelResponseTransformer(data);
    return data;
};

export type CreateProductResponseTransformer = (data: any) => Promise<CreateProductResponse>;

export type SingleProductResponseModelResponseTransformer = (data: any) => SingleProductResponse;

export type ProductResponseModelResponseTransformer = (data: any) => ProductResponse;

export const ProductResponseModelResponseTransformer: ProductResponseModelResponseTransformer = data => {
    if (data?.meta?.created_at) {
        data.meta.created_at = new Date(data.meta.created_at);
    }
    if (data?.meta?.updated_at) {
        data.meta.updated_at = new Date(data.meta.updated_at);
    }
    return data;
};

export const SingleProductResponseModelResponseTransformer: SingleProductResponseModelResponseTransformer = data => {
    if (data?.data) {
        ProductResponseModelResponseTransformer(data.data);
    }
    if (Array.isArray(data?.included?.component_products)) {
        data.included.component_products.forEach(ProductResponseModelResponseTransformer);
    }
    return data;
};

export const CreateProductResponseTransformer: CreateProductResponseTransformer = async (data) => {
    SingleProductResponseModelResponseTransformer(data);
    return data;
};

export type GetAllProductsResponseTransformer = (data: any) => Promise<GetAllProductsResponse>;

export type MultiProductResponseModelResponseTransformer = (data: any) => MultiProductResponse;

export const MultiProductResponseModelResponseTransformer: MultiProductResponseModelResponseTransformer = data => {
    if (Array.isArray(data?.data)) {
        data.data.forEach(ProductResponseModelResponseTransformer);
    }
    if (Array.isArray(data?.included?.component_products)) {
        data.included.component_products.forEach(ProductResponseModelResponseTransformer);
    }
    return data;
};

export const GetAllProductsResponseTransformer: GetAllProductsResponseTransformer = async (data) => {
    MultiProductResponseModelResponseTransformer(data);
    return data;
};

export type ImportProductsResponseTransformer = (data: any) => Promise<ImportProductsResponse>;

export const ImportProductsResponseTransformer: ImportProductsResponseTransformer = async (data) => {
    SingleModelResponseTransformer(data);
    return data;
};

export type ExportProductsResponseTransformer = (data: any) => Promise<ExportProductsResponse>;

export const ExportProductsResponseTransformer: ExportProductsResponseTransformer = async (data) => {
    SingleModelResponseTransformer(data);
    return data;
};

export type GetProductResponseTransformer = (data: any) => Promise<GetProductResponse>;

export const GetProductResponseTransformer: GetProductResponseTransformer = async (data) => {
    SingleProductResponseModelResponseTransformer(data);
    return data;
};

export type UpdateProductResponseTransformer = (data: any) => Promise<UpdateProductResponse>;

export const UpdateProductResponseTransformer: UpdateProductResponseTransformer = async (data) => {
    SingleProductResponseModelResponseTransformer(data);
    return data;
};

export type GetProductsNodesResponseTransformer = (data: any) => Promise<GetProductsNodesResponse>;

export type MultiNodesModelResponseTransformer = (data: any) => MultiNodes;

export type NodeModelResponseTransformer = (data: any) => Node;

export const NodeModelResponseTransformer: NodeModelResponseTransformer = data => {
    if (data?.meta?.created_at) {
        data.meta.created_at = new Date(data.meta.created_at);
    }
    if (data?.meta?.updated_at) {
        data.meta.updated_at = new Date(data.meta.updated_at);
    }
    return data;
};

export const MultiNodesModelResponseTransformer: MultiNodesModelResponseTransformer = data => {
    if (Array.isArray(data?.data)) {
        data.data.forEach(NodeModelResponseTransformer);
    }
    return data;
};

export const GetProductsNodesResponseTransformer: GetProductsNodesResponseTransformer = async (data) => {
    MultiNodesModelResponseTransformer(data);
    return data;
};

export type GetChildProductsResponseTransformer = (data: any) => Promise<GetChildProductsResponse>;

export const GetChildProductsResponseTransformer: GetChildProductsResponseTransformer = async (data) => {
    MultiProductResponseModelResponseTransformer(data);
    return data;
};

export type CreateVariationResponseTransformer = (data: any) => Promise<CreateVariationResponse>;

export type CreatedVariationModelResponseTransformer = (data: any) => CreatedVariation;

export const CreatedVariationModelResponseTransformer: CreatedVariationModelResponseTransformer = data => {
    if (data?.data?.meta?.created_at) {
        data.data.meta.created_at = new Date(data.data.meta.created_at);
    }
    if (data?.data?.meta?.updated_at) {
        data.data.meta.updated_at = new Date(data.data.meta.updated_at);
    }
    return data;
};

export const CreateVariationResponseTransformer: CreateVariationResponseTransformer = async (data) => {
    CreatedVariationModelResponseTransformer(data);
    return data;
};

export type CreateVariationOptionResponseTransformer = (data: any) => Promise<CreateVariationOptionResponse>;

export type CreatedOptionModelResponseTransformer = (data: any) => CreatedOption;

export const CreatedOptionModelResponseTransformer: CreatedOptionModelResponseTransformer = data => {
    if (data?.data?.meta?.created_at) {
        data.data.meta.created_at = new Date(data.data.meta.created_at);
    }
    if (data?.data?.meta?.updated_at) {
        data.data.meta.updated_at = new Date(data.data.meta.updated_at);
    }
    return data;
};

export const CreateVariationOptionResponseTransformer: CreateVariationOptionResponseTransformer = async (data) => {
    CreatedOptionModelResponseTransformer(data);
    return data;
};

export type GetVariationOptionResponseTransformer = (data: any) => Promise<GetVariationOptionResponse>;

export type SingleOptionModelResponseTransformer = (data: any) => SingleOption;

export const SingleOptionModelResponseTransformer: SingleOptionModelResponseTransformer = data => {
    if (data?.data?.meta?.created_at) {
        data.data.meta.created_at = new Date(data.data.meta.created_at);
    }
    if (data?.data?.meta?.updated_at) {
        data.data.meta.updated_at = new Date(data.data.meta.updated_at);
    }
    return data;
};

export const GetVariationOptionResponseTransformer: GetVariationOptionResponseTransformer = async (data) => {
    SingleOptionModelResponseTransformer(data);
    return data;
};

export type UpdateVariationOptionResponseTransformer = (data: any) => Promise<UpdateVariationOptionResponse>;

export const UpdateVariationOptionResponseTransformer: UpdateVariationOptionResponseTransformer = async (data) => {
    SingleOptionModelResponseTransformer(data);
    return data;
};

export type CreateHierarchyResponseTransformer = (data: any) => Promise<CreateHierarchyResponse>;

export type SingleHierarchyModelResponseTransformer = (data: any) => SingleHierarchy;

export type HierarchyModelResponseTransformer = (data: any) => Hierarchy;

export const HierarchyModelResponseTransformer: HierarchyModelResponseTransformer = data => {
    if (data?.meta?.created_at) {
        data.meta.created_at = new Date(data.meta.created_at);
    }
    if (data?.meta?.updated_at) {
        data.meta.updated_at = new Date(data.meta.updated_at);
    }
    return data;
};

export const SingleHierarchyModelResponseTransformer: SingleHierarchyModelResponseTransformer = data => {
    if (data?.data) {
        HierarchyModelResponseTransformer(data.data);
    }
    return data;
};

export const CreateHierarchyResponseTransformer: CreateHierarchyResponseTransformer = async (data) => {
    SingleHierarchyModelResponseTransformer(data);
    return data;
};

export type GetHierarchyResponseTransformer = (data: any) => Promise<GetHierarchyResponse>;

export type MultiHierarchyModelResponseTransformer = (data: any) => MultiHierarchy;

export const MultiHierarchyModelResponseTransformer: MultiHierarchyModelResponseTransformer = data => {
    if (Array.isArray(data?.data)) {
        data.data.forEach(HierarchyModelResponseTransformer);
    }
    return data;
};

export const GetHierarchyResponseTransformer: GetHierarchyResponseTransformer = async (data) => {
    MultiHierarchyModelResponseTransformer(data);
    return data;
};

export type GetHierarchyChildResponseTransformer = (data: any) => Promise<GetHierarchyChildResponse>;

export const GetHierarchyChildResponseTransformer: GetHierarchyChildResponseTransformer = async (data) => {
    SingleHierarchyModelResponseTransformer(data);
    return data;
};

export type UpdateHierarchyResponseTransformer = (data: any) => Promise<UpdateHierarchyResponse>;

export const UpdateHierarchyResponseTransformer: UpdateHierarchyResponseTransformer = async (data) => {
    SingleHierarchyModelResponseTransformer(data);
    return data;
};

export type CreateNodeResponseTransformer = (data: any) => Promise<CreateNodeResponse>;

export type SingleNodeModelResponseTransformer = (data: any) => SingleNode;

export const SingleNodeModelResponseTransformer: SingleNodeModelResponseTransformer = data => {
    if (data?.data) {
        NodeModelResponseTransformer(data.data);
    }
    return data;
};

export const CreateNodeResponseTransformer: CreateNodeResponseTransformer = async (data) => {
    SingleNodeModelResponseTransformer(data);
    return data;
};

export type GetAllNodesInHierarchyResponseTransformer = (data: any) => Promise<GetAllNodesInHierarchyResponse>;

export const GetAllNodesInHierarchyResponseTransformer: GetAllNodesInHierarchyResponseTransformer = async (data) => {
    MultiNodesModelResponseTransformer(data);
    return data;
};

export type GetHierarchyNodeResponseTransformer = (data: any) => Promise<GetHierarchyNodeResponse>;

export const GetHierarchyNodeResponseTransformer: GetHierarchyNodeResponseTransformer = async (data) => {
    SingleNodeModelResponseTransformer(data);
    return data;
};

export type UpdateNodeResponseTransformer = (data: any) => Promise<UpdateNodeResponse>;

export const UpdateNodeResponseTransformer: UpdateNodeResponseTransformer = async (data) => {
    SingleNodeModelResponseTransformer(data);
    return data;
};

export type GetAllChildrenResponseTransformer = (data: any) => Promise<GetAllChildrenResponse>;

export const GetAllChildrenResponseTransformer: GetAllChildrenResponseTransformer = async (data) => {
    MultiNodesModelResponseTransformer(data);
    return data;
};

export type CreateNodeChildRelationshipsResponseTransformer = (data: any) => Promise<CreateNodeChildRelationshipsResponse>;

export const CreateNodeChildRelationshipsResponseTransformer: CreateNodeChildRelationshipsResponseTransformer = async (data) => {
    SingleNodeModelResponseTransformer(data);
    return data;
};

export type GetAllNodeChildrenResponseTransformer = (data: any) => Promise<GetAllNodeChildrenResponse>;

export const GetAllNodeChildrenResponseTransformer: GetAllNodeChildrenResponseTransformer = async (data) => {
    MultiNodesModelResponseTransformer(data);
    return data;
};

export type CreateNodeProductRelationshipResponseTransformer = (data: any) => Promise<CreateNodeProductRelationshipResponse>;

export const CreateNodeProductRelationshipResponseTransformer: CreateNodeProductRelationshipResponseTransformer = async (data) => {
    SingleNodeModelResponseTransformer(data);
    return data;
};

export type DeleteNodeProductRelationshipsResponseTransformer = (data: any) => Promise<DeleteNodeProductRelationshipsResponse>;

export const DeleteNodeProductRelationshipsResponseTransformer: DeleteNodeProductRelationshipsResponseTransformer = async (data) => {
    SingleNodeModelResponseTransformer(data);
    return data;
};

export type GetNodeProductsResponseTransformer = (data: any) => Promise<GetNodeProductsResponse>;

export const GetNodeProductsResponseTransformer: GetNodeProductsResponseTransformer = async (data) => {
    MultiProductResponseModelResponseTransformer(data);
    return data;
};

export type DuplicateHierarchyResponseTransformer = (data: any) => Promise<DuplicateHierarchyResponse>;

export const DuplicateHierarchyResponseTransformer: DuplicateHierarchyResponseTransformer = async (data) => {
    SingleModelResponseTransformer(data);
    return data;
};

export type GetAllProductTagsResponseTransformer = (data: any) => Promise<GetAllProductTagsResponse>;

export type MultiTagModelResponseTransformer = (data: any) => MultiTag;

export type TagModelResponseTransformer = (data: any) => Tag;

export const TagModelResponseTransformer: TagModelResponseTransformer = data => {
    if (data?.meta?.created_at) {
        data.meta.created_at = new Date(data.meta.created_at);
    }
    if (data?.meta?.updated_at) {
        data.meta.updated_at = new Date(data.meta.updated_at);
    }
    return data;
};

export const MultiTagModelResponseTransformer: MultiTagModelResponseTransformer = data => {
    if (Array.isArray(data?.data)) {
        data.data.forEach(TagModelResponseTransformer);
    }
    return data;
};

export const GetAllProductTagsResponseTransformer: GetAllProductTagsResponseTransformer = async (data) => {
    MultiTagModelResponseTransformer(data);
    return data;
};

export type GetProductTagResponseTransformer = (data: any) => Promise<GetProductTagResponse>;

export type SingleTagModelResponseTransformer = (data: any) => SingleTag;

export const SingleTagModelResponseTransformer: SingleTagModelResponseTransformer = data => {
    if (data?.data) {
        TagModelResponseTransformer(data.data);
    }
    return data;
};

export const GetProductTagResponseTransformer: GetProductTagResponseTransformer = async (data) => {
    SingleTagModelResponseTransformer(data);
    return data;
};

export type CreateCustomRelationshipResponseTransformer = (data: any) => Promise<CreateCustomRelationshipResponse>;

export type SingleCustomRelationshipModelResponseTransformer = (data: any) => SingleCustomRelationship;

export type CustomRelationshipModelResponseTransformer = (data: any) => CustomRelationship;

export const CustomRelationshipModelResponseTransformer: CustomRelationshipModelResponseTransformer = data => {
    if (data?.meta?.timestamps?.created_at) {
        data.meta.timestamps.created_at = new Date(data.meta.timestamps.created_at);
    }
    if (data?.meta?.timestamps?.updated_at) {
        data.meta.timestamps.updated_at = new Date(data.meta.timestamps.updated_at);
    }
    return data;
};

export const SingleCustomRelationshipModelResponseTransformer: SingleCustomRelationshipModelResponseTransformer = data => {
    if (data?.data) {
        CustomRelationshipModelResponseTransformer(data.data);
    }
    return data;
};

export const CreateCustomRelationshipResponseTransformer: CreateCustomRelationshipResponseTransformer = async (data) => {
    SingleCustomRelationshipModelResponseTransformer(data);
    return data;
};

export type UpdateCustomRelationshipResponseTransformer = (data: any) => Promise<UpdateCustomRelationshipResponse>;

export const UpdateCustomRelationshipResponseTransformer: UpdateCustomRelationshipResponseTransformer = async (data) => {
    SingleCustomRelationshipModelResponseTransformer(data);
    return data;
};