// This file is auto-generated by @hey-api/openapi-ts

export type attributes = {
    /**
     * The name of the node, such as `Ranges` or `Refrigerators`. Names must be unique among sibling nodes in the hierarchy. Otherwise, a name can be non-unique within the hierarchy and across multiple hierarchies.
     */
    name?: string;
    /**
     * A description for a node.
     */
    description?: string;
    /**
     * A slug for the node. Slugs must be unique among sibling nodes in the hierarchy. Otherwise, a slug can be non-unique within the hierarchy and across multiple hierarchies.
     */
    slug?: string;
    /**
     * You can curate your products in your nodes product lists. Product curation allows you to promote specific products within each node in a hierarchy, enabling you to create unique product collections in your storefront.
     */
    curated_products?: Array<(string)>;
    /**
     * Product Experience Manager supports localization of hierarchies and nodes. If you store supports multiple languages, you can localize hierarchy and node names and descriptions.
     */
    locales?: {
        [key: string]: {
            /**
             * A localized hierarchy or node name.
             */
            name?: string;
            /**
             * A localized hierarchy or node description.
             */
            description?: string;
        };
    };
};

export type attributes_custom_relationship = {
    /**
     * The name of the custom relationship, such as `Kitchen electrics`.
     */
    name?: string;
    /**
     * A description of the custom relationship.
     */
    description?: string;
    /**
     * A unique slug for the custom relationship.
     */
    slug?: string;
};

export type attributes_hierarchy = {
    /**
     * The name of a hierarchy, such as `Major Appliances`.
     */
    name?: string;
    /**
     * A description for a hierarchy.
     */
    description?: string;
    /**
     * A unique slug for a hierarchy.
     */
    slug?: string;
    /**
     * Product Experience Manager supports localization of hierarchies and nodes. If you store supports multiple languages, you can localize hierarchy and node names and descriptions.
     */
    locales?: {
        [key: string]: {
            /**
             * A localized hierarchy or node name.
             */
            name?: string;
            /**
             * A localized hierarchy or node description.
             */
            description?: string;
        };
    };
};

export type attributes_nodes = {
    /**
     * The name of the node, such as `Ranges` or `Refrigerators`. Names must be unique among sibling nodes in the hierarchy. Otherwise, a name can be non-unique within the hierarchy and across multiple hierarchies.
     */
    name?: string;
    /**
     * A description of the node.
     */
    description?: string;
    /**
     * A slug for the node. Slugs must be unique among sibling nodes in the hierarchy. Otherwise, a slug can be non-unique within the hierarchy and across multiple hierarchies.
     */
    slug?: string;
    /**
     * You can curate your products in your nodes product lists. Product curation allows you to promote specific products within each node in a hierarchy, enabling you to create unique product collections in your storefront. See [Curating Products in a node](/docs/api/pxm/products/create-node#curating-products-in-a-node).
     */
    curated_products?: Array<(string)>;
    /**
     * Product Experience Manager supports localization of products and hierarchies. If your store supports multiple languages, you can localize product names and descriptions. You can have as many locales as you want.
     */
    locales?: {
        [key: string]: {
            /**
             * A localized name for the node.
             */
            name?: string;
            /**
             * A localized description for the node.
             */
            description?: string;
        };
    };
};

export type component_products_response = {
    data?: Array<{
        /**
         * The unique identifier of a product component generated when a product is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product`.
         */
        type?: 'product';
    }>;
};

export type create_custom_relationship = {
    data?: {
        /**
         * This represents the type of resource object being returned. Always `custom-relationship`.
         */
        type: 'custom-relationship';
        attributes: req_attributes_custom_relationship;
    };
};

/**
 * This represents the type of resource object being returned. Always `custom-relationship`.
 */
export type type = 'custom-relationship';

export type create_hierarchy = {
    data?: {
        /**
         * This represents the type of resource object being returned. Always `hierarchy`.
         */
        type: 'hierarchy';
        attributes: req_attributes_hierarchy;
    };
};

/**
 * This represents the type of resource object being returned. Always `hierarchy`.
 */
export type type2 = 'hierarchy';

/**
 * Use modifiers to change the properties of child products that are inherited from a parent product. With modifiers, you only need to have one parent product with a variation attached to the product.
 */
export type create_modifier = {
    data: {
        /**
         * This represents the type of resource object being returned. Always `product-variation-modifier`.
         */
        type: 'product-variation-modifier';
        attributes: {
            /**
             * You can specify different modifiers for different options in a variation. When you build child products using options in variations, the properties of a child products depends on the modifier set for the options that are applied to the child product. The table below describes the different types of modifiers.
             *
             * | Modifier | Data Type | Effect |
             * | :--- | :--- | :--- |
             * | `name_equals` | `string` | Overrides the name of the child product with the name specified by the modifier. |
             * | `name_append` | `string` | Appends the string specified in the modifier to the name of the child product. |
             * | `name_prepend` | `string` | Prepends the string specified in the modifier to the name of the child product. |
             * | `description_equals` | `string` | Overrides the description of the child product. |
             * | `description_append` | `string` | Appends the string specified in the modifier to the description of the child product. |
             * | `description_prepend` | `string` | Prepends the string specified in the modifier to the product description of the child product. |
             * | `commodity_type` | `string` | Sets the commodity type of the child product, such as `physical` or `digital`. |
             * | `price` | `string` | Allows application of price modifiers (`price_increment`, `price_decrement`, and `price_equals`) to the child products. |
             * | `price_increment` | `string` | Increases the price of the child product. |
             * | `price_decrement` | `string` | Decreases the price of the child product. |
             * | `price_equals` | `string` | Sets the price of a child product to the amount you specify. |
             * | `slug_append` | `string` | Appends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_prepend` | `string` | Prepends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_builder` | `string`| Sets a part of the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `sku_equals` | `string` | Sets the SKU of the child product. |
             * | `sku_append` | `string` | Appends the string specified in the modifier to the SKU of the child product. |
             * | `sku_prepend` | `string` | Prepends the string specified in the modifier to the SKU of the child product. |
             * | `sku_builder` | `string` | Sets a part of the SKU of the child product. |
             * | `status` | `string` | Sets the status of the child product, such as `draft` or `live`. |
             *
             */
            type: 'commodity_type' | 'status' | 'price' | 'name_append' | 'name_prepend' | 'name_equals' | 'sku_append' | 'sku_prepend' | 'sku_equals' | 'sku_builder' | 'slug_append' | 'slug_prepend' | 'slug_equals' | 'slug_builder' | 'description_append' | 'description_prepend' | 'description_equals' | 'custom_inputs_equals' | 'build_rules_equals' | 'locales_equals' | 'upc_ean_equals' | 'mpn_equals' | 'external_ref_equals';
            /**
             * Required for non-builder modifiers. The value of the modifier type.
             */
            value?: string;
            /**
             * Required for builder modifiers. The sub-string to find and replace enclosed in curly brackets for `slug_builder` and `sku_builder`.
             */
            seek?: string;
            /**
             * Required for builder modifiers. The value to replace matches the `seek` string for `slug_builder` and `sku_builder`.
             */
            set?: string;
            /**
             * A name for the modifier.
             */
            reference_name?: string;
        };
    };
};

/**
 * This represents the type of resource object being returned. Always `product-variation-modifier`.
 */
export type type3 = 'product-variation-modifier';

export type create_node = {
    data?: {
        /**
         * This represents the type of resource object being returned. Always `node`.
         */
        type: 'node';
        attributes: attributes_nodes;
        meta?: {
            /**
             * You can sort the order of your nodes, regardless of where the nodes are in the hierarchy. The `sort_order` for each node. This value determines the order of nodes in the response for the `Get a Node’s Children` request. The node with the highest value of sort_order is displayed first. For example, a node with a sort_order value of 3 appears before a node with a sort_order value of 2.
             *
             * - If you don’t provide `sort_order` when creating nodes, all child nodes in the response for `Get a Node’s Children` request are ordered by the `updated_at` time in descending order, with the most recently updated child node first.
             * - If you set `sort_order` for only a few child nodes or not all, the child nodes with a `sort_order` value appear first and then other child nodes appear in the order of `updated_at` time. See [Sorting Nodes in a hierarchy]().
             *
             */
            sort_order?: number;
        };
    };
};

/**
 * This represents the type of resource object being returned. Always `node`.
 */
export type type4 = 'node';

export type create_option = {
    data: {
        /**
         * This represents the type of resource object being returned. Always `product-variation-option`.
         */
        type: 'product-variation-option';
        attributes: {
            /**
             * A human recognizable identifier for the option, also used in the SLUG for child products. Option names can only contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
             */
            name?: string;
            /**
             * By default, variations and variation options are sorted alphabetically. You can use the `sort_order` attribute to sort the order of your variation and variation options in the `variation_matrix`.
             *
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want.
             *
             * The variation option with the highest value of `sort_order` is displayed first. For example, a variation option with a `sort_order` value of `3` appears before a variation option with a `sort_order` value of `2`. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, and so on, zero or negative numbers.
             *
             * You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             *
             * You must rebuild your products for the sort order changes to take effect.
             *
             */
            sort_order?: number;
            /**
             * A description of a product variation option.
             */
            description?: string;
        };
    };
};

/**
 * This represents the type of resource object being returned. Always `product-variation-option`.
 */
export type type5 = 'product-variation-option';

export type create_product_request = {
    data: {
        /**
         * This represents the type of resource being returned. Always `product`.
         */
        type: 'product';
        attributes: product_attributes;
        /**
         * Relationships are established between different product entities.
         */
        relationships?: {
            variations?: {
                data?: Array<{
                    /**
                     * A unique identifier for a resource.
                     */
                    id?: string;
                    /**
                     * This represents the type of resource object being returned.
                     */
                    type?: string;
                }>;
            };
        };
    };
};

/**
 * This represents the type of resource being returned. Always `product`.
 */
export type type6 = 'product';

export type create_variation = {
    data: {
        /**
         * This represents the type of resource object being returned. Always `product-variation`.
         */
        type: 'product-variation';
        attributes: {
            /**
             * The variation name.
             */
            name?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want.
             *
             * The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2.
             *
             * You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             *
             * You must rebuild your products for the sort order changes to take effect.
             *
             */
            sort_order?: number;
        };
    };
};

/**
 * This represents the type of resource object being returned. Always `product-variation`.
 */
export type type7 = 'product-variation';

export type created_modifier = {
    data?: {
        /**
         * A unique identifier for a modifier that is generated automatically when a modifier is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation-modifier'.
         */
        type?: 'product-variation-modifier';
        attributes?: {
            /**
             * You can specify different modifiers for different options in a variation. When you build child products using options in variations, the properties of a child products depends on the modifier set for the options that are applied to the child product. The table below describes the different types of modifiers.
             *
             * | Modifier | Data Type | Effect |
             * | :--- | :--- | :--- |
             * | `name_equals` | `string` | Overrides the name of the child product with the name specified by the modifier. |
             * | `name_append` | `string` | Appends the string specified in the modifier to the name of the child product. |
             * | `name_prepend` | `string` | Prepends the string specified in the modifier to the name of the child product. |
             * | `description_equals` | `string` | Overrides the description of the child product. |
             * | `description_append` | `string` | Appends the string specified in the modifier to the description of the child product. |
             * | `description_prepend` | `string` | Prepends the string specified in the modifier to the product description of the child product. |
             * | `commodity_type` | `string` | Sets the commodity type of the child product, such as `physical` or `digital`. |
             * | `price` | `string` | Allows application of price modifiers (`price_increment`, `price_decrement`, and `price_equals`) to the child products. |
             * | `price_increment` | `string` | Increases the price of the child product. |
             * | `price_decrement` | `string` | Decreases the price of the child product. |
             * | `price_equals` | `string` | Sets the price of a child product to the amount you specify. |
             * | `slug_append` | `string` | Appends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_prepend` | `string` | Prepends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_builder` | `string`| Sets a part of the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `sku_equals` | `string` | Sets the SKU of the child product. |
             * | `sku_append` | `string` | Appends the string specified in the modifier to the SKU of the child product. |
             * | `sku_prepend` | `string` | Prepends the string specified in the modifier to the SKU of the child product. |
             * | `sku_builder` | `string` | Sets a part of the SKU of the child product. |
             * | `status` | `string` | Sets the status of the child product, such as `draft` or `live`. |
             *
             */
            type?: 'commodity_type' | 'status' | 'price' | 'name_append' | 'name_prepend' | 'name_equals' | 'sku_append' | 'sku_prepend' | 'sku_equals' | 'sku_builder' | 'slug_append' | 'slug_prepend' | 'slug_equals' | 'slug_builder' | 'description_append' | 'description_prepend' | 'description_equals' | 'custom_inputs_equals' | 'build_rules_equals' | 'locales_equals' | 'upc_ean_equals' | 'mpn_equals' | 'external_ref_equals';
            /**
             * Required for non-builder modifiers. The value of the modifier type.
             */
            value?: string;
            /**
             * Required for builder modifiers. The sub-string to find and replace enclosed in curly brackets for `slug_builder` and `sku_builder`.
             */
            seek?: string;
            /**
             * Required for builder modifiers. The value to replace matches the `seek` string for `slug_builder` and `sku_builder`.
             */
            set?: string;
            /**
             * The name of the modifier.
             */
            reference_name?: string;
        };
        meta?: {
            /**
             * The owner of the resource, either `organization` or `store`.
             */
            owner?: 'organization' | 'store';
        };
    };
};

/**
 * The owner of the resource, either `organization` or `store`.
 */
export type owner = 'organization' | 'store';

export type created_option = {
    data: {
        /**
         * A unique identifier that is generated when an option is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation-option`.
         */
        type: 'product-variation-option';
        attributes: {
            /**
             * A human-recognizable identifier for the option, also used in the SLUG for child products. Option names can only contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
             */
            name?: string;
            /**
             * A human-recognizable description for the option.
             */
            description?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             */
            sort_order?: number;
        };
        meta?: {
            /**
             * The owner of a resource, either `organization` or `store`.
             */
            owner?: 'organization' | 'store';
            /**
             * The date and time an option is created.
             */
            created_at?: string;
            /**
             * The date and time an option is updated.
             */
            updated_at?: string;
        };
    };
};

export type created_variation = {
    data: {
        /**
         * A unique identifier generated when a variation is created.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation`.
         */
        type: 'product-variation';
        attributes: {
            /**
             * A human-recognizable identifier for a variation.
             */
            name?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             */
            sort_order?: number;
        };
        meta: {
            /**
             * The owner of the resource, either `organization` or `store`.
             */
            owner?: 'organization' | 'store';
            /**
             * The date and time a variation is created.
             */
            created_at?: string;
            /**
             * The date and time a variation is updated.
             */
            updated_at?: string;
        };
    };
};

export type custom_relationship = {
    /**
     * A unique identifier generated when a custom relationship is created.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned. Always `hierarchy`.
     */
    type?: 'custom-relationship';
    attributes?: attributes_custom_relationship;
    meta?: {
        /**
         * The owner of the resource.
         */
        owner?: string;
        timestamps?: {
            /**
             * The date and time the resource is created.
             */
            created_at?: string;
            /**
             * The date and time the resource is updated.
             */
            updated_at?: string;
        };
    };
};

export type duplicate_job = {
    data?: {
        /**
         * This represents the type of resource object being returned. Always `hierarchy`.
         */
        type?: 'hierarchy';
        attributes?: {
            /**
             * The name of the duplicate hierarchy. The maximum length is 1000 characters.
             */
            name?: string;
            /**
             * A description of the duplicate hierarchy.
             */
            description?: string;
            /**
             * Specify `true` if you want the product associations in the existing nodes associated in your duplicated hierarchy. If not, specify `false`.
             */
            include_products?: boolean;
        };
    };
};

export type error = {
    errors: Array<{
        /**
         * The HTTP response code of the error.
         */
        status: string;
        /**
         * A brief summary of the error.
         */
        title: string;
        /**
         * Optional additional detail about the error.
         */
        detail?: string;
        /**
         * Internal request ID.
         */
        request_id?: string;
        /**
         * Additional supporting meta data for the error.
         */
        meta?: {
            [key: string]: unknown;
        };
    }>;
};

export type errors = {
    /**
     * An array of job errors.
     */
    data?: Array<{
        /**
         * This represents the type of resource object being returned. Always `pim-job-error`.
         */
        type?: 'pim-job-error';
        /**
         * A unique identifier for a job error generated when a job error is created.
         */
        id?: string;
        attributes?: {
            /**
             * A description of an error message.
             */
            message?: string;
        };
    }>;
};

export type file_response = {
    data?: Array<{
        /**
         * The unique identifier of the new file.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `file`.
         */
        type?: 'file';
    }>;
};

export type hierarchy = {
    /**
     * A unique identifier generated when a hierarchy is created.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned. Always `hierarchy`.
     */
    type?: 'hierarchy';
    attributes?: attributes_hierarchy;
    relationships?: relationships_hierarchy;
    meta?: {
        /**
         * The date and time a hierarchy is created.
         */
        created_at?: string;
        /**
         * The date and time a hierarchy is updated.
         */
        updated_at?: string;
        /**
         * The owner of a resource, either `organization` or `store`.
         */
        owner?: 'store' | 'organization';
    };
};

export type job = {
    /**
     * A unique identifier generated when a job is created.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned. Always `pim-job`.
     */
    type?: 'pim-job';
    attributes?: {
        /**
         * The date and time a job is started.
         */
        started_at?: (string) | null;
        /**
         * The date and time a job is completed.
         */
        completed_at?: (string) | null;
        /**
         * The date and time a job is created.
         */
        created_at?: string;
        /**
         * The date and time a job is updated.
         */
        updated_at?: string;
        /**
         * The status of a job.
         *
         * * `pending` - Commerce has received the request but is currently busy processing other requests.
         * * `started` - Commerce has started processing the job.
         * * `success` - The job has successfully completed.
         * * `failed` - The job has failed.
         *
         */
        type?: 'child-products' | 'product-import' | 'product-export' | 'hierarchy-duplicate' | 'price-import';
        status?: 'pending' | 'cancelled' | 'started' | 'success' | 'failed';
    };
    meta?: {
        /**
         * Applies to all job types. A unique request ID is generated when a job is created.
         */
        x_request_id?: string;
        /**
         * Applies to `hierarchy-duplicate` job types. The ID of the original hierarchy that you duplicated.
         */
        copied_from?: string;
        /**
         * Applies to `hierarchy-duplicate` job types. The duplicated hierarchy ID.
         */
        hierarchy_id?: string;
        /**
         * If the job type is `product_export`, a link to the file is created when running a job.
         */
        file_locations?: Array<(string)> | null;
        /**
         * The entities included in the job. For example, if the job type is `product-export`, the PXM products included in the export.
         */
        filter?: string;
    };
};

/**
 * This represents the type of resource object being returned. Always `pim-job`.
 */
export type type8 = 'pim-job';

export type status = 'pending' | 'cancelled' | 'started' | 'success' | 'failed';

export type main_image_request = {
    data?: {
        /**
         * The ID of the image file.
         */
        id?: string;
        /**
         * This represents the type of resource being returned. Always `file`.
         */
        type?: 'file';
    };
};

/**
 * This represents the type of resource being returned. Always `file`.
 */
export type type9 = 'file';

export type main_image_response = {
    data?: Array<{
        /**
         * A unique identifier for the image file generated automatically when a file is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `file`.
         */
        type?: string;
    }>;
};

export type multi = {
    /**
     * An array of jobs.
     */
    data?: Array<job>;
    meta?: {
        /**
         * Contains the results for the entire collection.
         */
        results?: {
            /**
             * Total number of results for the entire collection.
             */
            total?: number;
        };
    };
};

export type multi_hierarchy = {
    data?: Array<hierarchy>;
    links?: multi_links;
    meta?: multi_meta;
};

/**
 * Links are used to allow you to move between requests.
 */
export type multi_links = {
    /**
     * Always the first page.
     */
    first?: string;
    /**
     * This is `null` if there is only one page.
     */
    last?: string;
    /**
     * This is `null` if there is only one page.
     */
    next?: string;
    /**
     * This is `null` if you on the first page.
     */
    prev?: string;
};

export type multi_meta = {
    /**
     * Contains the results for the entire collection.
     */
    results?: {
        /**
         * Total number of results for the entire collection.
         */
        total?: number;
    };
};

export type multi_modifiers = {
    data?: Array<{
        /**
         * A unique identifier for a modifier that is generated automatically when a modifier is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation-modifier'.
         */
        type?: 'product-variation-modifier';
        attributes?: {
            /**
             * You can specify different modifiers for different options in a variation. When you build child products using options in variations, the properties of a child products depends on the modifier set for the options that are applied to the child product. The table below describes the different types of modifiers.
             *
             * | Modifier | Data Type | Effect |
             * | :--- | :--- | :--- |
             * | `name_equals` | `string` | Overrides the name of the child product with the name specified by the modifier. |
             * | `name_append` | `string` | Appends the string specified in the modifier to the name of the child product. |
             * | `name_prepend` | `string` | Prepends the string specified in the modifier to the name of the child product. |
             * | `description_equals` | `string` | Overrides the description of the child product. |
             * | `description_append` | `string` | Appends the string specified in the modifier to the description of the child product. |
             * | `description_prepend` | `string` | Prepends the string specified in the modifier to the product description of the child product. |
             * | `commodity_type` | `string` | Sets the commodity type of the child product, such as `physical` or `digital`. |
             * | `price` | `string` | Allows application of price modifiers (`price_increment`, `price_decrement`, and `price_equals`) to the child products. |
             * | `price_increment` | `string` | Increases the price of the child product. |
             * | `price_decrement` | `string` | Decreases the price of the child product. |
             * | `price_equals` | `string` | Sets the price of a child product to the amount you specify. |
             * | `slug_append` | `string` | Appends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_prepend` | `string` | Prepends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_builder` | `string`| Sets a part of the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `sku_equals` | `string` | Sets the SKU of the child product. |
             * | `sku_append` | `string` | Appends the string specified in the modifier to the SKU of the child product. |
             * | `sku_prepend` | `string` | Prepends the string specified in the modifier to the SKU of the child product. |
             * | `sku_builder` | `string` | Sets a part of the SKU of the child product. |
             * | `status` | `string` | Sets the status of the child product, such as `draft` or `live`. |
             *
             */
            type?: 'commodity_type' | 'status' | 'price' | 'name_append' | 'name_prepend' | 'name_equals' | 'sku_append' | 'sku_prepend' | 'sku_equals' | 'sku_builder' | 'slug_append' | 'slug_prepend' | 'slug_equals' | 'slug_builder' | 'description_append' | 'description_prepend' | 'description_equals' | 'custom_inputs_equals' | 'build_rules_equals' | 'locales_equals' | 'upc_ean_equals' | 'mpn_equals' | 'external_ref_equals';
            /**
             * Required for non-builder modifiers. The value of the modifier type.
             */
            value?: string;
            /**
             * Required for builder modifiers. The sub-string to find and replace enclosed in curly brackets for `slug_builder` and `sku_builder`.
             */
            seek?: string;
            /**
             * Required for builder modifiers. The value to replace matches the `seek` string for `slug_builder` and `sku_builder`.
             */
            set?: string;
            /**
             * The name of the modifier.
             */
            reference_name?: string;
        };
        meta?: {
            /**
             * The owner of a resource, either `organization` or `store`.
             */
            owner?: 'store' | 'organization';
        };
    }>;
    meta?: {
        /**
         * Contains the results for the entire collection.
         */
        results?: {
            /**
             * Total number of results for the entire collection.
             */
            total?: number;
        };
    };
};

export type multi_nodes = {
    /**
     * An array of nodes.
     */
    data?: Array<node>;
    meta?: multi_meta;
    links?: multi_links;
};

export type multi_options = {
    data?: Array<{
        /**
         * A unique identifier generated when an option is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation-option`.
         */
        type?: 'product-variation-option';
        attributes?: {
            /**
             * A human-recognizable identifier for the option, also used in the SLUG for child products. Option names can only contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
             */
            name?: string;
            /**
             * A human-recognizable description for the option.
             */
            description?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             */
            sort_order?: number;
        };
        meta?: {
            /**
             * The owner of a resource, either `organization` or `store`.
             */
            owner?: 'organization' | 'store';
            /**
             * The date and time an option is created.
             */
            created_at?: string;
            /**
             * The date and time an option is updated.
             */
            updated_at?: string;
        };
    }>;
    meta?: {
        /**
         * Contains the results for the entire collection.
         */
        results?: {
            /**
             * Total number of results for the entire collection.
             */
            total?: number;
        };
    };
};

export type multi_product_response = {
    data?: Array<product_response>;
    /**
     * Returns a list of component products in a product bundle. If a bundle has no component products (in other words, is not a product bundle), an empty array is returned.
     */
    included?: {
        /**
         * Returns a list of component products in a product bundle. If a bundle has no component products (in other words, is not a product bundle), an empty array is returned.
         */
        component_products?: Array<product_response>;
    };
    meta?: {
        /**
         * Contains the results for the entire collection.
         */
        results?: {
            /**
             * Total number of results for the entire collection.
             */
            total?: number;
        };
    };
};

export type multi_tag = {
    /**
     * An array of tags.
     */
    data?: Array<tag>;
    meta?: {
        /**
         * Contains the results for the entire collection.
         */
        results?: {
            /**
             * Total number of results for the entire collection.
             */
            total?: number;
        };
    };
};

export type multi_variations = {
    data?: Array<{
        /**
         * A unique identifier for a variation.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation`.
         */
        type?: 'product-variation';
        attributes?: {
            /**
             * The name of a variation.
             */
            name?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             */
            sort_order?: number;
        };
        meta?: {
            options?: Array<{
                /**
                 * A unique ID that is generated when an option is created.
                 */
                id?: string;
                /**
                 * A human recognizable identifier for the option, also used in the SLUG for child products. Option names can only contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
                 */
                name?: string;
                /**
                 * A human recognizable description of the option.
                 */
                description?: string;
                /**
                 * The date and time an option is created.
                 */
                created_at?: string;
                /**
                 * The date and time an option is updated.
                 */
                updated_at?: string;
                /**
                 * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
                 */
                sort_order?: number;
            }>;
            /**
             * The owner of the resource, either `organization` or `store`.
             */
            owner?: 'organization' | 'store';
            /**
             * The date and time a variation is created.
             */
            created_at?: string;
            /**
             * The date and time a variation is updated.
             */
            updated_at?: string;
        };
    }>;
    meta?: {
        /**
         * Contains the results for the entire collection.
         */
        results?: {
            /**
             * Total number of results for the entire collection.
             */
            total?: number;
        };
    };
};

export type node = {
    /**
     * The unique identifier of a node.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned. Always `node`.
     */
    type?: 'node';
    attributes?: attributes;
    relationships?: relationships;
    meta?: {
        /**
         * The sort order value. The node with the highest value of `sort_order` is displayed first. For example, a node with a `sort_order` value of `3` appears before a node with a `sort_order` value of `2`. See [Sorting Nodes in a hierarchy](/docs/api/pxm/products/create-node#sorting-nodes-in-a-hierarchy).
         */
        sort_order?: number;
        /**
         * The date and time a node is created.
         */
        created_at?: string;
        /**
         * The date and time a node was updated.
         */
        updated_at?: string;
        /**
         * The name of the parent of the node if one exists.
         */
        parent_name?: string;
        /**
         * The node owner, either `organization` or `store`.
         */
        owner?: 'store' | 'organization';
    };
};

export type node_children = {
    data?: Array<{
        /**
         * The unique identifier of the child node. Must not match the node ID specified in the request path.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `node`.
         */
        type: 'node';
    }>;
};

export type node_parent = {
    data?: {
        /**
         * The unique identifier of the new parent node. Must not match the node ID specified in the request path.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `node`.
         */
        type: 'node';
    };
};

export type node_products = {
    data?: Array<{
        /**
         * The unique identifier of the product to be attached to the node.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `product`.
         */
        type: 'product';
    }>;
};

/**
 * A custom relationship slug.
 */
export type Parametercustom_relationship_slug = string;

/**
 *
 * Many Commerce API endpoints support filtering. The general syntax is described [**here**](/docs/commerce-cloud/api-overview/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
 *
 * For more information about the attributes and operators that this endpoint supports, see [Export Products](/docs/api/pxm/products/export-products).
 *
 */
export type Parameterfilterexport = string;

/**
 * Many Commerce API endpoints support filtering. The general syntax is described [**here**](/docs/commerce-cloud/api-overview/filtering).
 *
 * For more information about the attributes and operators that are supported, see [Get all products](/docs/api/pxm/products/get-all-products).
 *
 */
export type Parameterfilterproduct = string;

/**
 * A unique identifier for the hierarchy.
 */
export type Parameterhierarchy_id = string;

/**
 * Using the include parameter, you can retrieve top-level resources.
 *
 * - Files or main image. For example, `include=files,main_image`.
 * - Component product data. For example, `include=component_products`.
 * - Key attribute data, such as SKU or slug.
 *
 */
export type Parameterinclude = string;

/**
 * A unique identifier for the job.
 */
export type Parameterjob_id = string;

/**
 * A unique identifier for the modifier.
 */
export type Parametermodifier_id = string;

/**
 * A unique identifier for the node.
 */
export type Parameternode_id = string;

/**
 * A unique identifier for the option.
 */
export type Parameteroption_id = string;

/**
 * The number of records per page. The maximum limit is 100.
 */
export type Parameterpage_limit = number;

/**
 * The number of records to offset the results by.
 */
export type Parameterpage_offset = number;

/**
 * A unique identifier for the product.
 */
export type Parameterproduct_id = string;

/**
 * A unique identifier for the tag.
 */
export type Parametertag_id = string;

/**
 * Set to `true` if you want to use a template slug instead of a template ID when exporting products that have custom data.
 */
export type ParameteruseTemplateSlugs = boolean;

/**
 * A unique identifier for the variation.
 */
export type Parametervariation_id = string;

export type product_attributes = {
    /**
     * The unique attribute associated with the product. This could be an external reference from a separate company system, for example. The maximum length is 2048 characters.
     */
    external_ref?: string;
    /**
     * The product name to display to customers.
     */
    name?: string;
    /**
     * A description for the product.
     */
    description?: string;
    /**
     * The unique slug of the product. A slug can contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
     */
    slug?: string;
    /**
     * The unique stock keeping unit of the product.
     */
    sku?: string;
    /**
     * The status for the product, either `draft` or `live`. Default is `draft`.
     */
    status?: 'live' | 'draft';
    /**
     * The commodity type, either `physical` or `digital`.
     */
    commodity_type?: 'physical' | 'digital';
    /**
     * The universal product code or european article number of the product.
     */
    upc_ean?: string;
    /**
     * The manufacturer part number of the product.
     */
    mpn?: string;
    /**
     * You can use product tags to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. A product can have up to 20 tags. A product tag can be up to 255 characters. Product tags must not contain any spaces or commas. See [Product Tags](/docs/api/pxm/products/product-tags).
     */
    tags?: Array<(string)>;
    build_rules?: product_build_rules;
    locales?: product_locales;
    custom_inputs?: product_custom_inputs;
    components?: product_bundle_components;
};

/**
 * The status for the product, either `draft` or `live`. Default is `draft`.
 */
export type status2 = 'live' | 'draft';

/**
 * The commodity type, either `physical` or `digital`.
 */
export type commodity_type = 'physical' | 'digital';

/**
 * You can build a combination of child products associated with a product, based on build rules that you specify. This is useful, for example, if you have a variation option that you do not sell. This makes managing and building your child products quick and easy. See [Using Build Rules](/docs/api/pxm/products/build-child-products#using-build-rules).
 */
export type product_build_rules = {
    /**
     * Specifies the default behaviour, either `include` or `exclude`.
     */
    default?: 'include' | 'exclude';
    /**
     * An array of option IDs to include when child products are built. Each combination consists of a nested array of option IDs from one or more variations. Combinations of option IDs in the nested arrays must come from different variations.
     */
    include?: Array<Array<(string)>>;
    /**
     * An array of option IDs to exclude when child products are built. Each combination consists of a nested array of option IDs from one or more variations. Combinations of option IDs in the nested arrays must come from different variations.
     */
    exclude?: Array<Array<(string)>>;
};

/**
 * Specifies the default behaviour, either `include` or `exclude`.
 */
export type default = 'include' | 'exclude';

/**
 * With Product Experience Manager, you can create and manage bundles. A bundle is a purchasable product, comprising of one or more products that you want to sell together. You can create multiple components within a bundle. Each component must have at least one or more options. Each option is a product and a quantity. See [Bundles](/docs/api/pxm/products/products#bundles).
 */
export type product_bundle_components = {
    [key: string]: {
        /**
         * The component name. The component name is the name that is displayed in your storefront.
         */
        name?: string;
        /**
         * The product options included in a component. This can be the ID of another bundle.
         */
        options?: Array<{
            /**
             * The unique ID of the product you want to add to a component.
             */
            id?: string;
            /**
             * This represents the type of object being returned. Always `product`.
             */
            type?: string;
            /**
             * The number of this product option that a shopper must purchase.
             */
            quantity?: number;
            /**
             * The sort order of the options. The `create a bundle` and `update a bundle` endpoints do not sort the options. You can use the `sort_order` attribute when programming your storefront to display the options in the order that you want.
             */
            sort_order?: number;
            /**
             * Whether the product option is a default option in a bundle. Shoppers can select a bundle that specifies a default list of product options. See [Dynamic Bundles](/docs/api/pxm/products/products#dynamic-bundles).
             */
            default?: boolean;
        }>;
        /**
         * The minimum number of product options a shopper can select from this component.
         */
        min?: number;
        /**
         * The maximum number of product options a shopper can select from this component.
         */
        max?: number;
        /**
         * The sort order of the components. The `create a bundle` and `update a bundle` endpoints do not sort the components. You can use the `sort_order` attribute when programming your storefront to display the components in the order that you want.
         */
        sort_order?: number;
    };
};

/**
 * You use the `custom_inputs` attribute to allow your shoppers to add custom text to a product when adding product items to their carts. This is useful, for example, if you have a product like a T-shirt that can be personalized or you sell greetings cards that can be printed with your shoppers personalized messages. See [Personalizing Products](/docs/api/pxm/products/create-product#personalizing-products).
 */
export type product_custom_inputs = {
    [key: string]: {
        /**
         * A name for the custom text field.
         */
        name?: string;
        /**
         * The validation rules for the custom text.
         */
        validation_rules?: unknown[];
        /**
         * This represents the type of the resource being returned.
         */
        type?: string;
        /**
         * The length of the custom input text field.
         */
        options?: {
            [key: string]: unknown;
        };
        /**
         * The number of characters the custom text field can be. You can specify a maximum length up to 255 characters, as the limit is 255 characters.
         */
        max_length?: number;
        /**
         * `true` or `false` depending on whether the custom text is required.
         */
        required?: boolean;
    };
};

export type product_files_request = {
    data?: Array<{
        /**
         * A unique identifier for a file generated when a file is created.
         */
        id?: string;
        /**
         * This represents the type of resource being returned. Always `file`.
         */
        type?: 'file';
        meta?: {
            /**
             * The files associated with a product.
             */
            tags?: Array<(string)>;
        };
    }>;
};

/**
 * Product Experience Manager supports localization of products and hierarchies. If your store supports multiple languages, you can localize product names and descriptions. You can have as many locales as you want.
 */
export type product_locales = {
    [key: string]: {
        /**
         * A localized name for the product.
         */
        name: string;
        /**
         * A localized description for the product.
         */
        description?: string;
    };
};

export type product_response = {
    /**
     * A unique product ID that is generated when you create the product.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned. Always `product`.
     */
    type?: 'product';
    attributes?: {
        /**
         * A name for the product.
         */
        name?: string;
        /**
         * A description for the product.
         */
        description?: string;
        /**
         * A label for the product that is used in the URL paths. A slug can contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. By default, the product name is used as the slug.
         */
        slug?: string;
        /**
         * The unique stock keeping unit of the product.
         */
        sku?: string;
        /**
         * The status for the product, either `draft` or `live`.
         */
        status?: 'live' | 'draft';
        /**
         * The commodity type, either `physical` or `digital`.
         */
        commodity_type?: 'physical' | 'digital';
        /**
         * The universal product code or european article number of the product.
         */
        upc_ean?: string;
        /**
         * The manufacturer part number of the product.
         */
        mpn?: string;
        /**
         * The unique attribute associated with the product. This could be an external reference from a separate company system, for example. The maximum length is 2048 characters.
         */
        external_ref?: string;
        /**
         * Product Experience Manager supports localization of products and hierarchies. If your store supports multiple languages, you can localize product names and descriptions. You can have as many locales as you want.
         */
        locales?: {
            [key: string]: unknown;
        };
        /**
         * You can use product tags to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. A product can have up to 20 tags. A product tag can be up to 255 characters. Product tags must not contain any spaces or commas.
         */
        tags?: Array<(string)>;
        extensions?: {
            [key: string]: {
                [key: string]: ((string) | null | number | boolean);
            };
        };
        custom_inputs?: product_custom_inputs;
        build_rules?: product_build_rules;
        components?: product_bundle_components;
    };
    meta?: {
        /**
         * The date and time a product is created.
         */
        created_at?: string;
        /**
         * The date and time a product is updated.
         */
        updated_at?: string;
        /**
         * The resource owner, either `organization` or `store`.
         */
        owner?: 'organization' | 'store';
        /**
         * A product's variations and the options defined for each variation. If you have specified `build_rules`, only the child products included in the `build_rules` are specified.
         */
        variations?: Array<{
            /**
             * A unique ID generated when a variation is created.
             */
            id?: string;
            /**
             * The name of a variation.
             */
            name?: string;
            options?: Array<{
                /**
                 * A unique ID that is generated an option is created.
                 */
                id?: string;
                /**
                 * The name of an option.
                 */
                name?: string;
                /**
                 * A description of an option.
                 */
                description?: string;
            }>;
        }>;
        /**
         * One of the following product types:
         *
         * - `standard` - A `standard` product is a standalone product.
         * - `parent` - A `parent` product is a product that has child products that have been built using the `Build Child Products` endpoint.
         * - `child` - When you configure product variations and variation options for `parent` products, the `child` products derived from the `parent` products are automatically created in Commerce.
         * - `bundle` - A `bundle` is a purchasable product, comprising one or more standalone products (in other words, components) to be sold together.
         *
         */
        product_types?: Array<('parent' | 'child' | 'bundle' | 'standard')>;
        /**
         * The child products defined for a product. The order of the variations in the `variation_matrix` is the order of the variations in the array when the variations were linked to the product. For example, the first variation in the `variation_matrix` corresponds to the first variation in the array, and so on. You can use the `sort_order`attribute to sort the order of your variation and variation options in the `variation_matrix` object. See [Sorting the Order of Variations and Options](/docs/api/pxm/products/variations#sorting-the-order-of-variations-and-options) If no variations are defined for a product, the `variation_matrix` is empty.
         */
        variation_matrix?: {
            [key: string]: unknown;
        };
    };
    /**
     * Relationships are established between different product entities. For example, a `bundle` product and a `child` product are related to a `parent` product, as both are associated with it.
     */
    relationships?: {
        [key: string]: {
            data?: (Array<{
    /**
     * A unique identifier for a resource.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned.
     */
    type?: string;
}> | {
    /**
     * A unique identifier for a resource.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned.
     */
    type?: string;
} | null);
            /**
             * Links are used to allow you to move between requests. Single entities use a `self` parameter with a link to that specific resource. Sometimes, there are not enough entities for a project to fill multiple pages. In this situation, we return some defaults.
             *
             * | Property | Description |
             * | :--- | :--- |
             * | `current` | Always the current page. |
             * | `first` | Always the first page. |
             * | `last` | `null` if there is only one page. |
             * | `prev` | `null` if the user is on the first page. |
             * | `next` | `null` if there is only one page. |
             *
             */
            links?: {
                [key: string]: (string);
            };
        };
    };
};

export type product_templates_request = {
    data?: Array<{
        /**
         * The unique identifier of a template.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `template'.
         */
        type?: 'template';
    }>;
};

export type product_variations_request = {
    data?: Array<{
        /**
         * The ID of the product variation.
         */
        id?: string;
        /**
         * This represents the type of resource being returned. Always `product-variation`.
         */
        type?: 'product-variation';
    }>;
};

/**
 * Relationships allow you to move between requests. Includes links to the child nodes and products associated with a hierarchy or node.
 */
export type relationships = {
    /**
     * The child nodes related to the resource.
     */
    children?: {
        /**
         * An array of child nodes.
         */
        data?: unknown[];
        /**
         * Links allow you to move between requests.
         */
        links?: {
            /**
             * A link to a related resource.
             */
            related?: string;
        };
    };
    /**
     * The parent node related to the resource
     */
    parent?: {
        /**
         * The parent node
         */
        data?: {
            /**
             * This represents the type of resource object being returned. Always `node`.
             */
            type: 'node';
            /**
             * The unique identifier of a node.
             */
            id: string;
        };
    };
    /**
     * The products related to the resource.
     */
    products?: {
        /**
         * An array of products.
         */
        data?: unknown[];
        /**
         * Links allow you to move between requests.
         */
        links?: {
            /**
             * A link to a related resource.
             */
            related?: string;
        };
    };
};

export type relationships_hierarchy = {
    /**
     * The child nodes related to the hierarchy.
     */
    children?: {
        /**
         * An array of child nodes.
         */
        data?: unknown[];
        /**
         * Links allow you to move between requests.
         */
        links?: {
            /**
             * A link to a related resource.
             */
            related?: string;
        };
    };
};

export type replace_main_image_request = {
    data?: Array<{
        /**
         * The ID of the new image file.
         */
        id?: string;
        type?: 'file';
    }>;
};

export type req_attributes_custom_relationship = {
    /**
     * The name of the custom relationship, such as `Kitchen electrics`.
     */
    name?: string;
    /**
     * A description of the custom relationship.
     */
    description?: string;
    /**
     * A unique slug for the custom relationship. Must match the slug specified in the request path.
     */
    slug?: string;
};

export type req_attributes_hierarchy = {
    /**
     * The name of the hierarchy, such as `Major Appliances`.
     */
    name?: string;
    /**
     * A description of the hierarchy.
     */
    description?: string;
    /**
     * A unique slug for the hierarchy.
     */
    slug?: string;
    /**
     * Product Experience Manager supports localization of products and hierarchies. If your store supports multiple languages, you can localize product names and descriptions. You can have as many locales as you want.
     */
    locales?: {
        [key: string]: {
            /**
             * A localized name for the hierarchy.
             */
            name?: string;
            /**
             * A localized description for the hierarchy.
             */
            description?: string;
        };
    };
};

export type single = {
    data?: job;
};

export type single_custom_relationship = {
    data?: custom_relationship;
};

export type single_hierarchy = {
    data?: hierarchy;
};

export type single_modifier = {
    data?: {
        /**
         * A unique identifier for a modifier that is generated automatically when a modifier is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation-modifier'.
         */
        type?: 'product-variation-modifier';
        attributes?: {
            /**
             * You can specify different modifiers for different options in a variation. When you build child products using options in variations, the properties of a child products depends on the modifier set for the options that are applied to the child product. The table below describes the different types of modifiers.
             *
             * | Modifier | Data Type | Effect |
             * | :--- | :--- | :--- |
             * | `name_equals` | `string` | Overrides the name of the child product with the name specified by the modifier. |
             * | `name_append` | `string` | Appends the string specified in the modifier to the name of the child product. |
             * | `name_prepend` | `string` | Prepends the string specified in the modifier to the name of the child product. |
             * | `description_equals` | `string` | Overrides the description of the child product. |
             * | `description_append` | `string` | Appends the string specified in the modifier to the description of the child product. |
             * | `description_prepend` | `string` | Prepends the string specified in the modifier to the product description of the child product. |
             * | `commodity_type` | `string` | Sets the commodity type of the child product, such as `physical` or `digital`. |
             * | `price` | `string` | Allows application of price modifiers (`price_increment`, `price_decrement`, and `price_equals`) to the child products. |
             * | `price_increment` | `string` | Increases the price of the child product. |
             * | `price_decrement` | `string` | Decreases the price of the child product. |
             * | `price_equals` | `string` | Sets the price of a child product to the amount you specify. |
             * | `slug_append` | `string` | Appends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_prepend` | `string` | Prepends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_builder` | `string`| Sets a part of the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `sku_equals` | `string` | Sets the SKU of the child product. |
             * | `sku_append` | `string` | Appends the string specified in the modifier to the SKU of the child product. |
             * | `sku_prepend` | `string` | Prepends the string specified in the modifier to the SKU of the child product. |
             * | `sku_builder` | `string` | Sets a part of the SKU of the child product. |
             * | `status` | `string` | Sets the status of the child product, such as `draft` or `live`. |
             *
             */
            type?: 'commodity_type' | 'status' | 'price' | 'name_append' | 'name_prepend' | 'name_equals' | 'sku_append' | 'sku_prepend' | 'sku_equals' | 'sku_builder' | 'slug_append' | 'slug_prepend' | 'slug_equals' | 'slug_builder' | 'description_append' | 'description_prepend' | 'description_equals' | 'custom_inputs_equals' | 'build_rules_equals' | 'locales_equals' | 'upc_ean_equals' | 'mpn_equals' | 'external_ref_equals';
            /**
             * Required for non-builder modifiers. The value of the modifier type.
             */
            value?: string;
            /**
             * Required for builder modifiers. The sub-string to find and replace enclosed in curly brackets for `slug_builder` and `sku_builder`.
             */
            seek?: string;
            /**
             * Required for builder modifiers. The value to replace matches the `seek` string for `slug_builder` and `sku_builder`.
             */
            set?: string;
            /**
             * The name of the modifier.
             */
            reference_name?: string;
        };
        /**
         * The owner of the resource, either `organization` or `store`.
         */
        meta?: {
            owner?: 'organization' | 'store';
        };
    };
};

export type single_node = {
    data?: node;
};

export type single_option = {
    data: {
        /**
         * The unique identifier generated when an option is created.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation-option`.
         */
        type: 'product-variation-option';
        /**
         * A variation option represents an option for selection for a single product-variation. For example, if your variation is `color`, you might have three possible options; red, green, and blue.
         */
        attributes: {
            /**
             * A human-recognizable identifier for the option, also used in the SLUG for child products. Option names can only contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
             */
            name?: string;
            /**
             * A human-recognizable description for the option.
             */
            description?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             */
            sort_order?: number;
        };
        meta: {
            /**
             * The owner of a resource, either `organization` or `store`.
             */
            owner?: 'organization' | 'store';
            /**
             * The date and time an option is created.
             */
            created_at?: string;
            /**
             * The date and time an option is updated.
             */
            updated_at?: string;
        };
    };
};

export type single_product_response = {
    data?: product_response;
    /**
     * Returns a list of component products in a product bundle. If a bundle has no component products (in other words, is not a product bundle), an empty array is returned.
     */
    included?: {
        /**
         * A list of component products in a product bundle. If a bundle has no component products (in other words, is not a product bundle), an empty array is returned.
         */
        component_products?: Array<product_response>;
    };
};

export type single_tag = {
    data?: tag;
};

export type single_variation = {
    data: {
        /**
         * A unique identifier for a variation.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation`.
         */
        type: 'product-variation';
        attributes: {
            /**
             * The name for a variation.
             */
            name?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             */
            sort_order?: number;
        };
        meta: {
            /**
             * A variation option represents an option for selection for a single product-variation. For example, if your variation is `color`, you might have three possible options; red, green, and blue.
             */
            options?: Array<{
                /**
                 * A unique ID that is generated an option is created.
                 */
                id?: string;
                /**
                 * A human-recognizable identifier for the option, also used in the SLUG for child products. Option names can only contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
                 */
                name?: string;
                /**
                 * A description for an option.
                 */
                description?: string;
                /**
                 * The date and time an option is created.
                 */
                created_at?: string;
                /**
                 * The date and time an option is updated.
                 */
                updated_at?: string;
                /**
                 * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want. The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2. You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
                 */
                sort_order?: number;
            }>;
            /**
             * The owner of the resource, either `organization` or `store`.
             */
            owner?: 'organization' | 'store';
            /**
             * The date and time a variation is created.
             */
            created_at?: string;
            /**
             * The date and time a variation is updated.
             */
            updated_at?: string;
        };
    };
};

export type tag = {
    /**
     * A unique identifier generated when a tag is created.
     */
    id?: string;
    /**
     * This represents the type of resource object being returned. Always `tag`.
     */
    type?: 'tag';
    attributes?: {
        /**
         * The text value of the tag.
         */
        value?: string;
    };
    meta?: {
        /**
         * A unique request ID is generated when a tag is created.
         */
        x_request_id?: string;
        /**
         * The date and time a tag is created.
         */
        created_at?: string;
        /**
         * The date and time a tag is updated.
         */
        updated_at?: string;
        /**
         * The owner of a resource, either `organization` or `store`.
         */
        owner?: 'store' | 'organization';
    };
};

/**
 * This represents the type of resource object being returned. Always `tag`.
 */
export type type10 = 'tag';

export type template_response = {
    data?: Array<{
        /**
         * A unique identifier for a template generated when a template is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `template`.
         */
        type?: 'template';
    }>;
};

export type update_custom_relationship = {
    data: {
        /**
         * The unique identifier of the custom relationship.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `custom-relationship`.
         */
        type: 'custom-relationship';
        attributes: req_attributes_custom_relationship;
    };
};

export type update_hierarchy = {
    data: {
        /**
         * The unique identifier of the hierarchy. Must match the hierarchy ID specified in the request path.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `hierarchy`.
         */
        type: 'hierarchy';
        attributes: req_attributes_hierarchy;
    };
};

export type update_modifier = {
    data: {
        /**
         * This represents the type of resource object being returned. Always `product-variation-modifier`.
         */
        type: 'product-variation-modifier';
        attributes: {
            /**
             * You can specify different modifiers for different options in a variation. When you build child products using options in variations, the properties of a child products depends on the modifier set for the options that are applied to the child product. The table below describes the different types of modifiers.
             *
             * | Modifier | Data Type | Effect |
             * | :--- | :--- | :--- |
             * | `name_equals` | `string` | Overrides the name of the child product with the name specified by the modifier. |
             * | `name_append` | `string` | Appends the string specified in the modifier to the name of the child product. |
             * | `name_prepend` | `string` | Prepends the string specified in the modifier to the name of the child product. |
             * | `description_equals` | `string` | Overrides the description of the child product. |
             * | `description_append` | `string` | Appends the string specified in the modifier to the description of the child product. |
             * | `description_prepend` | `string` | Prepends the string specified in the modifier to the product description of the child product. |
             * | `commodity_type` | `string` | Sets the commodity type of the child product, such as `physical` or `digital`. |
             * | `price` | `string` | Allows application of price modifiers (`price_increment`, `price_decrement`, and `price_equals`) to the child products. |
             * | `price_increment` | `string` | Increases the price of the child product. |
             * | `price_decrement` | `string` | Decreases the price of the child product. |
             * | `price_equals` | `string` | Sets the price of a child product to the amount you specify. |
             * | `slug_append` | `string` | Appends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_prepend` | `string` | Prepends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `slug_builder` | `string`| Sets a part of the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
             * | `sku_equals` | `string` | Sets the SKU of the child product. |
             * | `sku_append` | `string` | Appends the string specified in the modifier to the SKU of the child product. |
             * | `sku_prepend` | `string` | Prepends the string specified in the modifier to the SKU of the child product. |
             * | `sku_builder` | `string` | Sets a part of the SKU of the child product. |
             * | `status` | `string` | Sets the status of the child product, such as `draft` or `live`. |
             *
             */
            type: 'commodity_type' | 'status' | 'price' | 'name_append' | 'name_prepend' | 'name_equals' | 'sku_append' | 'sku_prepend' | 'sku_equals' | 'sku_builder' | 'slug_append' | 'slug_prepend' | 'slug_equals' | 'slug_builder' | 'description_append' | 'description_prepend' | 'description_equals' | 'custom_inputs_equals' | 'build_rules_equals' | 'locales_equals' | 'upc_ean_equals' | 'mpn_equals' | 'external_ref_equals';
            /**
             * Required for non-builder modifiers. The value of the modifier type.
             */
            value?: string;
            /**
             * Required for builder modifiers. The sub-string to find and replace enclosed in curly brackets for `slug_builder` and `sku_builder`.
             */
            seek?: string;
            /**
             * Required for builder modifiers. The value to replace matches the `seek` string for `slug_builder` and `sku_builder`.
             */
            set?: string;
            /**
             * The name of the modifier.
             */
            reference_name?: string;
        };
        /**
         * The unique identifier of the modifier. Must match the modifier ID specified in the request path.
         */
        id: string;
    };
};

export type update_node = {
    data?: {
        /**
         * The unique identifier of the node. Must match the node ID specified in the request path.
         */
        id: string;
        /**
         * This represents the type of resource object being returned. Always `node`.
         */
        type: 'node';
        attributes: attributes_nodes;
        meta?: {
            /**
             * You can sort the order of your nodes, regardless of where the nodes are in the hierarchy. The `sort_order` for each node. This value determines the order of nodes in the response for the `Get a Node’s Children` request. The node with the highest value of sort_order is displayed first. For example, a node with a sort_order value of 3 appears before a node with a sort_order value of 2.
             *
             * - If you don’t provide `sort_order` when creating nodes, all child nodes in the response for `Get a Node’s Children` request are ordered by the `updated_at` time in descending order, with the most recently updated child node first.
             * - If you set `sort_order` for only a few child nodes or not all, the child nodes with a `sort_order` value appear first and then other child nodes appear in the order of `updated_at` time.
             *
             */
            sort_order?: number;
        };
    };
};

export type update_option = {
    data: {
        /**
         * This represents the type of resource object being returned. Always `product-variation-option`.
         */
        type: 'product-variation-option';
        attributes: {
            /**
             * A human recognizable identifier for the option, also used in the SLUG for child products. Option names can only contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
             */
            name?: string;
            /**
             * The description of the option.
             */
            description?: string;
            /**
             * By default, variations and variation options are sorted alphabetically. You can use the `sort_order` attribute to sort the order of your variation and variation options in the `variation_matrix`. The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want.
             *
             * The variation option with the highest value of `sort_order` is displayed first. For example, a variation option with a `sort_order` value of `3` appears before a variation option with a `sort_order` value of `2`.
             *
             * You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, and so on, zero or negative numbers.
             *
             * You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             *
             * You must rebuild your products for the sort order changes to take effect.
             *
             */
            sort_order?: number;
        };
        /**
         * The unique identifier of the option. Must match the option ID specified in the request path.
         */
        id: string;
    };
};

export type update_product_request = {
    data: {
        /**
         * This represents the type of resource object being returned. Always `product`.
         */
        type: 'product';
        /**
         * The unique identifier of the product. Must match the product ID specified in the request path.
         */
        id: string;
        attributes: product_attributes;
    };
};

export type update_variation = {
    data: {
        /**
         * This represents the type of resource object being returned. Always `product-variation`.
         */
        type: 'product-variation';
        attributes: {
            /**
             * The variation name.
             */
            name?: string;
            /**
             * The sort order value is visible when you add the variations and variation options to your catalogs. You can then use the `sort_order` value to program your storefront to display the variation options in the order that you want.
             *
             * The variation with the highest value of `sort_order` is displayed first. For example, a variation with a `sort_order` value of 3 appears before a variation with a `sort_order` value of 2.
             *
             * You can specify any numbers that you want. You can use 1, 2, 3, or 100, 90, 80, including, zero or negative numbers. You can set `sort_order` to either `null` or omit it entirely from the request if you wish to remove an existing `sort_order` attribute.
             *
             * You must rebuild your products for the sort order changes to take effect.
             *
             */
            sort_order?: number;
        };
        /**
         * The unique identifier of the variation. Must match the variation ID specified in the request path.
         */
        id: string;
    };
};

export type variations_response = {
    data?: Array<{
        /**
         * A unique identifier generated when a variation is created.
         */
        id?: string;
        /**
         * This represents the type of resource object being returned. Always `product-variation`.
         */
        type?: 'product-variation';
        meta?: {
            /**
             * The date and time a resource is created.
             */
            created_at?: string;
        };
    }>;
};

export type GetAllJobsResponse = (multi);

export type GetAllJobsError = (error);

export type GetJobData = {
    path: {
        /**
         * A unique identifier for the job.
         */
        jobID: string;
    };
};

export type GetJobResponse = (single);

export type GetJobError = (error);

export type CancelJobData = {
    body?: {
        [key: string]: unknown;
    };
    path: {
        /**
         * A unique identifier for the job.
         */
        jobID: string;
    };
};

export type CancelJobResponse = (single);

export type CancelJobError = (error);

export type GetJobErrorsData = {
    path: {
        /**
         * A unique identifier for the job.
         */
        jobID: string;
    };
};

export type GetJobErrorsResponse = (errors);

export type GetJobErrorsError = (error);

export type CreateProductData = {
    body: create_product_request;
};

export type CreateProductResponse = (single_product_response);

export type CreateProductError = (error);

export type GetAllProductsData = {
    query?: {
        /**
         * Many Commerce API endpoints support filtering. The general syntax is described [**here**](/docs/commerce-cloud/api-overview/filtering).
         *
         * For more information about the attributes and operators that are supported, see [Get all products](/docs/api/pxm/products/get-all-products).
         *
         */
        filter?: string;
        /**
         * Using the include parameter, you can retrieve top-level resources.
         *
         * - Files or main image. For example, `include=files,main_image`.
         * - Component product data. For example, `include=component_products`.
         * - Key attribute data, such as SKU or slug.
         *
         */
        include?: string;
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetAllProductsResponse = (multi_product_response);

export type GetAllProductsError = (error);

export type ImportProductsData = {
    body?: {
        /**
         * The file you want to upload. Ensure that the file format is Comma Separated Values (CSV).
         */
        file?: (Blob | File);
    };
};

export type ImportProductsResponse = (single);

export type ImportProductsError = (error);

export type ExportProductsData = {
    body?: {
        [key: string]: unknown;
    };
    query?: {
        /**
         *
         * Many Commerce API endpoints support filtering. The general syntax is described [**here**](/docs/commerce-cloud/api-overview/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
         *
         * For more information about the attributes and operators that this endpoint supports, see [Export Products](/docs/api/pxm/products/export-products).
         *
         */
        filter?: string;
        /**
         * Set to `true` if you want to use a template slug instead of a template ID when exporting products that have custom data.
         */
        useTemplateSlugs?: boolean;
    };
};

export type ExportProductsResponse = (single);

export type ExportProductsError = (error);

export type GetProductData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
    query?: {
        /**
         * Using the include parameter, you can retrieve top-level resources.
         *
         * - Files or main image. For example, `include=files,main_image`.
         * - Component product data. For example, `include=component_products`.
         * - Key attribute data, such as SKU or slug.
         *
         */
        include?: string;
    };
};

export type GetProductResponse = (single_product_response);

export type GetProductError = (error);

export type UpdateProductData = {
    body?: update_product_request;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type UpdateProductResponse = (single_product_response);

export type UpdateProductError = (error);

export type DeleteProductData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type DeleteProductResponse = (void);

export type DeleteProductError = (error);

export type AttachNodesData = {
    body: {
        data: {
            /**
             * Filters applied to search for appropriate products to attach to a node. See [Attach multiple nodes](/docs/api/pxm/products/attach-nodes).
             *
             */
            filter: string;
            /**
             * A list of node unique identifiers that you want to assign to the products.
             */
            node_ids: Array<(string)>;
        };
    };
};

export type AttachNodesResponse = ({
    meta?: {
        /**
         * Number of nodes assigned to the products.
         */
        nodes_attached?: number;
        /**
         * A list of node unique identifiers that could not be identified.
         */
        nodes_not_found?: Array<(string)>;
    };
});

export type AttachNodesError = (error);

export type DetachNodesData = {
    body: {
        data: {
            /**
             * You can apply filters to search for the appropriate products to detach. See [Detach multiple nodes](/docs/api/pxm/products/detach-nodes).
             *
             */
            filter: string;
            /**
             * A list of node unique identifiers that you want to assign to the products.
             */
            node_ids: Array<(string)>;
        };
    };
};

export type DetachNodesResponse = ({
    meta?: {
        /**
         * Number of nodes dissociated from the products.
         */
        nodes_detached?: number;
        /**
         * A list of node unique identifiers that could not be identified.
         */
        nodes_not_found?: Array<(string)>;
    };
});

export type DetachNodesError = (error);

export type GetProductsNodesData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetProductsNodesResponse = (multi_nodes);

export type GetProductsNodesError = (error);

export type BuildChildProductsData = {
    body?: {
        [key: string]: unknown;
    };
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type BuildChildProductsResponse = (unknown);

export type BuildChildProductsError = (error);

export type GetChildProductsData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type GetChildProductsResponse = (multi_product_response);

export type GetChildProductsError = (error);

export type CreateProductTemplateRelationshipData = {
    body?: product_templates_request;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type CreateProductTemplateRelationshipResponse = (template_response);

export type CreateProductTemplateRelationshipError = (error);

export type GetProductTemplateRelationshipsData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type GetProductTemplateRelationshipsResponse = (template_response);

export type GetProductTemplateRelationshipsError = (error);

export type DeleteProductTemplateRelationshipData = {
    body?: product_templates_request;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type DeleteProductTemplateRelationshipResponse = (void);

export type DeleteProductTemplateRelationshipError = (error);

export type GetProductComponentProductsRelationshipsData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type GetProductComponentProductsRelationshipsResponse = (component_products_response);

export type GetProductComponentProductsRelationshipsError = (error);

export type GetProductFileRelationshipsData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type GetProductFileRelationshipsResponse = (file_response);

export type GetProductFileRelationshipsError = (error);

export type CreateProductFileRelationshipsData = {
    body?: product_files_request;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type CreateProductFileRelationshipsResponse = (void);

export type CreateProductFileRelationshipsError = (error);

export type UpdateProductFileRelationshipsData = {
    body?: product_files_request;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type UpdateProductFileRelationshipsResponse = (void);

export type UpdateProductFileRelationshipsError = (error);

export type DeleteProductFileRelationshipsData = {
    body?: product_files_request;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type DeleteProductFileRelationshipsResponse = (void);

export type DeleteProductFileRelationshipsError = (error);

export type CreateProductVariationRelationshipsData = {
    body?: product_variations_request;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type CreateProductVariationRelationshipsResponse = (void);

export type CreateProductVariationRelationshipsError = (error);

export type GetProductVariationRelationshipsData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type GetProductVariationRelationshipsResponse = (variations_response);

export type GetProductVariationRelationshipsError = (error);

export type UpdateProductVariationRelationshipsData = {
    body?: product_variations_request;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type UpdateProductVariationRelationshipsResponse = (void);

export type UpdateProductVariationRelationshipsError = (error);

export type DeleteProductVariationRelationshipsData = {
    body?: product_variations_request;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type DeleteProductVariationRelationshipsResponse = (void);

export type DeleteProductVariationRelationshipsError = (error);

export type CreateProductMainImageRelationshipsData = {
    body?: main_image_request;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type CreateProductMainImageRelationshipsResponse = (void);

export type CreateProductMainImageRelationshipsError = (error);

export type GetProductMainImageRelationshipsData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type GetProductMainImageRelationshipsResponse = (main_image_response);

export type GetProductMainImageRelationshipsError = (error);

export type UpdateProductMainImageRelationshipsData = {
    body?: replace_main_image_request;
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type UpdateProductMainImageRelationshipsResponse = (void);

export type UpdateProductMainImageRelationshipsError = (error);

export type DeleteProductMainImageRelationshipsData = {
    path: {
        /**
         * A unique identifier for the product.
         */
        productID: string;
    };
};

export type DeleteProductMainImageRelationshipsResponse = (void);

export type DeleteProductMainImageRelationshipsError = (error);

export type CreateVariationData = {
    body: create_variation;
};

export type CreateVariationResponse = (created_variation);

export type CreateVariationError = (error);

export type GetAllVariationsData = {
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetAllVariationsResponse = (multi_variations);

export type GetAllVariationsError = (error);

export type GetVariationData = {
    path: {
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type GetVariationResponse = (single_variation);

export type GetVariationError = (error);

export type UpdateVariationData = {
    body?: update_variation;
    path: {
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type UpdateVariationResponse = (single_variation);

export type UpdateVariationError = (error);

export type DeleteVariationData = {
    path: {
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type DeleteVariationResponse = (void);

export type DeleteVariationError = (error);

export type CreateVariationOptionData = {
    body?: create_option;
    path: {
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type CreateVariationOptionResponse = (created_option);

export type CreateVariationOptionError = (error);

export type GetAllVariationOptionsData = {
    path: {
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetAllVariationOptionsResponse = (multi_options);

export type GetAllVariationOptionsError = (error);

export type GetVariationOptionData = {
    path: {
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type GetVariationOptionResponse = (single_option);

export type GetVariationOptionError = (error);

export type UpdateVariationOptionData = {
    body?: update_option;
    path: {
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type UpdateVariationOptionResponse = (single_option);

export type UpdateVariationOptionError = (error);

export type DeleteVariationOptionData = {
    path: {
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type DeleteVariationOptionResponse = (void);

export type DeleteVariationOptionError = (error);

export type CreateModifierData = {
    body?: create_modifier;
    path: {
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type CreateModifierResponse = (created_modifier);

export type CreateModifierError = (error);

export type GetAllModifiersData = {
    path: {
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetAllModifiersResponse = (multi_modifiers);

export type GetAllModifiersError = (error);

export type GetModifierData = {
    path: {
        /**
         * A unique identifier for the modifier.
         */
        modifierID: string;
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type GetModifierResponse = (single_modifier);

export type GetModifierError = (error);

export type UpdateModifierData = {
    body?: update_modifier;
    path: {
        /**
         * A unique identifier for the modifier.
         */
        modifierID: string;
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type UpdateModifierResponse = (single_modifier);

export type UpdateModifierError = (error);

export type DeleteModifierData = {
    path: {
        /**
         * A unique identifier for the modifier.
         */
        modifierID: string;
        /**
         * A unique identifier for the option.
         */
        optionID: string;
        /**
         * A unique identifier for the variation.
         */
        variationID: string;
    };
};

export type DeleteModifierResponse = (void);

export type DeleteModifierError = (error);

export type CreateHierarchyData = {
    body: create_hierarchy;
};

export type CreateHierarchyResponse = (single_hierarchy);

export type CreateHierarchyError = (error);

export type GetHierarchyData = {
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetHierarchyResponse = (multi_hierarchy);

export type GetHierarchyError = (error);

export type GetHierarchyChildData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
    };
};

export type GetHierarchyChildResponse = (single_hierarchy);

export type GetHierarchyChildError = (error);

export type UpdateHierarchyData = {
    body: update_hierarchy;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
    };
};

export type UpdateHierarchyResponse = (single_hierarchy);

export type UpdateHierarchyError = (error);

export type DeleteHierarchyData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
    };
};

export type DeleteHierarchyResponse = (void);

export type DeleteHierarchyError = (error);

export type CreateNodeData = {
    body?: create_node;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
    };
};

export type CreateNodeResponse = (single_node);

export type CreateNodeError = (error);

export type GetAllNodesInHierarchyData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
    };
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetAllNodesInHierarchyResponse = (multi_nodes);

export type GetAllNodesInHierarchyError = (error);

export type GetHierarchyNodeData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type GetHierarchyNodeResponse = (single_node);

export type GetHierarchyNodeError = (error);

export type UpdateNodeData = {
    body?: update_node;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type UpdateNodeResponse = (single_node);

export type UpdateNodeError = (error);

export type DeleteNodeData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type DeleteNodeResponse = (void);

export type DeleteNodeError = (error);

export type GetAllChildrenData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
    };
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetAllChildrenResponse = (multi_nodes);

export type GetAllChildrenError = (error);

export type CreateNodeChildRelationshipsData = {
    body?: node_children;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type CreateNodeChildRelationshipsResponse = (single_node);

export type CreateNodeChildRelationshipsError = (error);

export type GetAllNodeChildrenData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetAllNodeChildrenResponse = (multi_nodes);

export type GetAllNodeChildrenError = (error);

export type UpdateNodeParentData = {
    body?: node_parent;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type UpdateNodeParentResponse = (void);

export type UpdateNodeParentError = (error);

export type DeleteNodeParentData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type DeleteNodeParentResponse = (void);

export type DeleteNodeParentError = (error);

export type CreateNodeProductRelationshipData = {
    body?: node_products;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type CreateNodeProductRelationshipResponse = (single_node);

export type CreateNodeProductRelationshipError = (error);

export type DeleteNodeProductRelationshipsData = {
    body?: node_products;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
};

export type DeleteNodeProductRelationshipsResponse = (single_node);

export type DeleteNodeProductRelationshipsError = (error);

export type GetNodeProductsData = {
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
        /**
         * A unique identifier for the node.
         */
        nodeID: string;
    };
    query?: {
        /**
         * The number of records per page. The maximum limit is 100.
         */
        'page[limit]'?: number;
        /**
         * The number of records to offset the results by.
         */
        'page[offset]'?: number;
    };
};

export type GetNodeProductsResponse = (multi_product_response);

export type GetNodeProductsError = (error);

export type DuplicateHierarchyData = {
    body: duplicate_job;
    path: {
        /**
         * A unique identifier for the hierarchy.
         */
        hierarchyID: string;
    };
};

export type DuplicateHierarchyResponse = (single);

export type DuplicateHierarchyError = (error);

export type GetAllProductTagsResponse = (multi_tag);

export type GetAllProductTagsError = (error);

export type GetProductTagData = {
    path: {
        /**
         * A unique identifier for the tag.
         */
        tagID: string;
    };
};

export type GetProductTagResponse = (single_tag);

export type GetProductTagError = (error);

export type CreateCustomRelationshipData = {
    body: create_custom_relationship;
};

export type CreateCustomRelationshipResponse = (single_custom_relationship);

export type CreateCustomRelationshipError = (error);

export type UpdateCustomRelationshipData = {
    body: update_custom_relationship;
    path: {
        /**
         * A custom relationship slug.
         */
        customRelationshipSlug: string;
    };
};

export type UpdateCustomRelationshipResponse = (single_custom_relationship);

export type UpdateCustomRelationshipError = (error);