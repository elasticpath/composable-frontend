// This file is auto-generated by @hey-api/openapi-ts

import {
  createClient,
  createConfig,
  type OptionsLegacyParser,
  formDataBodySerializer,
} from "@hey-api/client-fetch"
import type {
  GetAllJobsError,
  GetAllJobsResponse,
  GetJobData,
  GetJobError,
  GetJobResponse,
  CancelJobData,
  CancelJobError,
  CancelJobResponse,
  GetJobErrorsData,
  GetJobErrorsError,
  GetJobErrorsResponse,
  CreateProductData,
  CreateProductError,
  CreateProductResponse,
  GetAllProductsData,
  GetAllProductsError,
  GetAllProductsResponse,
  ImportProductsData,
  ImportProductsError,
  ImportProductsResponse,
  ExportProductsData,
  ExportProductsError,
  ExportProductsResponse,
  GetProductData,
  GetProductError,
  GetProductResponse,
  UpdateProductData,
  UpdateProductError,
  UpdateProductResponse,
  DeleteProductData,
  DeleteProductError,
  DeleteProductResponse,
  AttachNodesData,
  AttachNodesError,
  AttachNodesResponse,
  DetachNodesData,
  DetachNodesError,
  DetachNodesResponse,
  GetProductsNodesData,
  GetProductsNodesError,
  GetProductsNodesResponse,
  BuildChildProductsData,
  BuildChildProductsError,
  BuildChildProductsResponse,
  GetChildProductsData,
  GetChildProductsError,
  GetChildProductsResponse,
  CreateProductTemplateRelationshipData,
  CreateProductTemplateRelationshipError,
  CreateProductTemplateRelationshipResponse,
  GetProductTemplateRelationshipsData,
  GetProductTemplateRelationshipsError,
  GetProductTemplateRelationshipsResponse,
  DeleteProductTemplateRelationshipData,
  DeleteProductTemplateRelationshipError,
  DeleteProductTemplateRelationshipResponse,
  GetProductComponentProductsRelationshipsData,
  GetProductComponentProductsRelationshipsError,
  GetProductComponentProductsRelationshipsResponse,
  GetProductFileRelationshipsData,
  GetProductFileRelationshipsError,
  GetProductFileRelationshipsResponse,
  CreateProductFileRelationshipsData,
  CreateProductFileRelationshipsError,
  CreateProductFileRelationshipsResponse,
  UpdateProductFileRelationshipsData,
  UpdateProductFileRelationshipsError,
  UpdateProductFileRelationshipsResponse,
  DeleteProductFileRelationshipsData,
  DeleteProductFileRelationshipsError,
  DeleteProductFileRelationshipsResponse,
  CreateProductVariationRelationshipsData,
  CreateProductVariationRelationshipsError,
  CreateProductVariationRelationshipsResponse,
  GetProductVariationRelationshipsData,
  GetProductVariationRelationshipsError,
  GetProductVariationRelationshipsResponse,
  UpdateProductVariationRelationshipsData,
  UpdateProductVariationRelationshipsError,
  UpdateProductVariationRelationshipsResponse,
  DeleteProductVariationRelationshipsData,
  DeleteProductVariationRelationshipsError,
  DeleteProductVariationRelationshipsResponse,
  CreateProductMainImageRelationshipsData,
  CreateProductMainImageRelationshipsError,
  CreateProductMainImageRelationshipsResponse,
  GetProductMainImageRelationshipsData,
  GetProductMainImageRelationshipsError,
  GetProductMainImageRelationshipsResponse,
  UpdateProductMainImageRelationshipsData,
  UpdateProductMainImageRelationshipsError,
  UpdateProductMainImageRelationshipsResponse,
  DeleteProductMainImageRelationshipsData,
  DeleteProductMainImageRelationshipsError,
  DeleteProductMainImageRelationshipsResponse,
  CreateVariationData,
  CreateVariationError,
  CreateVariationResponse,
  GetAllVariationsData,
  GetAllVariationsError,
  GetAllVariationsResponse,
  GetVariationData,
  GetVariationError,
  GetVariationResponse,
  UpdateVariationData,
  UpdateVariationError,
  UpdateVariationResponse,
  DeleteVariationData,
  DeleteVariationError,
  DeleteVariationResponse,
  CreateVariationOptionData,
  CreateVariationOptionError,
  CreateVariationOptionResponse,
  GetAllVariationOptionsData,
  GetAllVariationOptionsError,
  GetAllVariationOptionsResponse,
  GetVariationOptionData,
  GetVariationOptionError,
  GetVariationOptionResponse,
  UpdateVariationOptionData,
  UpdateVariationOptionError,
  UpdateVariationOptionResponse,
  DeleteVariationOptionData,
  DeleteVariationOptionError,
  DeleteVariationOptionResponse,
  CreateModifierData,
  CreateModifierError,
  CreateModifierResponse,
  GetAllModifiersData,
  GetAllModifiersError,
  GetAllModifiersResponse,
  GetModifierData,
  GetModifierError,
  GetModifierResponse,
  UpdateModifierData,
  UpdateModifierError,
  UpdateModifierResponse,
  DeleteModifierData,
  DeleteModifierError,
  DeleteModifierResponse,
  CreateHierarchyData,
  CreateHierarchyError,
  CreateHierarchyResponse,
  GetHierarchyData,
  GetHierarchyError,
  GetHierarchyResponse,
  GetHierarchyChildData,
  GetHierarchyChildError,
  GetHierarchyChildResponse,
  UpdateHierarchyData,
  UpdateHierarchyError,
  UpdateHierarchyResponse,
  DeleteHierarchyData,
  DeleteHierarchyError,
  DeleteHierarchyResponse,
  CreateNodeData,
  CreateNodeError,
  CreateNodeResponse,
  GetAllNodesInHierarchyData,
  GetAllNodesInHierarchyError,
  GetAllNodesInHierarchyResponse,
  GetHierarchyNodeData,
  GetHierarchyNodeError,
  GetHierarchyNodeResponse,
  UpdateNodeData,
  UpdateNodeError,
  UpdateNodeResponse,
  DeleteNodeData,
  DeleteNodeError,
  DeleteNodeResponse,
  GetAllChildrenData,
  GetAllChildrenError,
  GetAllChildrenResponse,
  CreateNodeChildRelationshipsData,
  CreateNodeChildRelationshipsError,
  CreateNodeChildRelationshipsResponse,
  GetAllNodeChildrenData,
  GetAllNodeChildrenError,
  GetAllNodeChildrenResponse,
  UpdateNodeParentData,
  UpdateNodeParentError,
  UpdateNodeParentResponse,
  DeleteNodeParentData,
  DeleteNodeParentError,
  DeleteNodeParentResponse,
  CreateNodeProductRelationshipData,
  CreateNodeProductRelationshipError,
  CreateNodeProductRelationshipResponse,
  DeleteNodeProductRelationshipsData,
  DeleteNodeProductRelationshipsError,
  DeleteNodeProductRelationshipsResponse,
  GetNodeProductsData,
  GetNodeProductsError,
  GetNodeProductsResponse,
  DuplicateHierarchyData,
  DuplicateHierarchyError,
  DuplicateHierarchyResponse,
  GetAllProductTagsError,
  GetAllProductTagsResponse,
  GetProductTagData,
  GetProductTagError,
  GetProductTagResponse,
  CreateCustomRelationshipData,
  CreateCustomRelationshipError,
  CreateCustomRelationshipResponse,
  UpdateCustomRelationshipData,
  UpdateCustomRelationshipError,
  UpdateCustomRelationshipResponse,
} from "./types.gen"

export const client = createClient(createConfig())

/**
 * Get All Jobs
 * The jobs endpoints displays the status of a number of endpoints that function as jobs, for example, product import and export, price book import, building child products, and duplicating hierarchies.
 */
export const getAllJobs = <ThrowOnError extends boolean = false>(
  options?: OptionsLegacyParser<unknown, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllJobsResponse,
    GetAllJobsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/jobs",
  })
}

/**
 * Get a Job
 */
export const getJob = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetJobData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetJobResponse,
    GetJobError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/jobs/{jobID}",
  })
}

/**
 * Cancel a Job
 * The jobs endpoints display the status of a number of endpoints that function as jobs, for example, product import and export, and duplicating hierarchies.
 *
 * Jobs are processed one at a time. You can continue to send job requests, but those jobs are queued. In other words, Commerce looks for any jobs that have a status of PENDING and starts the job with the earliest created date. If you decide that a specific job needs to be prioritized over another, you can cancel the less critical job using the `Cancel a job` endpoint. You can only cancel jobs whose status is PENDING.
 *
 */
export const cancelJob = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<CancelJobData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CancelJobResponse,
    CancelJobError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/jobs/{jobID}/cancel",
  })
}

/**
 * Get Job Errors
 */
export const getJobErrors = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetJobErrorsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetJobErrorsResponse,
    GetJobErrorsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/jobs/{jobID}/errors",
  })
}

/**
 * Create a product or bundle
 * Creates a product or bundle with the attributes that are defined in the body.
 *
 * #### Product Types
 *
 * Commerce automatically assigns types to the products you create. In Commerce Manager, you can see at a glance the product types in a list of a products. In addition, you can filter on product types in both the API and Commerce Manager.
 *
 * Product types can also be used in catalogs. For example, in your catalog, you can filter on `parent` so that only your parent products are displayed in your storefront.
 *
 * See [**Product Types**](/docs/api/pxm/products/products#product-types).
 *
 * #### Product Tags
 *
 * You can use product tags to store or assign a key word against a product or service that you sell in your store. The product tag can then be used to describe or label that product. Product tags represent similarities between products who do not share the same attributes. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on.
 *
 * See [**Product Tags**](/docs/api/pxm/products/product-tags).
 *
 * #### Personalizing products
 *
 * You can allow your shoppers to add custom text to a product when adding product items to their carts. This is useful, for example, if you have a product like a T-shirt that can be personalized or you sell greetings cards that can be printed with your shoppers personalized messages. You can do this by configuring the the `custom_inputs` attribute.
 *
 * When configuring the `custom_inputs` attribute:
 *
 * - You can rename `input` to something more representative of the input that shoppers are adding, for example, `message` or `front`.
 * - `name` is the name that is displayed in your storefront.
 * - You can add validation rules. For example, the input field must be a `string` and/or up to 255 characters in length. The limit is 255 characters.
 * - You can specify if the input field is required.
 *
 * #### Curating Products
 *
 * You can curate the products in a node. Product curation allows you to promote specific products within each node of your hierarchies, enabling you to create unique product collections in your storefront. For example, you may find you have an abundance of cotton T-Shirts and you want to promote these products to the top of the product list. When a shopper navigates to T-shirts, the cotton T-Shirts are displayed first. See [**Update a node**](/docs/api/pxm/products/update-node).
 *
 * #### Bundles
 *
 * With Product Experience Manager, you can use the products API to create and manage bundles. A bundle is a purchasable product, comprising of one or more products that you want to sell together.
 *
 * See [**Bundles**](/docs/api/pxm/products/products#bundles).
 *
 */
export const createProduct = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<CreateProductData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateProductResponse,
    CreateProductError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products",
  })
}

/**
 * Get all products
 * Retrieves a list of all your products in the Product Experience Manager system.
 *
 * You can also use `include` to retrieve top-level resources, such as files or images, and key attribute data, such as SKU or slug for component products in a product bundle. With this option, you can get more information about the products in a product bundle in your store front, improving the buying experience for your shoppers.
 *
 * #### Filtering
 *
 * Many Commerce API endpoints support filtering. The general syntax is described in [**Filtering**](/docs/commerce-cloud/api-overview/filtering).
 *
 * The following attributes and operators are supported.
 *
 * | Operator | Attribute                                                                                       | Description                                                                                                                                                                                                           | Example                         |
 * | :--- |:------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------|
 * | `eq` | `sku`, `slug`,`upc_ean`, `mpn`, `name`, `templates`, `commodity_type`, `owner`, `product_types`, `tags` | Equals. Checks if the values of two operands are equal. If they are, the condition is true. For `product_types`, you can only specify one product type. For example, `filter=eq(product_types,child)`                 | `filter=eq(name,some-name)`     |
 * | `like` | `sku`, `slug`,`upc_ean`, `mpn`, `name`, `tags`                                                          | Like. Checks if the operand contains the specified string. Wildcards are supported.                                                                                                                                   | `filter=like(name,*some-name*)` |
 * | `In` | `id`, `name`, `SKU`, `slug`, `upc_ean`, `mpn`, `product_types`, `tags`                                | Checks if the values are included in the specified string. If they are, the condition is true. For `product_types`, you can specify more than one product type. For example, `filter=in(product_types,child,bundle)`. | `filter=in(id,some-id)`         |
 *
 */
export const getAllProducts = <ThrowOnError extends boolean = false>(
  options?: OptionsLegacyParser<GetAllProductsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllProductsResponse,
    GetAllProductsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products",
  })
}

/**
 * Import Products
 *
 * You can use the Product Import API to:
 *
 * - Add new products, including:
 *
 * - main image files. See [Importing Main Image Files](/docs/api/pxm/products/product-import-bulk-update#using-imported-main-image-files).
 * - custom data. See [Importing custom data](/docs/api/pxm/products/product-import-bulk-update#importing-custom-data-flows).
 * - Make bulk updates to existing products.
 *
 * You cannot use product import to:
 *
 * - Delete existing products.
 * - Import product bundles.
 *
 * The Product Import API uses a Comma Separated Values (CSV) file to import products, main image files and custom extension data. Each row in a .csv file represents a product you want to create/update.
 *
 * Each file can have 50,000 rows, including the header. If a CSV file exceeds 50,000 rows, an error is displayed, and the products are not imported. A CSV file must not be larger than 50 megabytes. If a CSV file is larger than 50 megabytes, a `503 client read` error is displayed.
 *
 * If you want to create/update more than 50,000 products or your CSV file is larger than 50 megabytes, you must have a separate CSV file and import each CSV file one at a time.
 *
 * See [**Characteristics of CSV Files**](/docs/api/pxm/products/product-import-bulk-update#characteristics-of-csv-import-files).
 *
 */
export const importProducts = <ThrowOnError extends boolean = false>(
  options?: OptionsLegacyParser<ImportProductsData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    ImportProductsResponse,
    ImportProductsError,
    ThrowOnError
  >({
    ...options,
    ...formDataBodySerializer,
    headers: {
      "Content-Type": null,
      ...options?.headers,
    },
    url: "/pcm/products/import",
  })
}

/**
 * Export Products
 *
 * The Export API is available to make bulk updates to products in Product Experience Manager. You might also export products for your personal requirements.
 *
 * The Export API builds a CSV file containing the product entries. A CSV file can contain up to 50,000 product entries. If you have more than 50,000 product entries, then another CSV file is created and so on, until all your products are exported.
 *
 * The Job endpoint response specifies the location where the CSV file is stored. See [Characteristics of CSV Files](/docs/api/pxm/products/product-export#characteristics-of-exporting-products).
 *
 * ### Filtering
 *
 * The following attributes and operators are supported.
 *
 * | Operator | Attribute                                              | Description                                                                                                                                                    | Example |
 * | :--- |:-------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------| :--- |
 * | `eq` | `sku`, `slug`, `upc_ean`, `mpn`, `name`, `description`, `tags`  | Equals. Checks if the values of two operands are equal. If they are, the condition is true. When filtering on tags, you can only specify one product tag.      | `filter=eq(name,some-name)` |
 * | `In` | `sku`, `tags`                                                | Checks if the values are included in the specified string. If they are, the condition is true. When filtering on tags, you can specify a list of product tags. | `filter=in(id,some-id)` |
 * | `like` | `sku`, `slug`, `upc_ean`, `mpn`, `name`, `description` | Like. Checks if the operand contains the specified string. Wildcards are supported.  | `filter=like(name,some-name)` |
 *
 */
export const exportProducts = <ThrowOnError extends boolean = false>(
  options?: OptionsLegacyParser<ExportProductsData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    ExportProductsResponse,
    ExportProductsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/export",
  })
}

/**
 * Get a product
 * Returns a product by its identifier.
 *
 * You can also use `include=component_products` to retrieve top-level resources, such as files or images, and key attribute data, such as SKU or slug for component products in a product bundle. With this option, you can get more information about the products in a product bundle in your store front, improving the buying experience for your shoppers.
 *
 */
export const getProduct = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetProductData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetProductResponse,
    GetProductError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}",
  })
}

/**
 * Update a product or bundle
 * Specify whichever attributes you want to change. The values of the other attributes remain the same. If the attributes section is empty, the product or bundle is not updated.
 */
export const updateProduct = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<UpdateProductData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateProductResponse,
    UpdateProductError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}",
  })
}

/**
 * Delete a product
 * Deletes the specified product.
 *
 * You cannot delete a product if it is part of a bundle. You must first delete the bundle before you delete the product.
 *
 */
export const deleteProduct = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<DeleteProductData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteProductResponse,
    DeleteProductError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}",
  })
}

/**
 * Attach multiple nodes
 * Assigns products to multiple hierarchies and their children nodes. You can apply a filter to search for the appropriate products to attach to a node. For general filtering syntax, see [**Filtering**](/docs/commerce-cloud/api-overview/filtering).
 *
 * The following attributes and operators are supported.
 *
 * | Operator | Attribute                                                                                       | Description                                                                                                                                                                                                           | Example                         |
 * | :--- |:------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------|
 * | `eq` | `sku`, `slug`,`upc_ean`, `mpn`, `name`, `templates`, `commodity_type`, `owner`, `product_types` | Equals. Checks if the values of two operands are equal. If they are, the condition is true. For `product_types`, you can only specify one product type. For example, `filter=eq(product_types,child)`                 | `filter=eq(name,some-name)`     |
 * | `like` | `sku`, `slug`,`upc_ean`, `mpn`, `name`                                                          | Like. Checks if the operand contains the specified string. Wildcards are supported.                                                                                                                                   | `filter=like(name,*some-name*)` |
 * | `In` | `id`, `name`, `SKU`, `slug`, `upc_ean`, `mpn`, `product_types`                                  | Checks if the values are included in the specified string. If they are, the condition is true. For `product_types`, you can specify more than one product type. For example, `filter=in(product_types,child,bundle)`. | `filter=in(id,some-id)`         |
 *
 *
 */
export const attachNodes = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<AttachNodesData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    AttachNodesResponse,
    AttachNodesError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/attach_nodes",
  })
}

/**
 * Detach multiple nodes
 * Dissociates products from multiple hierarchies and their children nodes. You can apply filters to search for the appropriate products to detach. For general filtering syntax, see [**Filtering**](/docs/commerce-cloud/api-overview/filtering).
 *
 * The following attributes and operators are supported.
 *
 * | Operator | Attribute                                                                                       | Description                                                                                                                                                                                                           | Example                         |
 * | :--- |:------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------|
 * | `eq` | `sku`, `slug`,`upc_ean`, `mpn`, `name`, `templates`, `commodity_type`, `owner`, `product_types` | Equals. Checks if the values of two operands are equal. If they are, the condition is true. For `product_types`, you can only specify one product type. For example, `filter=eq(product_types,child)`                 | `filter=eq(name,some-name)`     |
 * | `like` | `sku`, `slug`,`upc_ean`, `mpn`, `name`                                                          | Like. Checks if the operand contains the specified string. Wildcards are supported.                                                                                                                                   | `filter=like(name,*some-name*)` |
 * | `In` | `id`, `name`, `SKU`, `slug`, `upc_ean`, `mpn`, `product_types`                                  | Checks if the values are included in the specified string. If they are, the condition is true. For `product_types`, you can specify more than one product type. For example, `filter=in(product_types,child,bundle)`. | `filter=in(id,some-id)`         |
 *
 */
export const detachNodes = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<DetachNodesData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    DetachNodesResponse,
    DetachNodesError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/detach_nodes",
  })
}

/**
 * Get a product's nodes
 * Returns the nodes associated with the product. Products must be in a `live` status.
 */
export const getProductsNodes = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetProductsNodesData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetProductsNodesResponse,
    GetProductsNodesError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/nodes",
  })
}

/**
 * Build child products
 * With product variations in Product Experience Manager, you can create product variations and different options for each variation and use both to create child products for a product. Each child product is a unique combination of options associated with the product.
 *
 * Child products inherit attributes from their parent products. When you make changes to the attributes of the parent products, you can rebuild your child products, ensuring that changes to the parent products are propagated to the child products.
 *
 * Alternatively, you can modify a child product independently, without impacting its parent product. For example, you may prefer the status of your child product to be `live`, while keeping the parent product's status as `draft`. When you directly update a child product, it becomes independent of its parent product. In other words, any subsequent changes made to the parent product are not automatically reflected in the child product when you rebuild the parent product and its child products. Once a child product is independent of its parent, you cannot recreate the association between the child product and its parent. You must delete the child product and rebuild the parent to recreate the child product.
 *
 * Following on from that, if you add the same flow to both a parent and child product, the child flow values are not affected by changes to the parent flow values in a rebuild.
 *
 * ### Using Build Rules
 *
 * When building your child products, you can build all products related to a product.
 *
 * Alternatively, you can build a combination of child products associated with a product, based on build rules that you specify. This is useful, for example, if you have a variation option that you do not sell. This makes managing and building your child products quick and easy. You can do this using `build_rules`. `build_rules` are combinations of variation option IDs that you wish to include or exclude when building your child products.
 *
 * :::note
 *
 * You do not need to configure any `build_rules` in the following scenarios:
 *
 * - Child products must be built with all variation options. Simply, use the `Create a product` or `Update a product` endpoints with no `build_rules` specified.
 * - Child products must be built apart from all options for a specific variation. In this case, you must remove the variation and use the `Create a product` or `Update a product` endpoints with no `build_rules` specified. In other words, using our example, if none of the `size` options should be included, then remove the `size` variation.
 *
 * :::
 *
 * The `build_rules` contain:
 *
 * - (Required) `default`: specifies the default behavior.
 * - (Optional) `include`: specifies the option IDs to include when the child products are built. Each combination consists of a nested array of option IDs from one or more variations. Combinations of option IDs in the nested arrays must come from different variations. See [**Invalid Build Rules**](#invalid-build-rules).
 * - (Optional) `exclude`: specifies the option IDs to exclude when the child products are built. Each combination consists of a nested array of option IDs from one or more variations. Combinations of option IDs in the nested arrays must come from different variations. See [**Invalid build rules**](#invalid-build-rules).
 *
 * When building child products, Commerce compares each combination of option IDs to these rules to determine how your child products should be built, depending on how you have configured the `build_rules`. It depends on your requirements how you configure your `build_rules`.
 *
 * #### Invalid Build Rules
 *
 * The `build_rules` are invalid if both the option IDs come from the same variation. Combinations of option IDs in the nested arrays must come from different variations.
 *
 * If Commerce cannot resolve the `build_rules` a `could not determine whether to include or exclude a child product due to ambiguous rules` error is returned. This error can occur, for example, if you have the same number of variation option IDs in both the `include` and `exclude` arrays and the variation option IDs match.
 *
 * ### Building Child Products
 *
 * Building child products is an asynchronous operation. When you build child products, a job is created. The jobId of the job is displayed in the response. When the job is complete, the build child products operation is also complete. You can use the jobId to see the status of your job using the `Get a Job` endpoint.
 *
 * Jobs are processed one at a time. You can continue to send build child product requests, but those jobs are queued. In other words, Commerce looks for any jobs that have a status of PENDING and starts the job with the earliest created date. This process is repeated until all jobs are processed. See Jobs.
 *
 * Re-building child products after adding or removing a new variation changes the total number of child products that you can generate from a parent product. When you rebuild the child products after updating variations associated with the parent product, all existing child products that belong to a parent product are deleted. New child products are created with new product IDs.
 *
 * If you have any bundles that reference child products directly, then you must update the bundles with the new child product IDs.
 *
 * However, re-building child products after adding or removing an option does not change the existing product IDs.
 *
 */
export const buildChildProducts = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<BuildChildProductsData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    BuildChildProductsResponse,
    BuildChildProductsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/build",
  })
}

/**
 * Get child products
 */
export const getChildProducts = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetChildProductsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetChildProductsResponse,
    GetChildProductsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/children",
  })
}

/**
 * Create a product template relationship
 * Retrieves all the templates that are associated with the specified product.
 */
export const createProductTemplateRelationship = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    CreateProductTemplateRelationshipData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).post<
    CreateProductTemplateRelationshipResponse,
    CreateProductTemplateRelationshipError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/templates",
  })
}

/**
 * Get all product template relationships
 */
export const getProductTemplateRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    GetProductTemplateRelationshipsData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).get<
    GetProductTemplateRelationshipsResponse,
    GetProductTemplateRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/templates",
  })
}

/**
 * Delete a product template relationship
 */
export const deleteProductTemplateRelationship = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    DeleteProductTemplateRelationshipData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).delete<
    DeleteProductTemplateRelationshipResponse,
    DeleteProductTemplateRelationshipError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/templates",
  })
}

/**
 * Get Bundle Component Product Relationships
 * Retrieves all the products included in the specified bundle product.
 */
export const getProductComponentProductsRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    GetProductComponentProductsRelationshipsData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).get<
    GetProductComponentProductsRelationshipsResponse,
    GetProductComponentProductsRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/component_products",
  })
}

/**
 * Get all product file relationships
 * Retrieves all files that are associated with the specified product.
 */
export const getProductFileRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<GetProductFileRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetProductFileRelationshipsResponse,
    GetProductFileRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/files",
  })
}

/**
 * Create a product file relationship
 */
export const createProductFileRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    CreateProductFileRelationshipsData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).post<
    CreateProductFileRelationshipsResponse,
    CreateProductFileRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/files",
  })
}

/**
 * Replace a product file relationship
 */
export const updateProductFileRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    UpdateProductFileRelationshipsData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).put<
    UpdateProductFileRelationshipsResponse,
    UpdateProductFileRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/files",
  })
}

/**
 * Delete a product file relationships
 */
export const deleteProductFileRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    DeleteProductFileRelationshipsData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).delete<
    DeleteProductFileRelationshipsResponse,
    DeleteProductFileRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/files",
  })
}

/**
 * Create a product variation relationship
 */
export const createProductVariationRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    CreateProductVariationRelationshipsData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).post<
    CreateProductVariationRelationshipsResponse,
    CreateProductVariationRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/variations",
  })
}

/**
 * Get all product variation relationships
 */
export const getProductVariationRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    GetProductVariationRelationshipsData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).get<
    GetProductVariationRelationshipsResponse,
    GetProductVariationRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/variations",
  })
}

/**
 * Replace a product variation relationship
 */
export const updateProductVariationRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    UpdateProductVariationRelationshipsData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).put<
    UpdateProductVariationRelationshipsResponse,
    UpdateProductVariationRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/variations",
  })
}

/**
 * Delete a product variation relationships
 */
export const deleteProductVariationRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    DeleteProductVariationRelationshipsData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).delete<
    DeleteProductVariationRelationshipsResponse,
    DeleteProductVariationRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/variations",
  })
}

/**
 * Create main image relationships
 * Associates a main image with the specified product.
 */
export const createProductMainImageRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    CreateProductMainImageRelationshipsData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).post<
    CreateProductMainImageRelationshipsResponse,
    CreateProductMainImageRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/main_image",
  })
}

/**
 * Get Main Image Relationships
 */
export const getProductMainImageRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    GetProductMainImageRelationshipsData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).get<
    GetProductMainImageRelationshipsResponse,
    GetProductMainImageRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/main_image",
  })
}

/**
 * Replace Main Image Relationships
 */
export const updateProductMainImageRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    UpdateProductMainImageRelationshipsData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).put<
    UpdateProductMainImageRelationshipsResponse,
    UpdateProductMainImageRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/main_image",
  })
}

/**
 * Delete Main Image Relationships
 */
export const deleteProductMainImageRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    DeleteProductMainImageRelationshipsData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).delete<
    DeleteProductMainImageRelationshipsResponse,
    DeleteProductMainImageRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/products/{productID}/relationships/main_image",
  })
}

/**
 * Create a variation
 */
export const createVariation = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<CreateVariationData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateVariationResponse,
    CreateVariationError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/variations",
  })
}

/**
 * Get all variations
 */
export const getAllVariations = <ThrowOnError extends boolean = false>(
  options?: OptionsLegacyParser<GetAllVariationsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllVariationsResponse,
    GetAllVariationsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/variations",
  })
}

/**
 * Get a variation
 */
export const getVariation = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetVariationData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetVariationResponse,
    GetVariationError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/variations/{variationID}",
  })
}

/**
 * Update a variation
 * Specify whichever attributes you want to change. The values of the other attributes remain the same. If the attributes section is empty, the variation is not updated.
 */
export const updateVariation = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<UpdateVariationData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateVariationResponse,
    UpdateVariationError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/variations/{variationID}",
  })
}

/**
 * Delete a variation and all it's associated options
 */
export const deleteVariation = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<DeleteVariationData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteVariationResponse,
    DeleteVariationError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/variations/{variationID}",
  })
}

/**
 * Create a variation option
 */
export const createVariationOption = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<CreateVariationOptionData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateVariationOptionResponse,
    CreateVariationOptionError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/variations/{variationID}/options",
  })
}

/**
 * Get all variation options
 */
export const getAllVariationOptions = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetAllVariationOptionsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllVariationOptionsResponse,
    GetAllVariationOptionsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/variations/{variationID}/options",
  })
}

/**
 * Get a variation option
 */
export const getVariationOption = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetVariationOptionData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetVariationOptionResponse,
    GetVariationOptionError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/variations/{variationID}/options/{optionID}",
  })
}

/**
 * Update a variation option
 */
export const updateVariationOption = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<UpdateVariationOptionData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateVariationOptionResponse,
    UpdateVariationOptionError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/variations/{variationID}/options/{optionID}",
  })
}

/**
 * Delete a variation option
 */
export const deleteVariationOption = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<DeleteVariationOptionData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteVariationOptionResponse,
    DeleteVariationOptionError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/variations/{variationID}/options/{optionID}",
  })
}

/**
 * Create a modifier
 */
export const createModifier = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<CreateModifierData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateModifierResponse,
    CreateModifierError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/variations/{variationID}/options/{optionID}/modifiers",
  })
}

/**
 * Get all modifiers
 */
export const getAllModifiers = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetAllModifiersData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllModifiersResponse,
    GetAllModifiersError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/variations/{variationID}/options/{optionID}/modifiers",
  })
}

/**
 * Get a modifier
 */
export const getModifier = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetModifierData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetModifierResponse,
    GetModifierError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/variations/{variationID}/options/{optionID}/modifiers/{modifierID}",
  })
}

/**
 * Update a modifier
 * Specify whichever attributes you want to change. The values of the other attributes remain the same. If the attributes section is empty, the modifier is not updated.
 */
export const updateModifier = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<UpdateModifierData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateModifierResponse,
    UpdateModifierError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/variations/{variationID}/options/{optionID}/modifiers/{modifierID}",
  })
}

/**
 * Delete a modifier
 * You cannot delete a modifier if it is in use. Deleting a modifier in us returns a `422 Failed Validation` error.
 */
export const deleteModifier = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<DeleteModifierData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteModifierResponse,
    DeleteModifierError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/variations/{variationID}/options/{optionID}/modifiers/{modifierID}",
  })
}

/**
 * Create a hierarchy
 * Create a hierarchy
 */
export const createHierarchy = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<CreateHierarchyData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateHierarchyResponse,
    CreateHierarchyError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies",
  })
}

/**
 * Get all hierarchies
 * Get all hierarchies
 */
export const getHierarchy = <ThrowOnError extends boolean = false>(
  options?: OptionsLegacyParser<GetHierarchyData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetHierarchyResponse,
    GetHierarchyError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies",
  })
}

/**
 * Get a hierarchy
 * Retrieves the specified hierarchy.
 */
export const getHierarchyChild = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetHierarchyChildData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetHierarchyChildResponse,
    GetHierarchyChildError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}",
  })
}

/**
 * Update a hierarchy
 * Specify whichever attributes you want to change. The values of the other attributes remain the same. If the attributes section is empty, the hierarchy is not updated.
 */
export const updateHierarchy = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<UpdateHierarchyData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateHierarchyResponse,
    UpdateHierarchyError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}",
  })
}

/**
 * Delete a hierarchy
 * Deletes the specified hierarchy and all its children.
 */
export const deleteHierarchy = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<DeleteHierarchyData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteHierarchyResponse,
    DeleteHierarchyError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}",
  })
}

/**
 * Create a node
 * Creates a node in the specified hierarchy.
 *
 * ### Sorting Nodes in a Hierarchy
 *
 * You can sort the order of your nodes, regardless of where the nodes are in the hierarchy.
 *
 * You can do this by adding a `meta` object to the body of your request and specifying a `sort_order` value.
 *
 * The node with the highest value of `sort_order` is displayed first. For example, a node with a `sort_order` value of `3` appears before a node with a `sort_order` value of `2`.
 *
 * - If you don’t provide `sort_order` when creating nodes, all child nodes in the response for Get a Node’s Children request are ordered by the `updated_at` time in descending order, with the most recently updated child node first.
 * - If you set `sort_order` for only a few child nodes, the child nodes with a `sort_order` value appear first and then other child nodes appear in the order of `updated_at` time.
 *
 * You can also specify a `sort_order` when creating a node relationship.
 *
 * - If you create a node (**Node A**) with a `sort_order` and then you create a relationship for **Node A** with another node (**Node B**), the `sort_order` you specified when creating **Node A** is overwritten.
 * - If you create **Node A** and then you create a relationship with **Node B** but do not configure a `sort_order`, the `sort_order` you specified when you created **Node A** is not overwritten.
 *
 * ### Curating Products in a node
 *
 * You can curate the products in a node. Product curation allows you to promote specific products within each node of your hierarchies, enabling you to create unique product collections in your storefront. For example, you may find you have an abundance of cotton T-Shirts and you want to promote these products to the top of the product list. When a shopper navigates to T-shirts, the cotton T-Shirts are displayed first.
 *
 * You can do this by adding a `curated_products` attribute to the body of your request and adding an array of product IDs to the attribute. You should add the products IDs in the order you want them to be displayed in your node. The first product ID is displayed first in the product list.
 *
 * You can only curate 20 products or less. You cannot have more than 20 curated products.
 *
 * - The product IDs you provide must exist in the specified node.
 * - If a curated product is removed from a node, the product is also removed from the curated_products list.
 * - Once you have curated the products in a node, you can use the get node products endpoint to retrieve a list of curated products.
 *
 * You can then display your curated products in your catalogs using the following catalog endpoints.
 *
 * - Get a node in your latest catalog release.
 * - Get a node in a catalog.
 * - Get all nodes in your latest catalog release.
 * - Get all nodes in a catalog.
 * - Get node children in your latest catalog release.
 * - Get node children in a catalog.
 *
 */
export const createNode = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<CreateNodeData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateNodeResponse,
    CreateNodeError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}/nodes",
  })
}

/**
 * Get all nodes in a hierarchy
 * A fully paginated view of all nodes in a hierarchy regardless of depth.
 */
export const getAllNodesInHierarchy = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetAllNodesInHierarchyData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllNodesInHierarchyResponse,
    GetAllNodesInHierarchyError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}/nodes",
  })
}

/**
 * Get a node
 * Retrieves a node from a hierarchy.
 */
export const getHierarchyNode = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetHierarchyNodeData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetHierarchyNodeResponse,
    GetHierarchyNodeError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}",
  })
}

/**
 * Update a node
 * Updates the specified node in a hierarchy. You can do a partial update, where you specify only the field value to change.
 *
 * ### Sorting Nodes in a hierarchy
 *
 * You can sort the order of your nodes, regardless of where the nodes are in the hierarchy.
 *
 * The node with the highest value of sort_order is displayed first. For example, a node with a `sort_order` value of `3` appears before a node with a `sort_order` value of `2`.
 *
 * - If you don’t provide `sort_order` when creating nodes, all child nodes in the response for Get a Node’s Children request are ordered by the `updated_at` time in descending order, with the most recently updated child node first.
 * - If you set `sort_order` for only a few child nodes or not all, the child nodes with a `sort_order` value appear first and then other child nodes appear in the order of `updated_at` time.
 *
 * You can also specify a sort_order when creating a node relationship.
 *
 * - If you update a node (**Node A**) with a `sort_order` and then you create a relationship for **Node A** with another node (**Node B**), the `sort_order` you specified when updating **Node A** is overwritten.
 * - If you have updated **Node A** and then you create a relationship with **Node B** but do not configure a `sort_order`, the `sort_order` you specified when you updated **Node A** is not overwritten.
 *
 * ### Curating Products in a node
 *
 * You can curate the products in a node. Product curation allows you to promote specific products within each node of your hierarchies, enabling you to create unique product collections in your storefront. For example, you may find you have an abundance of cotton T-Shirts and you want to promote these products to the top of the product list. When a shopper navigates to T-shirts, the cotton T-Shirts are displayed first.
 *
 * You can do this by adding a `curated_products` attribute to the body of your request and adding an array of product IDs to the attribute. You should add the products IDs in the order you want them to be displayed in your node. The first product ID is displayed first in the product list.
 *
 * You can only curate 20 products or less. You cannot have more than 20 curated products.
 *
 * - The product IDs you provide must exist in the specified node.
 * - If a curated product is removed from a node, the product is also removed from the curated_products list.
 * - Once you have curated the products in a node, you can use the get node products endpoint to retrieve a list of curated products.
 *
 * You can then display your curated products in your catalogs using the following catalog endpoints.
 *
 * - Get a node in your latest catalog release.
 * - Get a node in a catalog.
 * - Get all nodes in your latest catalog release.
 * - Get all nodes in a catalog.
 * - Get node children in your latest catalog release.
 * - Get node children in a catalog.
 *
 */
export const updateNode = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<UpdateNodeData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateNodeResponse,
    UpdateNodeError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}",
  })
}

/**
 * Deletes a node
 * Deletes a node by the node ID
 */
export const deleteNode = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<DeleteNodeData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteNodeResponse,
    DeleteNodeError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}",
  })
}

/**
 * Get a hierarchy's children
 * Get a hierarchy's children
 */
export const getAllChildren = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetAllChildrenData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllChildrenResponse,
    GetAllChildrenError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}/children",
  })
}

/**
 * Create relationships between a node and child nodes
 * Use this endpoint to create relationships between a single parent node and one or more child nodes. You can create a relationship only if:
 *
 * - The parent node already exists.
 * - All child nodes already exist.
 * - Every child node in the body of the request exists in the same hierarchy as the parent node.
 * - A node is not a parent of itself. An array of child nodes request body must not contain the ID of the parent node in the path.
 * - All siblings in a hierarchy must have a unique `slug`. Siblings are the child nodes that are related to the same parent.
 *
 * ### Sort Order
 *
 * You can also provide `sort_order` information when you create a relationship by adding a `meta` object to the array of node reference objects for each child node that requires sorting.
 *
 * The node with the highest value of `sort_order` appears at the top of the response. For example, a node with a `sort_order` value of `3` appears before a node with a `sort_order` value of `2`.
 *
 * - If you don’t provide `sort_order` when creating relationships, all child nodes in the response for Get a Node’s Children request are ordered by the `updated_at` time in descending order. The most recently updated child node appears at the top of the response.
 * - If you set `sort_order` for only a few child nodes or not all, the child nodes with `sort_order` value appear first in the response and then other child nodes appear in the order of `updated_at` time.
 *
 * You can also specify a `sort_order` when creating and updating a node.
 *
 * - If you create or update a node (**Node A**) with a `sort_order` and then you create a relationship for **Node A** with another node (**Node B**), the `sort_order` you specified when creating\updating **Node A** is overwritten.
 * - If you create\update **Node A** and then you create a relationship with **Node B** but do not configure a `sort_order`, the `sort_order` you specified when you created\updated **Node A** is not overwritten.
 *
 */
export const createNodeChildRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<CreateNodeChildRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateNodeChildRelationshipsResponse,
    CreateNodeChildRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/relationships/children",
  })
}

/**
 * Get a node's children
 * Retrieves the child nodes for a specified node.
 */
export const getAllNodeChildren = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetAllNodeChildrenData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllNodeChildrenResponse,
    GetAllNodeChildrenError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/children",
  })
}

/**
 * Update a node's parent
 * Changes the parent of the specified node. The new parent node must be located within the same hierarchy as the specified node.
 *
 * You cannot move a node to another hierarchy. If you want to put the specified node into another hierarchy, create the node in the target hierarchy and delete it from the current hierarchy.
 *
 */
export const updateNodeParent = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<UpdateNodeParentData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateNodeParentResponse,
    UpdateNodeParentError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/relationships/parent",
  })
}

/**
 * Delete a node's parent
 */
export const deleteNodeParent = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<DeleteNodeParentData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteNodeParentResponse,
    DeleteNodeParentError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/relationships/parent",
  })
}

/**
 * Create a node's product relationships
 * Creates relationships between the specified node and one or more products in a specified hierarchy.
 */
export const createNodeProductRelationship = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<CreateNodeProductRelationshipData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateNodeProductRelationshipResponse,
    CreateNodeProductRelationshipError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/relationships/products",
  })
}

/**
 * Deletes a node's product relationships
 */
export const deleteNodeProductRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: OptionsLegacyParser<
    DeleteNodeProductRelationshipsData,
    ThrowOnError
  >,
) => {
  return (options?.client ?? client).delete<
    DeleteNodeProductRelationshipsResponse,
    DeleteNodeProductRelationshipsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/relationships/products",
  })
}

/**
 * Get a node's products
 * Returns the products associated with the specified hierarchy node from a published catalog. Products must be in a live status. If the products have been curated using the update a hierarchy node endpoint, then the products are returned in the order specified in the `curated_products` attribute in the body of the update a hierarchy node request. A product that is curated has the "curated_product": true attribute displayed.
 *
 */
export const getNodeProducts = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetNodeProductsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetNodeProductsResponse,
    GetNodeProductsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/products",
  })
}

/**
 * Duplicate a hierarchy
 * Using this option, you can duplicate an existing hierarchy. This is useful because it enables you to quickly and easily create multiple hierarchies with the same node structure.
 *
 * When you duplicate a hierarchy, you can specify a new name and/or a new description for the duplicated hierarchy. All other attributes, such as slug and locales, stay the same.
 *
 * Any nodes in the existing hierarchy are also replicated in the duplicated hierarchy. In addition, you can optionally use the `include_products` attribute to specify whether you want products associated with the nodes in an existing hierarchy to be associated with the nodes in the duplicated hierarchy. By default, product associations in an existing hierarchy are not duplicated in a duplicate hierarchy.
 *
 * Duplicating a hierarchy is an asynchronous operation. When you duplicate a hierarchy, a job is created. The jobId of the job is displayed in the response. When the job is complete, the duplicate hierarchy operation is also complete. You can use the jobId to see the status of your job using Get a Job.
 *
 * Jobs are processed one at a time. You can continue to send duplicate hierarchy requests, but those jobs are queued. In other words, Commerce looks for any jobs that have a status of PENDING and starts the job with the earliest created date. This process is repeated until all jobs are processed.
 *
 * Once the job is complete, run:
 *
 * - Get all hierarchies to retrieve the HierarchyId of your duplicated hierarchy.
 * - Get a hierarchy to retrieve the nodes and (if applicable) products associated with the duplicated hierarchy.
 *
 */
export const duplicateHierarchy = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<DuplicateHierarchyData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    DuplicateHierarchyResponse,
    DuplicateHierarchyError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/hierarchies/{hierarchyID}/duplicate_job",
  })
}

/**
 * Get All Product Tags
 * Retrieves all product tags for a store. A store can view the tags associated with the organization to which the store belongs. However, an organization can only view the tags associated with the organization.
 *
 *
 */
export const getAllProductTags = <ThrowOnError extends boolean = false>(
  options?: OptionsLegacyParser<unknown, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllProductTagsResponse,
    GetAllProductTagsError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/tags",
  })
}

/**
 * Get a Product Tag
 * Retrieves a product tag for a store. A store can view the tags associated with the organization to which the store belongs. However, an organization can only view the tags associated with the organization.
 */
export const getProductTag = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<GetProductTagData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetProductTagResponse,
    GetProductTagError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/tags/{tagID}",
  })
}

/**
 * Create a custom relationship
 * Create a custom relationship
 */
export const createCustomRelationship = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<CreateCustomRelationshipData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateCustomRelationshipResponse,
    CreateCustomRelationshipError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/custom_relationships",
  })
}

/**
 * Update a custom relationship
 * Specify whichever attributes you want to change. The values of the other attributes remain the same. If the attributes section is empty, the custom relationship is not updated.
 */
export const updateCustomRelationship = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<UpdateCustomRelationshipData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateCustomRelationshipResponse,
    UpdateCustomRelationshipError,
    ThrowOnError
  >({
    ...options,
    url: "/pcm/custom_relationships/{customRelationshipSlug}",
  })
}
