// This file is auto-generated by @hey-api/openapi-ts

import {
  createClient,
  createConfig,
  type Options,
  formDataBodySerializer,
} from "@hey-api/client-fetch"
import type {
  GetAllJobsData,
  GetAllJobsResponse,
  GetAllJobsError,
  GetJobData,
  GetJobResponse,
  GetJobError,
  CancelJobData,
  CancelJobResponse,
  CancelJobError,
  GetJobErrorsData,
  GetJobErrorsResponse,
  GetJobErrorsError,
  GetAllProductsData,
  GetAllProductsResponse,
  GetAllProductsError,
  CreateProductData,
  CreateProductResponse,
  CreateProductError,
  ImportProductsData,
  ImportProductsResponse,
  ImportProductsError,
  ExportProductsData,
  ExportProductsResponse,
  ExportProductsError,
  DeleteProductData,
  DeleteProductResponse,
  DeleteProductError,
  GetProductData,
  GetProductResponse,
  GetProductError,
  UpdateProductData,
  UpdateProductResponse,
  UpdateProductError,
  AttachNodesData,
  AttachNodesResponse,
  AttachNodesError,
  DetachNodesData,
  DetachNodesResponse,
  DetachNodesError,
  GetProductsNodesData,
  GetProductsNodesResponse,
  GetProductsNodesError,
  BuildChildProductsData,
  BuildChildProductsResponse,
  BuildChildProductsError,
  GetChildProductsData,
  GetChildProductsResponse,
  GetChildProductsError,
  DeleteProductTemplateRelationshipData,
  DeleteProductTemplateRelationshipResponse,
  DeleteProductTemplateRelationshipError,
  GetProductTemplateRelationshipsData,
  GetProductTemplateRelationshipsResponse,
  GetProductTemplateRelationshipsError,
  CreateProductTemplateRelationshipData,
  CreateProductTemplateRelationshipResponse,
  CreateProductTemplateRelationshipError,
  GetProductComponentProductsRelationshipsData,
  GetProductComponentProductsRelationshipsResponse,
  GetProductComponentProductsRelationshipsError,
  DeleteProductFileRelationshipsData,
  DeleteProductFileRelationshipsResponse,
  DeleteProductFileRelationshipsError,
  GetProductFileRelationshipsData,
  GetProductFileRelationshipsResponse,
  GetProductFileRelationshipsError,
  CreateProductFileRelationshipsData,
  CreateProductFileRelationshipsResponse,
  CreateProductFileRelationshipsError,
  UpdateProductFileRelationshipsData,
  UpdateProductFileRelationshipsResponse,
  UpdateProductFileRelationshipsError,
  DeleteProductVariationRelationshipsData,
  DeleteProductVariationRelationshipsResponse,
  DeleteProductVariationRelationshipsError,
  GetProductVariationRelationshipsData,
  GetProductVariationRelationshipsResponse,
  GetProductVariationRelationshipsError,
  CreateProductVariationRelationshipsData,
  CreateProductVariationRelationshipsResponse,
  CreateProductVariationRelationshipsError,
  UpdateProductVariationRelationshipsData,
  UpdateProductVariationRelationshipsResponse,
  UpdateProductVariationRelationshipsError,
  DeleteProductMainImageRelationshipsData,
  DeleteProductMainImageRelationshipsResponse,
  DeleteProductMainImageRelationshipsError,
  GetProductMainImageRelationshipsData,
  GetProductMainImageRelationshipsResponse,
  GetProductMainImageRelationshipsError,
  CreateProductMainImageRelationshipsData,
  CreateProductMainImageRelationshipsResponse,
  CreateProductMainImageRelationshipsError,
  UpdateProductMainImageRelationshipsData,
  UpdateProductMainImageRelationshipsResponse,
  UpdateProductMainImageRelationshipsError,
  DetachCustomRelationshipsData,
  DetachCustomRelationshipsResponse,
  DetachCustomRelationshipsError,
  ListAttachedCustomRelationshipData,
  ListAttachedCustomRelationshipResponse,
  ListAttachedCustomRelationshipError,
  AttachCustomRelationshipsData,
  AttachCustomRelationshipsResponse,
  AttachCustomRelationshipsError,
  DissociateProductsData,
  DissociateProductsResponse,
  DissociateProductsError,
  GetRelatedProductIdsOfAProductIdData,
  GetRelatedProductIdsOfAProductIdResponse,
  GetRelatedProductIdsOfAProductIdError,
  ProductAssociationIdData,
  ProductAssociationIdResponse,
  ProductAssociationIdError,
  GetRelatedProductsOfAProductIdData,
  GetRelatedProductsOfAProductIdResponse,
  GetRelatedProductsOfAProductIdError,
  GetAllVariationsData,
  GetAllVariationsResponse,
  GetAllVariationsError,
  CreateVariationData,
  CreateVariationResponse,
  CreateVariationError,
  DeleteVariationData,
  DeleteVariationResponse,
  DeleteVariationError,
  GetVariationData,
  GetVariationResponse,
  GetVariationError,
  UpdateVariationData,
  UpdateVariationResponse,
  UpdateVariationError,
  GetAllVariationOptionsData,
  GetAllVariationOptionsResponse,
  GetAllVariationOptionsError,
  CreateVariationOptionData,
  CreateVariationOptionResponse,
  CreateVariationOptionError,
  DeleteVariationOptionData,
  DeleteVariationOptionResponse,
  DeleteVariationOptionError,
  GetVariationOptionData,
  GetVariationOptionResponse,
  GetVariationOptionError,
  UpdateVariationOptionData,
  UpdateVariationOptionResponse,
  UpdateVariationOptionError,
  GetAllModifiersData,
  GetAllModifiersResponse,
  GetAllModifiersError,
  CreateModifierData,
  CreateModifierResponse,
  CreateModifierError,
  DeleteModifierData,
  DeleteModifierResponse,
  DeleteModifierError,
  GetModifierData,
  GetModifierResponse,
  GetModifierError,
  UpdateModifierData,
  UpdateModifierResponse,
  UpdateModifierError,
  GetHierarchyData,
  GetHierarchyResponse,
  GetHierarchyError,
  CreateHierarchyData,
  CreateHierarchyResponse,
  CreateHierarchyError,
  GetAllNodesData,
  GetAllNodesResponse,
  GetAllNodesError,
  DeleteHierarchyData,
  DeleteHierarchyResponse,
  DeleteHierarchyError,
  GetHierarchyChildData,
  GetHierarchyChildResponse,
  GetHierarchyChildError,
  UpdateHierarchyData,
  UpdateHierarchyResponse,
  UpdateHierarchyError,
  GetAllNodesInHierarchyData,
  GetAllNodesInHierarchyResponse,
  GetAllNodesInHierarchyError,
  CreateNodeData,
  CreateNodeResponse,
  CreateNodeError,
  DeleteNodeData,
  DeleteNodeResponse,
  DeleteNodeError,
  GetHierarchyNodeData,
  GetHierarchyNodeResponse,
  GetHierarchyNodeError,
  UpdateNodeData,
  UpdateNodeResponse,
  UpdateNodeError,
  GetAllChildrenData,
  GetAllChildrenResponse,
  GetAllChildrenError,
  CreateHierarchyChildRelationshipsData,
  CreateHierarchyChildRelationshipsResponse,
  CreateHierarchyChildRelationshipsError,
  CreateNodeChildRelationshipsData,
  CreateNodeChildRelationshipsResponse,
  CreateNodeChildRelationshipsError,
  GetAllNodeChildrenData,
  GetAllNodeChildrenResponse,
  GetAllNodeChildrenError,
  DeleteNodeParentData,
  DeleteNodeParentResponse,
  DeleteNodeParentError,
  UpdateNodeParentData,
  UpdateNodeParentResponse,
  UpdateNodeParentError,
  DeleteNodeProductRelationshipsData,
  DeleteNodeProductRelationshipsResponse,
  DeleteNodeProductRelationshipsError,
  CreateNodeProductRelationshipData,
  CreateNodeProductRelationshipResponse,
  CreateNodeProductRelationshipError,
  GetNodeProductsData,
  GetNodeProductsResponse,
  GetNodeProductsError,
  DuplicateHierarchyData,
  DuplicateHierarchyResponse,
  DuplicateHierarchyError,
  GetAllProductTagsData,
  GetAllProductTagsResponse,
  GetAllProductTagsError,
  GetProductTagData,
  GetProductTagResponse,
  GetProductTagError,
  GetCustomRelationshipsData,
  GetCustomRelationshipsResponse,
  GetCustomRelationshipsError,
  CreateCustomRelationshipData,
  CreateCustomRelationshipResponse,
  CreateCustomRelationshipError,
  DeleteCustomRelationshipData,
  DeleteCustomRelationshipResponse,
  DeleteCustomRelationshipError,
  GetCustomRelationshipData,
  GetCustomRelationshipResponse,
  GetCustomRelationshipError,
  UpdateCustomRelationshipData,
  UpdateCustomRelationshipResponse,
  UpdateCustomRelationshipError,
} from "./types.gen"

export const client = createClient(createConfig())

/**
 * Get All Jobs
 * The jobs endpoints displays the status of a number of endpoints that function as jobs, for example, product import and export, price book import, building child products, and duplicating hierarchies.
 */
export const getAllJobs = <ThrowOnError extends boolean = false>(
  options?: Options<GetAllJobsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllJobsResponse,
    GetAllJobsError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/jobs",
  })
}

/**
 * Get a Job
 */
export const getJob = <ThrowOnError extends boolean = false>(
  options: Options<GetJobData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetJobResponse,
    GetJobError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/jobs/{jobID}",
  })
}

/**
 * Cancel a Job
 * The jobs endpoints display the status of a number of endpoints that function as jobs, for example, product import and export, and duplicating hierarchies.
 *
 * Jobs are processed one at a time. You can continue to send job requests, but those jobs are queued. In other words, Commerce looks for any jobs that have a status of PENDING and starts the job with the earliest created date. If you decide that a specific job needs to be prioritized over another, you can cancel the less critical job using the `Cancel a job` endpoint. You can only cancel jobs whose status is PENDING.
 *
 */
export const cancelJob = <ThrowOnError extends boolean = false>(
  options: Options<CancelJobData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CancelJobResponse,
    CancelJobError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/jobs/{jobID}/cancel",
  })
}

/**
 * Get Job Errors
 */
export const getJobErrors = <ThrowOnError extends boolean = false>(
  options: Options<GetJobErrorsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetJobErrorsResponse,
    GetJobErrorsError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/jobs/{jobID}/errors",
  })
}

/**
 * Get all products
 * Retrieves a list of all your products in the Product Experience Manager system.
 *
 * You can also use `include` to retrieve top-level resources, such as files or images, and key attribute data, such as SKU or slug for component products in a product bundle. With this option, you can get more information about the products in a product bundle in your store front, improving the buying experience for your shoppers.
 *
 * #### Filtering
 *
 * Many Commerce API endpoints support filtering. The general syntax is described in [**Filtering**](/guides/Getting-Started/filtering).
 *
 * The following attributes and operators are supported.
 *
 * | Operator          | Attribute                                                                                                                                               | Description                                                                                                                                                                                                                                             | Example                                      |
 * | :---------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------- |
 * | `eq`              | `id`, `sku`, `slug`, `upc_ean`, `manufacturer_part_num`, `name`, `templates`, `commodity_type`, `owner`, `product_types`, `parent_id`, `tags`, `status`, `has_nodes (false only)`, `created_at`, `updated_at`, `external_ref`, `description` | Equals. Checks if the values of two operands are equal. If they are, the condition is true. For `product_types`, you can only specify one product type. **Note:** `has_nodes` can only be filtered as `false`.                           | `?filter=eq(name,some-name)`                 |
 * | `like`            | `sku`, `slug`, `upc_ean`, `manufacturer_part_num`, `name`, `tags`, `description`, `external_ref`                                                           | Like. Checks if the operand contains the specified string. Wildcards are supported.                                                                                                                                                                   | `?filter=like(name,*some-name*)`              |
 * | `in`              | `id`, `name`, `sku`, `slug`, `upc_ean`, `manufacturer_part_num`, `product_types`, `parent_id`, `tags`, `external_ref`                                        | Checks if the values are included in the specified list. If they are, the condition is true. For `product_types`, you can specify more than one product type.                                                                                        | `?filter=in(id,some-id)`                     |
 * | `gt`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Greater than. Checks if the value of the field is greater than the given value.                                                                                                                                                                         | `?filter=gt(updated_at,2024-01-01T00:00:00Z)`  |
 * | `ge`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Greater than or equal to. Checks if the value of the field is greater than or equal to the given value.                                                                                                                                                 | `?filter=ge(created_at,2023-01-01T00:00:00Z)`  |
 * | `lt`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Less than. Checks if the value of the field is less than the given value.                                                                                                                                                                               | `?filter=lt(updated_at,2025-01-01T00:00:00Z)`  |
 * | `le`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Less than or equal to. Checks if the value of the field is less than or equal to the given value.                                                                                                                                                       | `?filter=le(created_at,2022-01-01T00:00:00Z)`  |
 * | `eq` (extensions) | `extensions.book.isbn`                                                                                                                                    | Filters using a nested extension field.                                                                                                                                                                                                               | `?filter=eq(extensions.book.isbn,1765426)`     |
 *
 */
export const getAllProducts = <ThrowOnError extends boolean = false>(
  options?: Options<GetAllProductsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllProductsResponse,
    GetAllProductsError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products",
  })
}

/**
 * Create a product or bundle
 * Creates a product or bundle with the attributes that are defined in the body.
 *
 * #### Product Types
 *
 * Product Experience Manager automatically assigns types to the products you create. You can filter on product types. Product types can also be used in catalogs. For example, in your catalog, you can filter on `parent` so that only your parent products are displayed in your storefront.
 *
 * See [**Product Types**](/docs/api/pxm/products/products#product-types).
 *
 * #### Product Tags
 *
 * You can use product tags to store or assign a key word against a product or service that you sell in your store. The product tag can then be used to describe or label that product. Product tags represent similarities between products who do not share the same attributes. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on.
 *
 * See [**Product Tags**](/docs/api/pxm/products/product-tags).
 *
 * #### Personalizing Products
 *
 * You can allow your shoppers to add custom text to a product when adding product items to their carts. This is useful, for example, if you have a product like a T-shirt that can be personalized, or you sell greetings cards that can be printed with your shoppers personalized messages. You can do this by configuring the `custom_inputs` attribute.
 *
 * When configuring the `custom_inputs` attribute:
 *
 * - You can rename `input` to something more representative of the input that shoppers are adding, for example, `message` or `front`.
 * - `name` is the name that is displayed in your storefront.
 * - You can add validation rules. For example, the input field must be a `string` and/or up to 255 characters in length. The limit is 255 characters.
 * - You can specify if the input field is required.
 *
 * #### Curating Products
 *
 * You can curate the products in a node. Product curation allows you to promote specific products within each node of your hierarchies, enabling you to create unique product collections in your storefront. For example, you may find you have an abundance of cotton T-Shirts and you want to promote these products to the top of the product list. When a shopper navigates to T-shirts, the cotton T-Shirts are displayed first. See [**Update a node**](/docs/api/pxm/products/update-node).
 *
 * #### Bundles
 *
 * With Product Experience Manager, you can use the products API to create and manage bundles. A bundle is a purchasable product, consisting of one or more products that you want to sell together.
 *
 * See [**Bundles**](/docs/api/pxm/products/products#bundles).
 *
 */
export const createProduct = <ThrowOnError extends boolean = false>(
  options: Options<CreateProductData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateProductResponse,
    CreateProductError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products",
  })
}

/**
 * Import Products
 *
 * You can use the Product Import API to:
 *
 * - Add new products, including:
 *
 * - main image files. See [Importing Main Image Files](/docs/api/pxm/products/product-import-bulk-update#using-imported-main-image-files).
 * - custom data. See [Importing custom data](/docs/api/pxm/products/product-import-bulk-update#importing-custom-data-flows).
 * - Make bulk updates to existing products.
 *
 * You cannot use product import to:
 *
 * - Delete existing products.
 * - Import product bundles.
 *
 * The Product Import API uses a Comma Separated Values (CSV) file to import products, main image files and custom extension data. Each row in a .csv file represents a product you want to create/update. See an [example file](/assets/pim_product_import_example.csv).
 *
 * Each file can have 50,000 rows, including the header. If a CSV file exceeds 50,000 rows, an error is displayed, and the products are not imported. A CSV file must not be larger than 50 megabytes. If a CSV file is larger than 50 megabytes, a `503 client read` error is displayed.
 *
 * If you want to create/update more than 50,000 products or your CSV file is larger than 50 megabytes, you must have a separate CSV file and import each CSV file one at a time.
 *
 * See [**Characteristics of CSV Files**](/docs/api/pxm/products/product-import-bulk-update#characteristics-of-csv-import-files).
 *
 */
export const importProducts = <ThrowOnError extends boolean = false>(
  options?: Options<ImportProductsData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    ImportProductsResponse,
    ImportProductsError,
    ThrowOnError
  >({
    ...options,
    ...formDataBodySerializer,
    headers: {
      "Content-Type": null,
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/import",
  })
}

/**
 * Export Products
 *
 * The Export API is available to make bulk updates to products in Product Experience Manager. You might also export products for your personal requirements.
 *
 * The Export API builds a CSV file containing the product entries. A CSV file can contain up to 50,000 product entries. If you have more than 50,000 product entries, then another CSV file is created and so on, until all your products are exported.
 *
 * The Job endpoint response specifies the location where the CSV file is stored. See [Characteristics of CSV Files](/docs/api/pxm/products/product-export#characteristics-of-exporting-products).
 *
 * ### Filtering
 *
 * The following attributes and operators are supported.
 *
 * | Operator          | Attribute                                                                                                                                               | Description                                                                                                                                                                                                                                             | Example                                      |
 * | :---------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------- |
 * | `eq`              | `id`, `sku`, `slug`, `upc_ean`, `manufacturer_part_num`, `name`, `templates`, `commodity_type`, `owner`, `product_types`, `parent_id`, `tags`, `status`, `has_nodes (false only)`, `created_at`, `updated_at`, `external_ref`, `description` | Equals. Checks if the values of two operands are equal. If they are, the condition is true. For `product_types`, you can only specify one product type. **Note:** `has_nodes` can only be filtered as `false`.                           | `?filter=eq(name,some-name)`                 |
 * | `like`            | `sku`, `slug`, `upc_ean`, `manufacturer_part_num`, `name`, `tags`, `description`, `external_ref`                                                           | Like. Checks if the operand contains the specified string. Wildcards are supported.                                                                                                                                                                   | `?filter=like(name,*some-name*)`              |
 * | `in`              | `id`, `name`, `sku`, `slug`, `upc_ean`, `manufacturer_part_num`, `product_types`, `parent_id`, `tags`, `external_ref`                                        | Checks if the values are included in the specified list. If they are, the condition is true. For `product_types`, you can specify more than one product type.                                                                                        | `?filter=in(id,some-id)`                     |
 * | `gt`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Greater than. Checks if the value of the field is greater than the given value.                                                                                                                                                                         | `?filter=gt(updated_at,2024-01-01T00:00:00Z)`  |
 * | `ge`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Greater than or equal to. Checks if the value of the field is greater than or equal to the given value.                                                                                                                                                 | `?filter=ge(created_at,2023-01-01T00:00:00Z)`  |
 * | `lt`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Less than. Checks if the value of the field is less than the given value.                                                                                                                                                                               | `?filter=lt(updated_at,2025-01-01T00:00:00Z)`  |
 * | `le`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Less than or equal to. Checks if the value of the field is less than or equal to the given value.                                                                                                                                                       | `?filter=le(created_at,2022-01-01T00:00:00Z)`  |
 * | `eq` (extensions) | `extensions.book.isbn`                                                                                                                                    | Filters using a nested extension field.                                                                                                                                                                                                               | `?filter=eq(extensions.book.isbn,1765426)`     |
 *
 */
export const exportProducts = <ThrowOnError extends boolean = false>(
  options?: Options<ExportProductsData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    ExportProductsResponse,
    ExportProductsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/export",
  })
}

/**
 * Delete a product
 * Deletes the specified product.
 *
 * You cannot delete a product if it is part of a bundle. You must first delete the bundle before you delete the product.
 *
 */
export const deleteProduct = <ThrowOnError extends boolean = false>(
  options: Options<DeleteProductData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteProductResponse,
    DeleteProductError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}",
  })
}

/**
 * Get a product
 * Returns a product by its identifier.
 *
 * You can also use `include=component_products` to retrieve top-level resources, such as files or images, and key attribute data, such as SKU or slug for component products in a product bundle. With this option, you can get more information about the products in a product bundle in your store front, improving the buying experience for your shoppers.
 *
 */
export const getProduct = <ThrowOnError extends boolean = false>(
  options: Options<GetProductData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetProductResponse,
    GetProductError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}",
  })
}

/**
 * Update a product or bundle
 * Specify whichever attributes you want to change. The values of the other attributes remain the same. If the attributes section is empty, the product or bundle is not updated.
 */
export const updateProduct = <ThrowOnError extends boolean = false>(
  options: Options<UpdateProductData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateProductResponse,
    UpdateProductError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}",
  })
}

/**
 * Attach multiple nodes
 * Assigns products to multiple hierarchies and their children nodes. You can apply a filter to search for the appropriate products to attach to a node. For general filtering syntax, see [**Filtering**](/guides/Getting-Started/filtering).
 *
 * The following attributes and operators are supported.
 *
 * | Operator          | Attribute                                                                                                                                               | Description                                                                                                                                                                                                                                             | Example                                      |
 * | :---------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------- |
 * | `eq`              | `id`, `sku`, `slug`, `upc_ean`, `manufacturer_part_num`, `name`, `templates`, `commodity_type`, `owner`, `product_types`, `parent_id`, `tags`, `status`, `has_nodes (false only)`, `created_at`, `updated_at`, `external_ref`, `description` | Equals. Checks if the values of two operands are equal. If they are, the condition is true. For `product_types`, you can only specify one product type. **Note:** `has_nodes` can only be filtered as `false`.                           | `?filter=eq(name,some-name)`                 |
 * | `like`            | `sku`, `slug`, `upc_ean`, `manufacturer_part_num`, `name`, `tags`, `description`, `external_ref`                                                           | Like. Checks if the operand contains the specified string. Wildcards are supported.                                                                                                                                                                   | `?filter=like(name,*some-name*)`              |
 * | `in`              | `id`, `name`, `sku`, `slug`, `upc_ean`, `manufacturer_part_num`, `product_types`, `parent_id`, `tags`, `external_ref`                                        | Checks if the values are included in the specified list. If they are, the condition is true. For `product_types`, you can specify more than one product type.                                                                                        | `?filter=in(id,some-id)`                     |
 * | `gt`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Greater than. Checks if the value of the field is greater than the given value.                                                                                                                                                                         | `?filter=gt(updated_at,2024-01-01T00:00:00Z)`  |
 * | `ge`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Greater than or equal to. Checks if the value of the field is greater than or equal to the given value.                                                                                                                                                 | `?filter=ge(created_at,2023-01-01T00:00:00Z)`  |
 * | `lt`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Less than. Checks if the value of the field is less than the given value.                                                                                                                                                                               | `?filter=lt(updated_at,2025-01-01T00:00:00Z)`  |
 * | `le`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Less than or equal to. Checks if the value of the field is less than or equal to the given value.                                                                                                                                                       | `?filter=le(created_at,2022-01-01T00:00:00Z)`  |
 * | `eq` (extensions) | `extensions.book.isbn`                                                                                                                                    | Filters using a nested extension field.                                                                                                                                                                                                               | `?filter=eq(extensions.book.isbn,1765426)`     |
 *
 */
export const attachNodes = <ThrowOnError extends boolean = false>(
  options: Options<AttachNodesData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    AttachNodesResponse,
    AttachNodesError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/attach_nodes",
  })
}

/**
 * Detach multiple nodes
 * Dissociates products from multiple hierarchies and their children nodes. You can apply filters to search for the appropriate products to detach. For general filtering syntax, see [**Filtering**](/guides/Getting-Started/filtering).
 *
 * The following attributes and operators are supported.
 *
 * | Operator          | Attribute                                                                                                                                               | Description                                                                                                                                                                                                                                             | Example                                      |
 * | :---------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------- |
 * | `eq`              | `id`, `sku`, `slug`, `upc_ean`, `manufacturer_part_num`, `name`, `templates`, `commodity_type`, `owner`, `product_types`, `parent_id`, `tags`, `status`, `has_nodes (false only)`, `created_at`, `updated_at`, `external_ref`, `description` | Equals. Checks if the values of two operands are equal. If they are, the condition is true. For `product_types`, you can only specify one product type. **Note:** `has_nodes` can only be filtered as `false`.                           | `?filter=eq(name,some-name)`                 |
 * | `like`            | `sku`, `slug`, `upc_ean`, `manufacturer_part_num`, `name`, `tags`, `description`, `external_ref`                                                           | Like. Checks if the operand contains the specified string. Wildcards are supported.                                                                                                                                                                   | `?filter=like(name,*some-name*)`              |
 * | `in`              | `id`, `name`, `sku`, `slug`, `upc_ean`, `manufacturer_part_num`, `product_types`, `parent_id`, `tags`, `external_ref`                                        | Checks if the values are included in the specified list. If they are, the condition is true. For `product_types`, you can specify more than one product type.                                                                                        | `?filter=in(id,some-id)`                     |
 * | `gt`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Greater than. Checks if the value of the field is greater than the given value.                                                                                                                                                                         | `?filter=gt(updated_at,2024-01-01T00:00:00Z)`  |
 * | `ge`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Greater than or equal to. Checks if the value of the field is greater than or equal to the given value.                                                                                                                                                 | `?filter=ge(created_at,2023-01-01T00:00:00Z)`  |
 * | `lt`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Less than. Checks if the value of the field is less than the given value.                                                                                                                                                                               | `?filter=lt(updated_at,2025-01-01T00:00:00Z)`  |
 * | `le`              | `id`, `created_at`, `updated_at`, `external_ref`                                                                                                          | Less than or equal to. Checks if the value of the field is less than or equal to the given value.                                                                                                                                                       | `?filter=le(created_at,2022-01-01T00:00:00Z)`  |
 * | `eq` (extensions) | `extensions.book.isbn`                                                                                                                                    | Filters using a nested extension field.                                                                                                                                                                                                               | `?filter=eq(extensions.book.isbn,1765426)`     |
 *
 */
export const detachNodes = <ThrowOnError extends boolean = false>(
  options: Options<DetachNodesData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    DetachNodesResponse,
    DetachNodesError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/detach_nodes",
  })
}

/**
 * Get a product's nodes
 * Returns the nodes associated with the product. Products must be in a `live` status.
 */
export const getProductsNodes = <ThrowOnError extends boolean = false>(
  options: Options<GetProductsNodesData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetProductsNodesResponse,
    GetProductsNodesError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/nodes",
  })
}

/**
 * Build child products
 * With product variations in Product Experience Manager, you can create product variations and different options for each variation and use both to create child products for a product. Each child product is a unique combination of options associated with the product.
 *
 * Child products inherit attributes from their parent products. When you make changes to the attributes of the parent products, you can rebuild your child products, ensuring that changes to the parent products are propagated to the child products.
 *
 * Alternatively, you can modify a child product independently, without impacting its parent product. For example, you may prefer the status of your child product to be `live`, while keeping the parent product's status as `draft`. When you directly update a child product, it becomes independent of its parent product. In other words, any subsequent changes made to the parent product are not automatically reflected in the child product when you rebuild the parent product and its child products. Once a child product is independent of its parent, you cannot recreate the association between the child product and its parent. You must delete the child product and rebuild the parent to recreate the child product.
 *
 * Following on from that, if you add the same flow to both a parent and child product, the child flow values are not affected by changes to the parent flow values in a rebuild.
 *
 * ### Using Build Rules
 *
 * When building your child products, you can build all products related to a product.
 *
 * Alternatively, you can build a combination of child products associated with a product, based on build rules that you specify. This is useful, for example, if you have a variation option that you do not sell. This makes managing and building your child products quick and easy. You can do this using `build_rules`. `build_rules` are combinations of variation option IDs that you wish to include or exclude when building your child products.
 *
 * :::note
 *
 * You do not need to configure any `build_rules` in the following scenarios:
 *
 * - Child products must be built with all variation options. Simply, use the `Create a product` or `Update a product` endpoints with no `build_rules` specified.
 * - Child products must be built apart from all options for a specific variation. In this case, you must remove the variation and use the `Create a product` or `Update a product` endpoints with no `build_rules` specified. In other words, using our example, if none of the `size` options should be included, then remove the `size` variation.
 *
 * :::
 *
 * The `build_rules` contain:
 *
 * - (Required) `default`: specifies the default behavior.
 * - (Optional) `include`: specifies the option IDs to include when the child products are built. Each combination consists of a nested array of option IDs from one or more variations. Combinations of option IDs in the nested arrays must come from different variations. See [**Invalid Build Rules**](#invalid-build-rules).
 * - (Optional) `exclude`: specifies the option IDs to exclude when the child products are built. Each combination consists of a nested array of option IDs from one or more variations. Combinations of option IDs in the nested arrays must come from different variations. See [**Invalid build rules**](#invalid-build-rules).
 *
 * When building child products, Commerce compares each combination of option IDs to these rules to determine how your child products should be built, depending on how you have configured the `build_rules`. It depends on your requirements how you configure your `build_rules`.
 *
 * #### Invalid Build Rules
 *
 * The `build_rules` are invalid if both the option IDs come from the same variation. Combinations of option IDs in the nested arrays must come from different variations.
 *
 * If Commerce cannot resolve the `build_rules` a `could not determine whether to include or exclude a child product due to ambiguous rules` error is returned. This error can occur, for example, if you have the same number of variation option IDs in both the `include` and `exclude` arrays and the variation option IDs match.
 *
 * ### Building Child Products
 *
 * Building child products is an asynchronous operation. When you build child products, a job is created. The jobId of the job is displayed in the response. When the job is complete, the build child products operation is also complete. You can use the jobId to see the status of your job using the `Get a Job` endpoint.
 *
 * Jobs are processed one at a time. You can continue to send build child product requests, but those jobs are queued. In other words, Commerce looks for any jobs that have a status of PENDING and starts the job with the earliest created date. This process is repeated until all jobs are processed. See Jobs.
 *
 * Re-building child products after adding or removing a new variation changes the total number of child products that you can generate from a parent product. When you rebuild the child products after updating variations associated with the parent product, all existing child products that belong to a parent product are deleted. New child products are created with new product IDs.
 *
 * If you have any bundles that reference child products directly, then you must update the bundles with the new child product IDs.
 *
 * However, re-building child products after adding or removing an option does not change the existing product IDs.
 *
 */
export const buildChildProducts = <ThrowOnError extends boolean = false>(
  options: Options<BuildChildProductsData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    BuildChildProductsResponse,
    BuildChildProductsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/build",
  })
}

/**
 * Get child products
 */
export const getChildProducts = <ThrowOnError extends boolean = false>(
  options: Options<GetChildProductsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetChildProductsResponse,
    GetChildProductsError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/children",
  })
}

/**
 * Delete a product template relationship
 */
export const deleteProductTemplateRelationship = <
  ThrowOnError extends boolean = false,
>(
  options: Options<DeleteProductTemplateRelationshipData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteProductTemplateRelationshipResponse,
    DeleteProductTemplateRelationshipError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/templates",
  })
}

/**
 * Get all product template relationships
 */
export const getProductTemplateRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<GetProductTemplateRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetProductTemplateRelationshipsResponse,
    GetProductTemplateRelationshipsError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/templates",
  })
}

/**
 * Create a product template relationship
 * Retrieves all the templates that are associated with the specified product.
 */
export const createProductTemplateRelationship = <
  ThrowOnError extends boolean = false,
>(
  options: Options<CreateProductTemplateRelationshipData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateProductTemplateRelationshipResponse,
    CreateProductTemplateRelationshipError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/templates",
  })
}

/**
 * Get Bundle Component Product Relationships
 * Retrieves all the products included in the specified bundle product.
 */
export const getProductComponentProductsRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<GetProductComponentProductsRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetProductComponentProductsRelationshipsResponse,
    GetProductComponentProductsRelationshipsError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/component_products",
  })
}

/**
 * Delete a product file relationships
 */
export const deleteProductFileRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<DeleteProductFileRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteProductFileRelationshipsResponse,
    DeleteProductFileRelationshipsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/files",
  })
}

/**
 * Get all product file relationships
 * Retrieves all files that are associated with the specified product.
 */
export const getProductFileRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<GetProductFileRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetProductFileRelationshipsResponse,
    GetProductFileRelationshipsError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/files",
  })
}

/**
 * Create a product file relationship
 */
export const createProductFileRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<CreateProductFileRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateProductFileRelationshipsResponse,
    CreateProductFileRelationshipsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/files",
  })
}

/**
 * Replace a product file relationship
 */
export const updateProductFileRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<UpdateProductFileRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateProductFileRelationshipsResponse,
    UpdateProductFileRelationshipsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/files",
  })
}

/**
 * Delete a product variation relationships
 */
export const deleteProductVariationRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<DeleteProductVariationRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteProductVariationRelationshipsResponse,
    DeleteProductVariationRelationshipsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/variations",
  })
}

/**
 * Get all product variation relationships
 */
export const getProductVariationRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<GetProductVariationRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetProductVariationRelationshipsResponse,
    GetProductVariationRelationshipsError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/variations",
  })
}

/**
 * Create a product variation relationship
 */
export const createProductVariationRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<CreateProductVariationRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateProductVariationRelationshipsResponse,
    CreateProductVariationRelationshipsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/variations",
  })
}

/**
 * Replace a product variation relationship
 */
export const updateProductVariationRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<UpdateProductVariationRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateProductVariationRelationshipsResponse,
    UpdateProductVariationRelationshipsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/variations",
  })
}

/**
 * Delete Main Image Relationships
 */
export const deleteProductMainImageRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<DeleteProductMainImageRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteProductMainImageRelationshipsResponse,
    DeleteProductMainImageRelationshipsError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/main_image",
  })
}

/**
 * Get Main Image Relationships
 */
export const getProductMainImageRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<GetProductMainImageRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetProductMainImageRelationshipsResponse,
    GetProductMainImageRelationshipsError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/main_image",
  })
}

/**
 * Create main image relationships
 * Associates a main image with the specified product.
 */
export const createProductMainImageRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<CreateProductMainImageRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateProductMainImageRelationshipsResponse,
    CreateProductMainImageRelationshipsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/main_image",
  })
}

/**
 * Replace Main Image Relationships
 */
export const updateProductMainImageRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<UpdateProductMainImageRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateProductMainImageRelationshipsResponse,
    UpdateProductMainImageRelationshipsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/relationships/main_image",
  })
}

/**
 * Delete Custom Relationships from a Product
 * Delete Custom Relationships from a Product. Multiple Custom Relationships can be deleted from a product in one request.
 *
 */
export const detachCustomRelationships = <ThrowOnError extends boolean = false>(
  options: Options<DetachCustomRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DetachCustomRelationshipsResponse,
    DetachCustomRelationshipsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/custom-relationships",
  })
}

/**
 * Get all Custom Relationships attached to a Product
 * ### Prerequisites
 * - Custom Relationships have been attached to a product, see [Attach Custom Relationships to a Product](/docs/api/pxm/products/attach-custom-relationships)
 * - **OR** Products have been related to one another, see [Create a Relationship between a product with one or more products](/docs/api/pxm/products/product-association-id)
 *
 */
export const listAttachedCustomRelationship = <
  ThrowOnError extends boolean = false,
>(
  options: Options<ListAttachedCustomRelationshipData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    ListAttachedCustomRelationshipResponse,
    ListAttachedCustomRelationshipError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/custom-relationships",
  })
}

/**
 * Attach Custom Relationships to a Product
 * You can attach up to 5 custom relationships to a product.
 *
 * Once you have attached a custom relationship to a product, you can then create relationships from a product to one or many other products. See [Associate a product to one or more products using a custom relationship](/docs/api/pxm/products/product-association-id).
 *
 * See [Custom Relationships](/guides/key-concepts/product-experience-manager/custom-relationships/).
 *
 * ### Prerequisites
 * - A Custom Relationship has been created, see [create a Custom Relationship](/docs/api/pxm/products/create-custom-relationship),
 * - A Product has been created.
 *
 */
export const attachCustomRelationships = <ThrowOnError extends boolean = false>(
  options: Options<AttachCustomRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    AttachCustomRelationshipsResponse,
    AttachCustomRelationshipsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/custom-relationships",
  })
}

/**
 * Delete a Relationship between a product with one or more products
 */
export const dissociateProducts = <ThrowOnError extends boolean = false>(
  options: Options<DissociateProductsData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DissociateProductsResponse,
    DissociateProductsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/custom-relationships/{customRelationshipSlug}",
  })
}

/**
 * Get all Related Product IDs of a Products' attached Custom Relationship
 * ### Prerequisites
 * - Relationships have been created between Products, see [Create a Relationship between a product with one or more products](/docs/api/pxm/products/product-association-id).
 *
 */
export const getRelatedProductIdsOfAProductId = <
  ThrowOnError extends boolean = false,
>(
  options: Options<GetRelatedProductIdsOfAProductIdData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetRelatedProductIdsOfAProductIdResponse,
    GetRelatedProductIdsOfAProductIdError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/custom-relationships/{customRelationshipSlug}",
  })
}

/**
 * Create a Relationship between a Product with one or more Products
 * - You can associate a product with up to 2000 other products.
 * - You do not need to attach a custom relationship to products beforehand, this will be done automatically by this endpoint.
 * - This is a partial update, so if you make a request to this endpoint multiple times with different products in each request, they will not be overwritten but will be appended to the related products list.
 *
 * If you want to remove a relationship between products, see [Delete a Relationship between a product with one or more products](/docs/api/pxm/products/dissociate-products).
 *
 * ### Prerequisites
 * - A Custom Relationship has been created, see [create a Custom Relationship](/docs/api/pxm/products/create-custom-relationship).
 * - A Product has been created for the relationship to be based from.
 * - One or many Product have been created for the product to relate to.
 *
 */
export const productAssociationId = <ThrowOnError extends boolean = false>(
  options: Options<ProductAssociationIdData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    ProductAssociationIdResponse,
    ProductAssociationIdError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/custom-relationships/{customRelationshipSlug}",
  })
}

/**
 * Get all Related Products of a Products' attached Custom Relationship
 * ### Prerequisites
 * - Relationships have been created between Products, see [Create a Relationship between a product with one or more products](/docs/api/pxm/products/product-association-id).
 *
 */
export const getRelatedProductsOfAProductId = <
  ThrowOnError extends boolean = false,
>(
  options: Options<GetRelatedProductsOfAProductIdData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetRelatedProductsOfAProductIdResponse,
    GetRelatedProductsOfAProductIdError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/products/{productID}/custom-relationships/{customRelationshipSlug}/products",
  })
}

/**
 * Get all variations
 */
export const getAllVariations = <ThrowOnError extends boolean = false>(
  options?: Options<GetAllVariationsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllVariationsResponse,
    GetAllVariationsError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/variations",
  })
}

/**
 * Create a variation
 */
export const createVariation = <ThrowOnError extends boolean = false>(
  options: Options<CreateVariationData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateVariationResponse,
    CreateVariationError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/variations",
  })
}

/**
 * Delete a variation and all it's associated options.
 */
export const deleteVariation = <ThrowOnError extends boolean = false>(
  options: Options<DeleteVariationData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteVariationResponse,
    DeleteVariationError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/variations/{variationID}",
  })
}

/**
 * Get a variation
 */
export const getVariation = <ThrowOnError extends boolean = false>(
  options: Options<GetVariationData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetVariationResponse,
    GetVariationError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/variations/{variationID}",
  })
}

/**
 * Update a variation
 * Specify whichever attributes you want to change. The values of the other attributes remain the same. If the attributes section is empty, the variation is not updated.
 */
export const updateVariation = <ThrowOnError extends boolean = false>(
  options: Options<UpdateVariationData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateVariationResponse,
    UpdateVariationError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/variations/{variationID}",
  })
}

/**
 * Get all variation options
 */
export const getAllVariationOptions = <ThrowOnError extends boolean = false>(
  options: Options<GetAllVariationOptionsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllVariationOptionsResponse,
    GetAllVariationOptionsError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/variations/{variationID}/options",
  })
}

/**
 * Create a variation option
 */
export const createVariationOption = <ThrowOnError extends boolean = false>(
  options: Options<CreateVariationOptionData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateVariationOptionResponse,
    CreateVariationOptionError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/variations/{variationID}/options",
  })
}

/**
 * Delete a variation option
 */
export const deleteVariationOption = <ThrowOnError extends boolean = false>(
  options: Options<DeleteVariationOptionData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteVariationOptionResponse,
    DeleteVariationOptionError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/variations/{variationID}/options/{optionID}",
  })
}

/**
 * Get a variation option
 */
export const getVariationOption = <ThrowOnError extends boolean = false>(
  options: Options<GetVariationOptionData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetVariationOptionResponse,
    GetVariationOptionError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/variations/{variationID}/options/{optionID}",
  })
}

/**
 * Update a variation option
 */
export const updateVariationOption = <ThrowOnError extends boolean = false>(
  options: Options<UpdateVariationOptionData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateVariationOptionResponse,
    UpdateVariationOptionError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/variations/{variationID}/options/{optionID}",
  })
}

/**
 * Get all modifiers
 */
export const getAllModifiers = <ThrowOnError extends boolean = false>(
  options: Options<GetAllModifiersData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllModifiersResponse,
    GetAllModifiersError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/variations/{variationID}/options/{optionID}/modifiers",
  })
}

/**
 * Create a modifier
 * You can specify different modifiers for different options in a variation. When you build child products using options in variations, the properties of a child products depends on the modifier set for the options that are applied to the child product.
 *
 * The table below describes the different types of modifiers.
 *
 * | Modifier | Data Type | Effect |
 * | :--- | :--- | :--- |
 * | `name_equals` | `string` | Overrides the name of the child product with the name specified by the modifier. |
 * | `name_append` | `string` | Appends the string specified in the modifier to the name of the child product. |
 * | `name_prepend` | `string` | Prepends the string specified in the modifier to the name of the child product. |
 * | `description_equals` | `string` | Overrides the description of the child product. |
 * | `description_append` | `string` | Appends the string specified in the modifier to the description of the child product. |
 * | `description_prepend` | `string` | Prepends the string specified in the modifier to the product description of the child product. |
 * | `commodity_type` | `string` | Sets the commodity type of the child product, such as `physical` or `digital`. |
 * | `price` | `string` | Allows application of price modifiers (`price_increment`, `price_decrement`, and `price_equals`) to the child products. |
 * | `price_increment` | `string` | Increases the price of the child product. |
 * | `price_decrement` | `string` | Decreases the price of the child product. |
 * | `price_equals` | `string` | Sets the price of a child product to the amount you specify. |
 * | `slug_append` | `string` | Appends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
 * | `slug_prepend` | `string` | Prepends the string specified in the modifier to the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
 * | `slug_builder` | `string`| Sets a part of the slug of the child product. Can only contain A-Z, a-z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. However, for the `slug-builder` modifier, you can use `{}` in the `seek` field, for example, `"seek": :{COLOR}"`. |
 * | `sku_equals` | `string` | Sets the SKU of the child product. |
 * | `sku_append` | `string` | Appends the string specified in the modifier to the SKU of the child product. |
 * | `sku_prepend` | `string` | Prepends the string specified in the modifier to the SKU of the child product. |
 * | `sku_builder` | `string` | Sets a part of the SKU of the child product. |
 * | `status` | `string` | Sets the status of the child product, such as `draft` or `live`. |
 *
 */
export const createModifier = <ThrowOnError extends boolean = false>(
  options: Options<CreateModifierData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateModifierResponse,
    CreateModifierError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/variations/{variationID}/options/{optionID}/modifiers",
  })
}

/**
 * Delete a modifier
 * You cannot delete a modifier if it is in use. Deleting a modifier in us returns a `422 Failed Validation` error.
 */
export const deleteModifier = <ThrowOnError extends boolean = false>(
  options: Options<DeleteModifierData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteModifierResponse,
    DeleteModifierError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/variations/{variationID}/options/{optionID}/modifiers/{modifierID}",
  })
}

/**
 * Get a modifier
 */
export const getModifier = <ThrowOnError extends boolean = false>(
  options: Options<GetModifierData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetModifierResponse,
    GetModifierError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/variations/{variationID}/options/{optionID}/modifiers/{modifierID}",
  })
}

/**
 * Update a modifier
 * Specify whichever attributes you want to change. The values of the other attributes remain the same. If the attributes section is empty, the modifier is not updated.
 */
export const updateModifier = <ThrowOnError extends boolean = false>(
  options: Options<UpdateModifierData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateModifierResponse,
    UpdateModifierError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/variations/{variationID}/options/{optionID}/modifiers/{modifierID}",
  })
}

/**
 * Get all hierarchies
 * Get all hierarchies
 *
 * #### Filtering
 *
 * Many Commerce API endpoints support filtering. The general syntax is described in [**Filtering**](/guides/Getting-Started/filtering).
 *
 * The following attributes and operators are supported.
 *
 * | Operator        | Attribute                                                                                 | Description                                                                                      | Example                                  |
 * |----------------|------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|------------------------------------------|
 * | `eq`           | `id`, `hierarchy_id`, `owner`, `parent_id`, `name`, `slug`, `description`, `has_children`, `created_at`, `updated_at`, `locales.[locale].name`, `locales.[locale].description`, `breadcrumbs.id`, `breadcrumbs.name`, `breadcrumbs.slug`, `breadcrumbs.locales.[locale].name` | Equals. Checks if the value of the attribute matches the specified value. | `filter=eq(name,some-name)`, `filter=eq(locales.fr-FR.name,Nom-du-produit)` |
 * | `in`           | `id`, `hierarchy_id`,  `parent_id`, `breadcrumbs.id`                                              | Checks if the value of the attribute is included in the specified list.                        | `filter=in(id,1,2,3,4)`                 |
 * | `lt`, `le`, `gt`, `ge` | `id`, `hierarchy_id`,  `parent_id`, `created_at`, `updated_at`         | Comparison operators. `lt`: Less than, `le`: Less than or equal to, `gt`: Greater than, `ge`: Greater than or equal to. | `filter=lt(id,100)`, `filter=ge(created_at,2022-01-01)` |
 * | `like`         | `name`, `slug`, `description`, `locales.[locale].name`, `locales.[locale].description`, `breadcrumbs.name`, `breadcrumbs.slug`, `breadcrumbs.locales.[locale].name` | Like. Checks if the attribute contains the specified string (wildcards supported).            | `filter=like(name,*some-name*)`, `filter=like(locales.es-ES.description,*descripción*)` |
 *
 */
export const getHierarchy = <ThrowOnError extends boolean = false>(
  options?: Options<GetHierarchyData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetHierarchyResponse,
    GetHierarchyError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies",
  })
}

/**
 * Create a hierarchy
 * ```mdx-code-block
 * import CASummary from '/docs/partials/pxm/custom-attributes/custom-attribute-spec-summary.mdx';
 *
 * Creates a hierarchy with a name, description, and slug to organize products in your catalog.
 *
 * <CASummary />
 * ```
 *
 */
export const createHierarchy = <ThrowOnError extends boolean = false>(
  options: Options<CreateHierarchyData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateHierarchyResponse,
    CreateHierarchyError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies",
  })
}

/**
 * List all nodes
 * A fully paginated view of all nodes in all hierarchies regardless of depth.
 *
 * #### Filtering
 *
 * Many Commerce API endpoints support filtering. The general syntax is described in [**Filtering**](/guides/Getting-Started/filtering).
 *
 * The following attributes and operators are supported.
 *
 * | Operator        | Attribute                                                                                 | Description                                                                                      | Example                                  |
 * |----------------|------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|------------------------------------------|
 * | `eq`           | `id`, `hierarchy_id`, `owner`, `parent_id`, `name`, `slug`, `description`, `has_children`, `created_at`, `updated_at`, `locales.[locale].name`, `locales.[locale].description`, `breadcrumbs.id`, `breadcrumbs.name`, `breadcrumbs.slug`, `breadcrumbs.locales.[locale].name` | Equals. Checks if the value of the attribute matches the specified value. | `filter=eq(name,some-name)`, `filter=eq(locales.fr-FR.name,Nom-du-produit)` |
 * | `in`           | `id`, `hierarchy_id`,  `parent_id`, `breadcrumbs.id`                                              | Checks if the value of the attribute is included in the specified list.                        | `filter=in(id,1,2,3,4)`                 |
 * | `lt`, `le`, `gt`, `ge` | `id`, `hierarchy_id`,  `parent_id`, `created_at`, `updated_at`         | Comparison operators. `lt`: Less than, `le`: Less than or equal to, `gt`: Greater than, `ge`: Greater than or equal to. | `filter=lt(id,100)`, `filter=ge(created_at,2022-01-01)` |
 * | `like`         | `name`, `slug`, `description`, `locales.[locale].name`, `locales.[locale].description`, `breadcrumbs.name`, `breadcrumbs.slug`, `breadcrumbs.locales.[locale].name` | Like. Checks if the attribute contains the specified string (wildcards supported).            | `filter=like(name,*some-name*)`, `filter=like(locales.es-ES.description,*descripción*)` |
 *
 */
export const getAllNodes = <ThrowOnError extends boolean = false>(
  options?: Options<GetAllNodesData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllNodesResponse,
    GetAllNodesError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/nodes",
  })
}

/**
 * Delete a hierarchy
 * Deletes the specified hierarchy and all its children.
 */
export const deleteHierarchy = <ThrowOnError extends boolean = false>(
  options: Options<DeleteHierarchyData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteHierarchyResponse,
    DeleteHierarchyError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}",
  })
}

/**
 * Get a hierarchy
 * Retrieves the specified hierarchy.
 */
export const getHierarchyChild = <ThrowOnError extends boolean = false>(
  options: Options<GetHierarchyChildData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetHierarchyChildResponse,
    GetHierarchyChildError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}",
  })
}

/**
 * Update a hierarchy
 * ```mdx-code-block
 * import CASummary from '/docs/partials/pxm/custom-attributes/custom-attribute-spec-summary.mdx';
 *
 * Updates a hierarchy. You can do a partial update, where you specify only the field value to change.
 *
 * <CASummary />
 * ```
 *
 */
export const updateHierarchy = <ThrowOnError extends boolean = false>(
  options: Options<UpdateHierarchyData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateHierarchyResponse,
    UpdateHierarchyError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}",
  })
}

/**
 * Get all nodes in a hierarchy
 * A fully paginated view of all nodes in a hierarchy regardless of depth.
 *
 * #### Filtering
 *
 * Many Commerce API endpoints support filtering. The general syntax is described in [**Filtering**](/guides/Getting-Started/filtering).
 *
 * The following attributes and operators are supported.
 *
 * | Operator        | Attribute                                                                                 | Description                                                                                      | Example                                  |
 * |----------------|------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|------------------------------------------|
 * | `eq`           | `id`, `hierarchy_id`, `owner`, `parent_id`, `name`, `slug`, `description`, `has_children`, `created_at`, `updated_at`, `locales.[locale].name`, `locales.[locale].description`, `breadcrumbs.id`, `breadcrumbs.name`, `breadcrumbs.slug`, `breadcrumbs.locales.[locale].name` | Equals. Checks if the value of the attribute matches the specified value. | `filter=eq(name,some-name)`, `filter=eq(locales.fr-FR.name,Nom-du-produit)` |
 * | `in`           | `id`, `hierarchy_id`,  `parent_id`, `breadcrumbs.id`                                              | Checks if the value of the attribute is included in the specified list.                        | `filter=in(id,1,2,3,4)`                 |
 * | `lt`, `le`, `gt`, `ge` | `id`, `hierarchy_id`,  `parent_id`, `created_at`, `updated_at`         | Comparison operators. `lt`: Less than, `le`: Less than or equal to, `gt`: Greater than, `ge`: Greater than or equal to. | `filter=lt(id,100)`, `filter=ge(created_at,2022-01-01)` |
 * | `like`         | `name`, `slug`, `description`, `locales.[locale].name`, `locales.[locale].description`, `breadcrumbs.name`, `breadcrumbs.slug`, `breadcrumbs.locales.[locale].name` | Like. Checks if the attribute contains the specified string (wildcards supported).            | `filter=like(name,*some-name*)`, `filter=like(locales.es-ES.description,*descripción*)` |
 *
 */
export const getAllNodesInHierarchy = <ThrowOnError extends boolean = false>(
  options: Options<GetAllNodesInHierarchyData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllNodesInHierarchyResponse,
    GetAllNodesInHierarchyError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}/nodes",
  })
}

/**
 * Create a node
 * ```mdx-code-block
 * import CASummary from '/docs/partials/pxm/custom-attributes/custom-attribute-spec-summary.mdx';
 *
 * Creates a node in the specified hierarchy.
 *
 * <CASummary />
 * ```
 *
 * ### Sorting Nodes in a Hierarchy
 *
 * You can sort the order of your nodes, regardless of where the nodes are in the hierarchy.
 *
 * You can do this by adding a `meta` object to the body of your request and specifying a `sort_order` value.
 *
 * The node with the highest value of `sort_order` is displayed first. For example, a node with a `sort_order` value of `3` appears before a node with a `sort_order` value of `2`.
 *
 * - If you don’t provide `sort_order` when creating nodes, all child nodes in the response for Get a Node’s Children request are ordered by the `updated_at` time in descending order, with the most recently updated child node first.
 * - If you set `sort_order` for only a few child nodes, the child nodes with a `sort_order` value appear first and then other child nodes appear in the order of `updated_at` time.
 *
 * You can also specify a `sort_order` when creating a node relationship.
 *
 * - If you create a node (**Node A**) with a `sort_order` and then you create a relationship for **Node A** with another node (**Node B**), the `sort_order` you specified when creating **Node A** is overwritten.
 * - If you create **Node A** and then you create a relationship with **Node B** but do not configure a `sort_order`, the `sort_order` you specified when you created **Node A** is not overwritten.
 *
 * ### Curating Products in a Node
 *
 * You can curate the products in a node. Product curation allows you to promote specific products within each node of your hierarchies, enabling you to create unique product collections in your storefront. For example, you may find you have an abundance of cotton T-Shirts and you want to promote these products to the top of the product list. When a shopper navigates to T-shirts, the cotton T-Shirts are displayed first.
 *
 * You can do this by adding a `curated_products` attribute to the body of your request and adding an array of product IDs to the attribute. You should add the products IDs in the order you want them to be displayed in your node. The first product ID is displayed first in the product list.
 *
 * You can only curate 20 products or less. You cannot have more than 20 curated products.
 *
 * - The product IDs you provide must exist in the specified node.
 * - If a curated product is removed from a node, the product is also removed from the curated_products list.
 * - Once you have curated the products in a node, you can use the get node products endpoint to retrieve a list of curated products.
 *
 * You can then display your curated products in your catalogs using the following catalog endpoints.
 *
 * - Get a node in your latest catalog release.
 * - Get a node in a catalog.
 * - Get all nodes in your latest catalog release.
 * - Get all nodes in a catalog.
 * - Get node children in your latest catalog release.
 * - Get node children in a catalog.
 *
 */
export const createNode = <ThrowOnError extends boolean = false>(
  options: Options<CreateNodeData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateNodeResponse,
    CreateNodeError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}/nodes",
  })
}

/**
 * Deletes a node
 * Deletes a node by the node ID
 */
export const deleteNode = <ThrowOnError extends boolean = false>(
  options: Options<DeleteNodeData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteNodeResponse,
    DeleteNodeError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}",
  })
}

/**
 * Get a node
 * Retrieves a node from a hierarchy.
 */
export const getHierarchyNode = <ThrowOnError extends boolean = false>(
  options: Options<GetHierarchyNodeData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetHierarchyNodeResponse,
    GetHierarchyNodeError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}",
  })
}

/**
 * Update a node
 * ```mdx-code-block
 * import CASummary from '/docs/partials/pxm/custom-attributes/custom-attribute-spec-summary.mdx';
 *
 * Updates the specified node in a hierarchy. You can do a partial update, where you specify only the field value to change.
 *
 * <CASummary />
 * ```
 *
 * ### Sorting Nodes in a Hierarchy
 *
 * You can sort the order of your nodes, regardless of where the nodes are in the hierarchy.
 *
 * The node with the highest value of sort_order is displayed first. For example, a node with a `sort_order` value of `3` appears before a node with a `sort_order` value of `2`.
 *
 * - If you don’t provide `sort_order` when creating nodes, all child nodes in the response for Get a Node’s Children request are ordered by the `updated_at` time in descending order, with the most recently updated child node first.
 * - If you set `sort_order` for only a few child nodes or not all, the child nodes with a `sort_order` value appear first and then other child nodes appear in the order of `updated_at` time.
 *
 * You can also specify a sort_order when creating a node relationship.
 *
 * - If you update a node (**Node A**) with a `sort_order` and then you create a relationship for **Node A** with another node (**Node B**), the `sort_order` you specified when updating **Node A** is overwritten.
 * - If you have updated **Node A** and then you create a relationship with **Node B** but do not configure a `sort_order`, the `sort_order` you specified when you updated **Node A** is not overwritten.
 *
 * ### Curating Products in a Node
 *
 * You can curate the products in a node. Product curation allows you to promote specific products within each node of your hierarchies, enabling you to create unique product collections in your storefront. For example, you may find you have an abundance of cotton T-Shirts and you want to promote these products to the top of the product list. When a shopper navigates to T-shirts, the cotton T-Shirts are displayed first.
 *
 * You can do this by adding a `curated_products` attribute to the body of your request and adding an array of product IDs to the attribute. You should add the products IDs in the order you want them to be displayed in your node. The first product ID is displayed first in the product list.
 *
 * You can only curate 20 products or less. You cannot have more than 20 curated products.
 *
 * - The product IDs you provide must exist in the specified node.
 * - If a curated product is removed from a node, the product is also removed from the curated_products list.
 * - Once you have curated the products in a node, you can use the get node products endpoint to retrieve a list of curated products.
 *
 * You can then display your curated products in your catalogs using the following catalog endpoints.
 *
 * - [Get a node in your latest catalog release](/docs/api/pxm/catalog/get-node)
 * - [Get a node in a catalog](/docs/api/pxm/catalog/get-by-context-node)
 * - [Get all nodes in your latest catalog release](/docs/api/pxm/catalog/get-all-nodes)
 * - [Get all nodes in a catalog](/docs/api/pxm/catalog/get-by-context-all-nodes)
 * - [Get node children in your latest catalog release](/docs/api/pxm/catalog/get-child-nodes)
 * - [Get node children in a catalog](/docs/api/pxm/catalog/get-by-context-child-nodes)
 *
 */
export const updateNode = <ThrowOnError extends boolean = false>(
  options: Options<UpdateNodeData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateNodeResponse,
    UpdateNodeError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}",
  })
}

/**
 * Get a hierarchy's children
 * Get a hierarchy's children
 *
 * #### Filtering
 *
 * Many Commerce API endpoints support filtering. The general syntax is described in [**Filtering**](/guides/Getting-Started/filtering).
 *
 * The following attributes and operators are supported.
 *
 * | Operator        | Attribute                                                                                 | Description                                                                                      | Example                                  |
 * |----------------|------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|------------------------------------------|
 * | `eq`           | `id`, `hierarchy_id`, `owner`, `parent_id`, `name`, `slug`, `description`, `has_children`, `created_at`, `updated_at`, `locales.[locale].name`, `locales.[locale].description`, `breadcrumbs.id`, `breadcrumbs.name`, `breadcrumbs.slug`, `breadcrumbs.locales.[locale].name` | Equals. Checks if the value of the attribute matches the specified value. | `filter=eq(name,some-name)`, `filter=eq(locales.fr-FR.name,Nom-du-produit)` |
 * | `in`           | `id`, `hierarchy_id`,  `parent_id`, `breadcrumbs.id`                                              | Checks if the value of the attribute is included in the specified list.                        | `filter=in(id,1,2,3,4)`                 |
 * | `lt`, `le`, `gt`, `ge` | `id`, `hierarchy_id`,  `parent_id`, `created_at`, `updated_at`         | Comparison operators. `lt`: Less than, `le`: Less than or equal to, `gt`: Greater than, `ge`: Greater than or equal to. | `filter=lt(id,100)`, `filter=ge(created_at,2022-01-01)` |
 * | `like`         | `name`, `slug`, `description`, `locales.[locale].name`, `locales.[locale].description`, `breadcrumbs.name`, `breadcrumbs.slug`, `breadcrumbs.locales.[locale].name` | Like. Checks if the attribute contains the specified string (wildcards supported).            | `filter=like(name,*some-name*)`, `filter=like(locales.es-ES.description,*descripción*)` |
 *
 */
export const getAllChildren = <ThrowOnError extends boolean = false>(
  options: Options<GetAllChildrenData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllChildrenResponse,
    GetAllChildrenError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}/children",
  })
}

/**
 * Create relationships between a hierarchy and child nodes
 * Use this endpoint to create relationships between a hierarchy and one or more child nodes. You can create a relationship only if:
 *
 * - All child nodes already exist.
 * - Every child node in the request body must belong to this hierarchy.
 * - All siblings in a hierarchy must have a unique `name` and `slug`. Siblings are the child nodes that are related to the same parent.
 *
 * ### Sort Order
 *
 * You can also provide `sort_order` information when you create a relationship by adding a `meta` object to the array of node reference objects for each child node that requires sorting.
 *
 * The node with the highest value of `sort_order` appears at the top of the response. For example, a node with a `sort_order` value of `3` appears before a node with a `sort_order` value of `2`.
 *
 * - If you don’t provide `sort_order` when creating relationships, all child nodes in the response for Get a Hierarchy’s Children request are ordered by the `updated_at` time in descending order. The most recently updated child node appears at the top of the response.
 * - If you set `sort_order` for only a few child nodes or not all, the child nodes with `sort_order` value appear first in the response and then other child nodes appear in the order of `updated_at` time.
 *
 * You can also specify a `sort_order` when creating and updating a node.
 *
 * - If you create or update a node (**Node A**) with a `sort_order` and then you create a relationship for **Node A** with hierarchy (**Hierarchy A**) with a new `sort_order`, the `sort_order` you specified when creating\updating **Node A** is overwritten.
 * - If you create\update **Node A** and then you create a relationship with **Hierarchy A** but do not configure a `sort_order`, the `sort_order` you specified when you created\updated **Node A** is not overwritten.
 *
 */
export const createHierarchyChildRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<CreateHierarchyChildRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateHierarchyChildRelationshipsResponse,
    CreateHierarchyChildRelationshipsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}/relationships/children",
  })
}

/**
 * Create relationships between a node and child nodes
 * Use this endpoint to create relationships between a single parent node and one or more child nodes. You can create a relationship only if:
 *
 * - The parent node already exists.
 * - All child nodes already exist.
 * - Every child node in the body of the request exists in the same hierarchy as the parent node.
 * - A node is not a parent of itself. An array of child nodes request body must not contain the ID of the parent node in the path.
 * - All siblings in a hierarchy must have a unique `slug`. Siblings are the child nodes that are related to the same parent.
 *
 * ### Sort Order
 *
 * You can also provide `sort_order` information when you create a relationship by adding a `meta` object to the array of node reference objects for each child node that requires sorting.
 *
 * The node with the highest value of `sort_order` appears at the top of the response. For example, a node with a `sort_order` value of `3` appears before a node with a `sort_order` value of `2`.
 *
 * - If you don’t provide `sort_order` when creating relationships, all child nodes in the response for Get a Node’s Children request are ordered by the `updated_at` time in descending order. The most recently updated child node appears at the top of the response.
 * - If you set `sort_order` for only a few child nodes or not all, the child nodes with `sort_order` value appear first in the response and then other child nodes appear in the order of `updated_at` time.
 *
 * You can also specify a `sort_order` when creating and updating a node.
 *
 * - If you create or update a node (**Node A**) with a `sort_order` and then you create a relationship for **Node A** with another node (**Node B**) with a new `sort_order`, the `sort_order` you specified when creating\updating **Node A** is overwritten.
 * - If you create\update **Node A** and then you create a relationship with **Node B** but do not configure a `sort_order`, the `sort_order` you specified when you created\updated **Node A** is not overwritten.
 *
 */
export const createNodeChildRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<CreateNodeChildRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateNodeChildRelationshipsResponse,
    CreateNodeChildRelationshipsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/relationships/children",
  })
}

/**
 * Get a node's children
 * Retrieves the child nodes for a specified node.
 *
 * #### Filtering
 *
 * Many Commerce API endpoints support filtering. The general syntax is described in [**Filtering**](/guides/Getting-Started/filtering).
 *
 * The following attributes and operators are supported.
 *
 * | Operator        | Attribute                                                                                 | Description                                                                                      | Example                                  |
 * |----------------|------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|------------------------------------------|
 * | `eq`           | `id`, `hierarchy_id`, `owner`, `parent_id`, `name`, `slug`, `description`, `has_children`, `created_at`, `updated_at`, `locales.[locale].name`, `locales.[locale].description`, `breadcrumbs.id`, `breadcrumbs.name`, `breadcrumbs.slug`, `breadcrumbs.locales.[locale].name` | Equals. Checks if the value of the attribute matches the specified value. | `filter=eq(name,some-name)`, `filter=eq(locales.fr-FR.name,Nom-du-produit)` |
 * | `in`           | `id`, `hierarchy_id`,  `parent_id`, `breadcrumbs.id`                                              | Checks if the value of the attribute is included in the specified list.                        | `filter=in(id,1,2,3,4)`                 |
 * | `lt`, `le`, `gt`, `ge` | `id`, `hierarchy_id`,  `parent_id`, `created_at`, `updated_at`         | Comparison operators. `lt`: Less than, `le`: Less than or equal to, `gt`: Greater than, `ge`: Greater than or equal to. | `filter=lt(id,100)`, `filter=ge(created_at,2022-01-01)` |
 * | `like`         | `name`, `slug`, `description`, `locales.[locale].name`, `locales.[locale].description`, `breadcrumbs.name`, `breadcrumbs.slug`, `breadcrumbs.locales.[locale].name` | Like. Checks if the attribute contains the specified string (wildcards supported).            | `filter=like(name,*some-name*)`, `filter=like(locales.es-ES.description,*descripción*)` |
 *
 */
export const getAllNodeChildren = <ThrowOnError extends boolean = false>(
  options: Options<GetAllNodeChildrenData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllNodeChildrenResponse,
    GetAllNodeChildrenError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/children",
  })
}

/**
 * Delete a node's parent
 */
export const deleteNodeParent = <ThrowOnError extends boolean = false>(
  options: Options<DeleteNodeParentData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteNodeParentResponse,
    DeleteNodeParentError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/relationships/parent",
  })
}

/**
 * Update a node's parent
 * Changes the parent of the specified node. The new parent node must be located within the same hierarchy as the specified node.
 *
 * You cannot move a node to another hierarchy. If you want to put the specified node into another hierarchy, create the node in the target hierarchy and delete it from the current hierarchy.
 *
 */
export const updateNodeParent = <ThrowOnError extends boolean = false>(
  options: Options<UpdateNodeParentData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateNodeParentResponse,
    UpdateNodeParentError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/relationships/parent",
  })
}

/**
 * Deletes a node's product relationships
 */
export const deleteNodeProductRelationships = <
  ThrowOnError extends boolean = false,
>(
  options: Options<DeleteNodeProductRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteNodeProductRelationshipsResponse,
    DeleteNodeProductRelationshipsError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/relationships/products",
  })
}

/**
 * Create a node's product relationships
 * Creates relationships between the specified node and one or more products in a specified hierarchy.
 */
export const createNodeProductRelationship = <
  ThrowOnError extends boolean = false,
>(
  options: Options<CreateNodeProductRelationshipData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateNodeProductRelationshipResponse,
    CreateNodeProductRelationshipError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/relationships/products",
  })
}

/**
 * Get a node's products
 * Returns the products associated with the specified hierarchy node from a published catalog. Products must be in a live status. If the products have been curated using the update a hierarchy node endpoint, then the products are returned in the order specified in the `curated_products` attribute in the body of the update a hierarchy node request. A product that is curated has the "curated_product": true attribute displayed.
 *
 */
export const getNodeProducts = <ThrowOnError extends boolean = false>(
  options: Options<GetNodeProductsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetNodeProductsResponse,
    GetNodeProductsError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/products",
  })
}

/**
 * Duplicate a hierarchy
 * Using this option, you can duplicate an existing hierarchy. This is useful because it enables you to quickly and easily create multiple hierarchies with the same node structure.
 *
 * When you duplicate a hierarchy, you can specify a new name and/or a new description for the duplicated hierarchy. All other attributes, such as slug and locales, stay the same.
 *
 * Any nodes in the existing hierarchy are also replicated in the duplicated hierarchy. In addition, you can optionally use the `include_products` attribute to specify whether you want products associated with the nodes in an existing hierarchy to be associated with the nodes in the duplicated hierarchy. By default, product associations in an existing hierarchy are not duplicated in a duplicate hierarchy.
 *
 * Duplicating a hierarchy is an asynchronous operation. When you duplicate a hierarchy, a job is created. The jobId of the job is displayed in the response. When the job is complete, the duplicate hierarchy operation is also complete. You can use the jobId to see the status of your job using Get a Job.
 *
 * Jobs are processed one at a time. You can continue to send duplicate hierarchy requests, but those jobs are queued. In other words, Commerce looks for any jobs that have a status of PENDING and starts the job with the earliest created date. This process is repeated until all jobs are processed.
 *
 * Once the job is complete, run:
 *
 * - Get all hierarchies to retrieve the HierarchyId of your duplicated hierarchy.
 * - Get a hierarchy to retrieve the nodes and (if applicable) products associated with the duplicated hierarchy.
 *
 */
export const duplicateHierarchy = <ThrowOnError extends boolean = false>(
  options: Options<DuplicateHierarchyData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    DuplicateHierarchyResponse,
    DuplicateHierarchyError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/hierarchies/{hierarchyID}/duplicate_job",
  })
}

/**
 * Get All Product Tags
 * Retrieves all product tags for a store. A store can view the tags associated with the organization to which the store belongs. However, an organization can only view the tags associated with the organization.
 *
 */
export const getAllProductTags = <ThrowOnError extends boolean = false>(
  options?: Options<GetAllProductTagsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetAllProductTagsResponse,
    GetAllProductTagsError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/tags",
  })
}

/**
 * Get a Product Tag
 * Retrieves a product tag for a store. A store can view the tags associated with the organization to which the store belongs. However, an organization can only view the tags associated with the organization.
 */
export const getProductTag = <ThrowOnError extends boolean = false>(
  options: Options<GetProductTagData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetProductTagResponse,
    GetProductTagError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/tags/{tagID}",
  })
}

/**
 * Get all custom relationships
 * Gets all Custom Relationships.
 *
 * To see a list of custom relationships a product is attached to, see [Get all Custom Relationships attached to a Product](/docs/api/pxm/products/list-attached-custom-relationship).
 *
 * To see a list of products that a product is related to, see [Get all Related Products of a Products' attached Custom Relationship](/docs/api/pxm/products/get-related-products-of-a-product-id).
 *
 * ### Filtering
 *
 * Many Commerce API endpoints support filtering. The general syntax is described in [**Filtering**](/guides/Getting-Started/filtering).
 *
 * The following attributes and operators are supported.
 *
 * | Operator | Attribute | Description | Example |
 * | :--- |:---|:---|:---|
 * | `eq` | `owner`, `slug` | Equals. Checks if the values of two operands are equal. If they are, the condition is true. | `filter=eq(owner,store)` |
 * | `in` | `slug`          | In. Checks if a value exists in a given list of values. If the value matches any item in the list, the condition is true. | `filter=in(slug,slug-1,slug-2,slug-3)` |
 *
 */
export const getCustomRelationships = <ThrowOnError extends boolean = false>(
  options?: Options<GetCustomRelationshipsData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetCustomRelationshipsResponse,
    GetCustomRelationshipsError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/custom-relationships",
  })
}

/**
 * Create a custom relationship
 * Custom relationships can either be bi-directional or uni-directional.
 * - **Uni-Directional**: By setting `bi_directional` to `false` (or omitted from request) a uni-directional custom relationship will be created.
 * Within a uni-directional relationship, if Product A links to Product B, Product B will not link back to Product A.
 * This is ideal when one product (e.g., a base product) recommends another (e.g., an upsell), but the reverse
 * recommendation is unnecessary.
 *
 * - **Bi-Directional**: By setting `bi_directional` to `true` a bi-directional custom relationship will be created. Within a bi-directional
 * relationship, if Product A is linked to Product B, Product B will automatically link back to Product A.
 * This bi-directionality ensures a consistent experience, where products always suggest each other as related items.
 *
 * For more information on use cases, see [Custom Relationships](/guides/key-concepts/product-experience-manager/custom-relationships/).
 *
 * Custom Relationship slugs must meet the following criteria:
 * - be unique
 * - be prefixed with `CRP_`. Product Experience Manager automatically adds the `CRP_` prefix if you do not include it.
 * - contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed.
 *
 * Once a custom relationship has been created, you can:
 * 1. Add the custom relationship to a product. See [Attach a custom relationship to a product](/docs/api/pxm/products/attach-custom-relationships).
 * 2. Associate a product to multiple products. See [Associate a product with other products under a custom relationship](/docs/api/pxm/products/product-association-id).
 *
 */
export const createCustomRelationship = <ThrowOnError extends boolean = false>(
  options: Options<CreateCustomRelationshipData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateCustomRelationshipResponse,
    CreateCustomRelationshipError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/custom-relationships",
  })
}

/**
 * Delete a custom relationship
 * Deletes the specified custom relationship.
 *
 * Custom Relationships cannot be deleted if they are in use.
 *
 */
export const deleteCustomRelationship = <ThrowOnError extends boolean = false>(
  options: Options<DeleteCustomRelationshipData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteCustomRelationshipResponse,
    DeleteCustomRelationshipError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/custom-relationships/{customRelationshipSlug}",
  })
}

/**
 * Get a custom relationship
 * Gets a Custom Relationship.
 *
 * To see a list of custom relationships a product is attached to, see [Get all Custom Relationships attached to a Product](/docs/api/pxm/products/list-attached-custom-relationship).
 *
 * To see a list of products that a product is related to, see [Get all Related Products of a Products' attached Custom Relationship](/docs/api/pxm/products/get-related-products-of-a-product-id).
 *
 */
export const getCustomRelationship = <ThrowOnError extends boolean = false>(
  options: Options<GetCustomRelationshipData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    GetCustomRelationshipResponse,
    GetCustomRelationshipError,
    ThrowOnError
  >({
    ...options,
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/custom-relationships/{customRelationshipSlug}",
  })
}

/**
 * Update a custom relationship
 * Updates a custom relationship.
 *
 * A partial update can be performed, where you specify only the fields that need to be changed.
 *
 * The custom relationship slug cannot be updated.
 *
 */
export const updateCustomRelationship = <ThrowOnError extends boolean = false>(
  options: Options<UpdateCustomRelationshipData, ThrowOnError>,
) => {
  return (options?.client ?? client).put<
    UpdateCustomRelationshipResponse,
    UpdateCustomRelationshipError,
    ThrowOnError
  >({
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/pcm/custom-relationships/{customRelationshipSlug}",
  })
}
