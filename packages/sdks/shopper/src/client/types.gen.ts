// This file is auto-generated by @hey-api/openapi-ts

/**
 * The three-letter ISO code for the currency associated with this price.
 */
export type Amount = {
  /**
   * The price in the lowest denomination for the specified currency. This is a product's list price.
   */
  amount?: number
  /**
   * Whether this price includes tax.
   */
  includes_tax?: boolean
}

/**
 * If you want multiple price books for different scenarios, such as seasonal sales, business versus retail pricing, and reward programs, when creating a catalog, you can specify up to five price books. You must configure a priority for your price books. Product prices are displayed in the catalog according to the priority of the price books.
 */
export type PrioritizedPricebooks = Array<{
  /**
   * A unique identifier of a price book.
   */
  id: string
  /**
   * Priority is a number and the price book with the highest number has the highest priority.
   */
  priority: number
}>

/**
 * Creates a catalog with the following attributes.
 */
export type Catalog = {
  /**
   * A unique identifier of a catalog.
   */
  id: string
  attributes: {
    /**
     * The name of a catalog.
     */
    name: string
    /**
     * A brief description of the catalog, such as the purpose of the catalog.
     */
    description?: string
    /**
     * The unique identifiers of the hierarchies associated with a catalog.
     */
    hierarchy_ids: Array<string>
    /**
     * The unique identifier of a price book associated with a catalog. If no price book is selected, the catalog is displayed without prices.
     */
    pricebook_id?: string
    pricebook_ids?: PrioritizedPricebooks
    /**
     * Product Experience Manager supports localization of products and hierarchies. If you store supports multiple languages, you can localize product names and descriptions.
     */
    locales?: {
      [key: string]: {
        [key: string]: string
      }
    }
    /**
     * The date and time a catalog is created.
     */
    created_at: Date
    /**
     * The date and time a catalog was updated.
     */
    updated_at: Date
    /**
     * The owner of this resource, can be either `organization` or `store`.
     */
    owner?: "store" | "organization" | null
  }
  /**
   * Relationships are established between different catalog entities. For example, a catalog rule and a price book are related to a catalog, as both are associated with it.
   */
  relationships?: {
    /**
     * The catalog rules related to a catalog.
     */
    rules?: {
      links?: RelatedLink
    }
    /**
     * When a catalog is published, a catalog release is created. This is a URL to all catalog published releases available for this catalog.
     */
    releases?: {
      links?: RelatedLink
      meta?: {
        /**
         * The number releases available for a catalog.
         */
        count?: number
      }
    }
  }
  type: "catalog"
}

/**
 * The owner of this resource, can be either `organization` or `store`.
 */
export type owner = "store" | "organization"

export type type = "catalog"

/**
 * Creates a catalog with the following attributes.
 */
export type CatalogCreateData = {
  data: {
    attributes: {
      /**
       * The name of the catalog.
       */
      name: string
      /**
       * A brief description of the catalog.
       */
      description?: string | null
      /**
       * The unique identifiers of the hierarchies to associate with a catalog.
       */
      hierarchy_ids: Array<string>
      /**
       * The unique identifier of the price book to associate with this catalog. You can specify either a `pricebook_id` or `pricebook_ids` but not both. If you specify both a `pricebook_id` and `pricebook_ids`, a `422 Unprocessable Entity` error is displayed.
       *
       */
      pricebook_id?: string
      pricebook_ids?: PrioritizedPricebooks
      /**
       * Product Experience Manager supports localization of products and hierarchies. If you store supports multiple languages, you can localize product names and descriptions.
       */
      locales?: {
        [key: string]: {
          [key: string]: string
        }
      }
    }
    /**
     * Represents the type of object being returned. Always `Catalog`.
     */
    type: "catalog"
  }
}

/**
 * Container for a single catalog.
 */
export type CatalogData = {
  data: Catalog
  links?: Links
}

/**
 * Container for a list of catalogs.
 */
export type CatalogListData = {
  data: Array<Catalog>
  links?: Links
}

/**
 * A catalog combines price books, product lists, and hierarchies.
 */
export type CatalogUpdateData = {
  data: {
    attributes: {
      /**
       * The name of the catalog.
       */
      name?: string | null
      /**
       * A brief description of the catalog.
       */
      description?: string | null
      /**
       * The unique identifiers of the hierarchies to associate with a catalog.
       */
      hierarchy_ids?: Array<string> | null
      /**
       * The unique identifier of a price book to associate with a catalog. You can specify a `pricebook_id` or a `pricebook_ids` but not both. If you specify both, a `422 unprocessable entity` error is displayed.
       */
      pricebook_id?: string | null
      pricebook_ids?: PrioritizedPricebooks
      /**
       * Product Experience Manager supports localization of products and hierarchies. If you store supports multiple languages, you can localize product names and descriptions.
       */
      locales?: {
        [key: string]: {
          [key: string]: string
        }
      }
    }
    /**
     * The unique identifier of the catalog to be updated.
     */
    id: string
    /**
     * This represents the type of object being returned. Always `catalog`.
     */
    type: "catalog"
  }
}

/**
 * The unique identifier of the component, for example, `games`.
 */
export type ComponentProduct = {
  /**
   * The component name is the name that is displayed in your storefront.
   */
  name?: string
  /**
   * The minimum number of product options a shopper can select from this component.
   */
  min?: number | null
  /**
   * The maximum number of product options a shopper can select from this component.
   */
  max?: number | null
  /**
   * The sort order of the components. The `create a bundle` and `update a bundle` endpoints do not sort the components. You can use the `sort_order` attribute when programming your storefront to display the components in the order that you want.
   */
  sort_order?: number | null
  /**
   * The product options included in a component. This can be the ID of another bundle.
   */
  options?: Array<ComponentProductOption>
}

/**
 * The product options included in a component. This can be the ID of another bundle.
 */
export type ComponentProductOption = {
  /**
   * A unique identifier of the product you want to add to a component.
   */
  id?: string
  /**
   * This represents the type of object being returned. Always `product`.
   */
  type?: "product"
  /**
   * The number of this product option that a shopper must purchase.
   */
  quantity?: number
  /**
   * The sort order of the options. The `create a bundle` and `update a bundle` endpoints do not sort the options. You can use the `sort_order` attribute when programming your storefront to display the options in the order that you want.
   */
  sort_order?: number | null
  /**
   * The boolean indicates whether the current option is a default option for the component.
   */
  default?: boolean | null
}

/**
 * This represents the type of object being returned. Always `product`.
 */
export type type2 = "product"

/**
 * A bundle is a purchasable product, comprising of one or more products that you want to sell together. You can create multiple components within a bundle. Each component must have at least one or more options. Each option is a product and a quantity.
 */
export type Components = {
  [key: string]: ComponentProduct
}

/**
 * The length of the custom input text field.
 */
export type CustomInputValidationRuleOptions = {
  /**
   * The number of characters the custom text field can be. You can specify a maximum length up to 255 characters, as the limit is 255 characters.
   */
  max_length?: number
}

/**
 * The validation rules for the custom text.
 */
export type CustomInputValidationRule = {
  /**
   * This represents the type of object being returned. Must be `string`.
   */
  type?: "string"
  options?: CustomInputValidationRuleOptions
}

/**
 * This represents the type of object being returned. Must be `string`.
 */
export type type3 = "string"

/**
 * The name of the custom input. You can rename the input to something more representative of the input that shoppers are adding, for example, `message` or `front`.
 */
export type CustomInput = {
  /**
   * The name for the custom text field that is displayed in your storefront.
   */
  name?: string
  /**
   * The validation rules for the custom text.
   */
  validation_rules?: Array<CustomInputValidationRule>
  /**
   * This is `true` or `false` depending on whether the custom text is required.
   */
  required?: boolean | null
}

/**
 * You can allow your shoppers to add custom text to a product when adding product items to their carts. This is useful, for example, if you have a product like a T-shirt that can be personalized or you sell greetings cards that can be printed with your shoppers personalized messages.  You can do this using the `custom_inputs` attribute.
 *
 * - You can rename input to something more representative of the input that shoppers are adding, for example, `message` or `front`.
 * - `name` is the name that is displayed in your storefront.
 * - You can add validation rules. For example, the input field must be a string and/or up to 255 characters in length. The limit is 255 characters.
 *
 */
export type CustomInputs = {
  [key: string]: CustomInput
}

/**
 * A collection of one or more currencies objects that consists of the [**three-letter ISO code**](https://www.iso.org/iso-3166-country-codes.html) of the currencies associated with this price and the amount. This is the product's price.
 */
export type Currencies = {
  [key: string]: Amount
}

/**
 * The optional price extension with values in string format, viewable by shoppers.
 */
export type ShopperAttributes = {
  [key: string]: string
}

/**
 * A list of differences between two releases.
 */
export type DiffListData = {
  data?: Array<ProductDiff>
  links?: Links
}

/**
 * A price formatted for display.
 */
export type DisplayPrice = {
  with_tax?: FormattedPrice
  without_tax?: FormattedPrice
}

/**
 * APIError is a json-api style part of an error response.
 */
export type Error = {
  detail?: string
  status?: string
  title?: string
}

/**
 * ErrorResponse is a json-api style Error response.
 */
export type ErrorResponse = {
  errors?: Array<Error>
}

/**
 * The name of the product template.
 */
export type Extension = {
  [key: string]: {
    [key: string]: unknown
  }
}

/**
 * With extension templates, you can attach a specific set of custom fields to your products in Product Experience Manager. For example, a **Book** template might contain the attributes, such as **ISBN**, **Author**, **Number of pages**, **Year Published**, or **Condition (New/Used)**.
 */
export type Extensions = {
  [key: string]: Extension
}

/**
 * In Product Experience Manager, products can have associated rich media assets, such as product images or a file containing additional product details.
 */
export type FileReference = {
  /**
   * This represents the type of object being returned. Always `file`.
   */
  type?: "file"
  /**
   * A unique identifier for a file.
   */
  id?: string
  /**
   * The date and time a file is created.
   */
  created_at?: Date
}

/**
 * This represents the type of object being returned. Always `file`.
 */
export type type4 = "file"

/**
 * In Product Experience Manager, products can have associated rich media assets, such as product images or a file containing additional product details.
 */
export type FilesRelationship = {
  data?: Array<FileReference>
}

/**
 * A bundle is a purchasable product, comprising of one or more products that you want to sell together. You can create multiple components within a bundle. Each component must have at least one or more options. Each option is a product and a quantity. You can link to the products that make up your bundle components.
 */
export type ComponentProductsRelationship = {
  data?: ProductReferences
  links?: SelfLink
}

/**
 * A price formatted for display.
 */
export type FormattedPrice = {
  /**
   * The price in the lowest denomination for the specified currency. This is a product's list price.
   */
  amount?: number
  /**
   * The three-letter ISO code of the currencies associated with this price and the amount.
   */
  currency?: string
  /**
   * The format of the price for display.
   */
  formatted?: string
}

/**
 * A category hierarchy in a catalog. Hierarchies can have parent nodes and child nodes, as well as a list of attached products.
 */
export type Hierarchy = {
  attributes?: HierarchyAttributes
  /**
   * A unique identifier of a hierarchy.
   */
  id?: string
  relationships?: HierarchyRelationships
  /**
   * This represents the type of object being returned. Always `hierarchy`.
   */
  type?: string
  meta?: HierarchyMeta
}

/**
 * A hierarchy's metadata.
 */
export type HierarchyMeta = {
  /**
   * Product Experience Manager supports localization of hierarchies. If your store supports multiple languages, you can localize hierarchy names and descriptions. This is [**three-letter language code**](https://www.iso.org/iso-639-language-code) that represents the name of the language you have used.
   */
  language?: string
}

/**
 * Resource attributes of a catalog hierarchy.
 */
export type HierarchyAttributes = {
  /**
   * The date and time a hierarchy is created.
   */
  created_at?: Date
  /**
   * The date and time a hierarchy is published in a catalog.
   */
  published_at?: Date | null
  /**
   * A description of a hierarchy.
   */
  description?: string
  /**
   * The name of a hierarchy.
   */
  name?: string
  /**
   * A unique slug for a hierarchy.
   */
  slug?: string
  /**
   * The date and time a hierarchy was updated.
   */
  updated_at?: Date
}

/**
 * Container for hierarchies.
 */
export type HierarchyData = {
  data?: Hierarchy
  links?: Links
}

/**
 * Container for a list of hierarchies.
 */
export type HierarchyListData = {
  meta?: PageMeta
  data?: Array<Hierarchy>
  links?: Links
}

/**
 * Relationships to child nodes, and products.
 */
export type HierarchyRelationships = {
  /**
   * A URL to all the products associated with a hierarchy.
   */
  products?: {
    links?: RelatedLink
  }
  /**
   * A URL to all the child products associated with a hierarchy.
   */
  children?: {
    links: RelatedLink
  }
  /**
   * A URL to all the nodes associated with a hierarchy.
   */
  nodes?: {
    links: RelatedLink
  }
}

/**
 * Links allow you to move between requests.
 */
export type Links = {
  /**
   * Single entities use a `self` parameter with a link the specific resource.
   */
  self?: string | null
  /**
   * Always the first page.
   */
  first?: string | null
  /**
   * This is `null` if there is only one page.
   */
  last?: string | null
  /**
   * This is `null` if there is only one page.
   */
  prev?: string | null
  /**
   * This is `null` if there is only one page.
   */
  next?: string | null
}

/**
 * Included is an array of resources that are included in the response.
 */
export type Included = {
  /**
   * The main images associated with a product.
   */
  main_images?: Array<File>
  /**
   * The component products associated with a product.
   */
  component_products?: Array<Product>
  /**
   * The files associated with a product.
   */
  files?: Array<File>
}

/**
 * In Product Experience Manager, products can also have associated product images.
 */
export type MainImageRelationship = {
  /**
   * The images associated with a product.
   */
  data?: {
    /**
     * This represents the type of object being returned. Always `main_image`.
     */
    type?: "main_image"
    /**
     * A unique identifier for an image.
     */
    id?: string
  }
}

/**
 * This represents the type of object being returned. Always `main_image`.
 */
export type type5 = "main_image"

/**
 * A category node in a catalog. Nodes can have child nodes, as well as a list of attached products.
 */
export type Node = {
  attributes?: NodeAttributes
  /**
   * The unique identifier of a node.
   */
  id?: string
  relationships?: NodeRelationships
  /**
   * This represents the type of object being returned. Always `node`.
   */
  type?: string
  meta?: NodeMeta
}

/**
 * Resource attributes of a catalog node.
 */
export type NodeAttributes = {
  /**
   * The date and time a node was created.
   */
  created_at?: Date
  /**
   * The date and time a node was published in a catalog.
   */
  published_at?: Date | null
  /**
   * A description of a node.
   */
  description?: string
  label?: string
  /**
   * The name of a node. Names must be unique among sibling nodes in a hierarchy. Otherwise, a name can be non-unique within the hierarchy and across multiple hierarchies.
   */
  name?: string
  /**
   * A slug for the node. Slugs must be unique among sibling nodes in the hierarchy. Otherwise, a slug can be non-unique within the hierarchy and across multiple hierarchies.
   */
  slug?: string
  /**
   * A list of curated products for a node. You can curate your products in your nodes product lists. Product curation allows you to promote specific products within each node in a hierarchy, enabling you to create unique product collections in your storefront.
   */
  curated_products?: Array<string>
  status?: string
  /**
   * The date and time a node was updated.
   */
  updated_at?: Date
}

/**
 * Container for nodes.
 */
export type NodeCreateData = {
  /**
   * A node in a catalog (e.g. a category node). Nodes can have child nodes, as well as a list of attached products
   */
  data: {
    /**
     * Resource attributes of a catalog node.
     */
    attributes: {
      description?: string
      /**
       * hierarchy id of the node
       */
      hierarchy_id?: string
      label?: string
      name: string
      slug?: string
      status?: string
      locales?: {
        [key: string]: {
          [key: string]: string
        }
      }
    }
    relationships?: NodeRelationships
    id?: string
    type: string
  }
  links?: Links
}

/**
 * Container for nodes.
 */
export type NodeData = {
  data?: Node
  links?: Links
}

/**
 * Container for a list of nodes.
 */
export type NodeListData = {
  meta?: PageMeta
  data?: Array<Node>
  links?: Links
}

/**
 * A node's metadata.
 */
export type NodeMeta = {
  /**
   * The node details localized in the supported languages.
   */
  language?: string
  /**
   * Helps you understand the association of products with nodes. It explains how products are associated with parent nodes and the relationship among the array of nodes. This is useful if you want to improve how your shoppers search within you store.
   */
  bread_crumb?: Array<string>
}

/**
 * Minimum set of information to identify a catalog node.
 */
export type NodeReference = {
  /**
   * The unique identifier of a hierarchy.
   */
  id?: string
  /**
   * A label for a hierarchy.
   */
  label?: string
  /**
   * The name of a hierarchy.
   */
  name?: string
}

/**
 * Relationships to parent and child nodes, and products.
 */
export type NodeRelationships = {
  /**
   * A URL to all products associated with a node.
   */
  products?: {
    data?: Array<ProductReference>
    links?: RelatedLink
  }
  /**
   * A URL to all child nodes associated with a node.
   */
  children?: {
    links: RelatedLink
  }
  /**
   * A URL to all parent nodes associated with a node.
   */
  parent?: {
    data: {
      type: "node"
      id: string
    }
    links?: RelatedLink
  }
  /**
   * A URL to the hierarchies associated with a node.
   */
  hierarchy?: {
    data: {
      type: "hierarchy"
      id: string
    }
    links?: RelatedLink
  }
}

export type type6 = "node"

/**
 * Container for node relationships.
 */
export type NodeRelationshipsData = {
  data?: NodeRelationships
  links?: Links
}

/**
 * Contains the results for the entire collection.
 */
export type PageMeta = {
  /**
   * Total number of results for the entire collection.
   */
  results?: {
    /**
     * Total number of results for the entire collection.
     */
    total?: number
  }
  page?: {
    /**
     * The maximum number of records for all pages.
     */
    limit?: number
    /**
     * The current offset by number of pages.
     */
    offset?: number
    /**
     * The current number of pages.
     */
    current?: number
    /**
     * The total number of records for the entire collection.
     */
    total?: number
  }
}

/**
 * Top level entity in the pricebooks domain model. It contains a list of product prices.
 */
export type Pricebook = {
  /**
   * The unique identifier of a price book.
   */
  id?: string
  /**
   * This represents the type of object being returned. Always `pricebook`.
   */
  type: "pricebook"
  attributes: {
    created_at?: Date
    description?: string | null
    name: string | null
    updated_at?: Date
  }
}

/**
 * This represents the type of object being returned. Always `pricebook`.
 */
export type type7 = "pricebook"

/**
 * Container for pricebooks.
 */
export type PricebookCreateData = {
  /**
   * New top level pricebook.
   */
  data: {
    type: "pricebook"
    attributes: {
      description?: string | null
      name: string | null
    }
  }
  links?: Links
}

/**
 * Container for pricebooks.
 */
export type PricebookData = {
  data: Pricebook
  links?: Links
}

/**
 * ProductPrice associates a collection of locale specific prices with a product ID.
 */
export type PricebookPrice = {
  type: "product-price"
  attributes: {
    currencies: TieredCurrencies
    sales?: Sales
    sku: string
  }
  id: string
}

export type type8 = "product-price"

/**
 * Container for pricebook prices.
 */
export type PricebookPriceCreateData = {
  /**
   * ProductPrice associates a collection of locale specific prices with a product ID.
   */
  data: {
    type: "product-price"
    attributes: {
      currencies: TieredCurrencies
      sales?: Sales
      sku: string
    }
  }
  links?: Links
}

/**
 * Container for pricebook prices.
 */
export type PricebookPriceData = {
  data: PricebookPrice
  links?: Links
}

/**
 * A product in a catalog with the following attributes.
 */
export type Product = {
  attributes?: ProductAttributes
  /**
   * A unique identifier for a product.
   */
  id?: string
  relationships?: ProductRelationships
  /**
   * This represents the type of object being returned. Always `product`.
   */
  type?: string
  meta?: ProductMeta
}

/**
 * A product's attributes.
 */
export type ProductAttributes = {
  /**
   * The date and time a product was published in a catalog.
   */
  published_at?: Date | null
  /**
   * If this product is a `parent` product. A `parent` product is a product that has child products that have been built using the `build child products` endpoint.
   */
  base_product?: boolean
  /**
   * The unique identifier of a `parent` product.
   */
  base_product_id?: string
  /**
   * The commodity type, either `physical` or `digital`.
   */
  commodity_type?: string
  /**
   * If a product is curated, then the `curated_product` attribute with a value of `true` is displayed. If a product is not curated, the `curated_product` attribute is not displayed.
   */
  curated_product?: boolean
  /**
   * The universal product code or european article number of the product.
   */
  upc_ean?: string
  /**
   * The manufacturer part number of the product.
   */
  manufacturer_part_num?: string
  /**
   * A list of tags associated with the product. A tag must be HTML compatible characters excluding commas and will be stored in lowercase letters.
   */
  tags?: Array<string>
  /**
   * A list of price modifier names.
   */
  price_modifiers?: Array<string>
  /**
   * The date and time a product was created.
   */
  created_at?: Date
  /**
   * A description of the product.
   */
  description?: string
  /**
   * A name of a product.
   */
  name?: string
  price?: Currencies
  shopper_attributes?: ShopperAttributes
  tiers?: Tiers
  components?: Components
  custom_inputs?: CustomInputs
  /**
   * The unique stock keeping unit of the product.
   */
  sku?: string
  /**
   * A label for the product that is used in the URL paths. A slug can contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. By default, the product name is used as the slug.
   */
  slug?: string
  /**
   * The status of the product, either `live` or `draft`.
   */
  status?: string
  /**
   * The unique attribute associated with the product. This could be an external reference from a separate company system, for example.
   */
  external_ref?: string | null
  /**
   * The date and time a product was updated.
   */
  updated_at?: Date
  extensions?: Extensions
}

/**
 * Container for products.
 */
export type ProductCreateData = {
  /**
   * A new product in a catalog.
   */
  data?: {
    /**
     * A product's attributes.
     */
    attributes: {
      description?: string
      name: string
      sku?: string
      slug?: string
      status: string
      locales?: {
        [key: string]: {
          [key: string]: string
        }
      }
    }
    id?: string
    type: string
  }
  links?: Links
}

/**
 * Container for products.
 */
export type ProductData = {
  data?: Product
  links?: Links
  included?: Included
}

export type ProductDiff = {
  id?: string
  type?: string
  attributes?: {
    sku?: string
    this_release_id?: string
    other_release_id?: string
    diff_created_at?: Date
    exists?: {
      this: boolean
      other: boolean
    }
    updated_at?: {
      this?: Date | null
      other?: Date | null
    }
  }
}

/**
 * Container for a list of products.
 */
export type ProductListData = {
  meta?: PageMeta
  data?: Array<Product>
  links?: Links
}

/**
 * A product's metadata contains information about products, for example, the nodes a product is associated with, any child products, bundle configurations, and so on.
 */
export type ProductMeta = {
  /**
   * The relationship among the array of nodes a product is associated with, demonstrating the linking of the children nodes with the parent nodes. Up to 10 levels of parent nodes are displayed, depending on the number of levels of parent nodes you have.
   */
  bread_crumbs?: {
    [key: string]: Array<string>
  }
  /**
   * An array of parent node IDs that a product is associated with. Up to 10 levels of parent nodes are displayed, depending on the number of levels of parent nodes you have.
   */
  bread_crumb_nodes?: Array<string>
  /**
   * A unique identifier of the catalog a product is associated with.
   */
  catalog_id?: string
  /**
   * The unique identifier of the price book a product is associated with.
   */
  pricebook_id?: string | null
  display_price?: DisplayPrice
  /**
   * The source of a catalog. Always `pim`.
   */
  catalog_source?: "pim"
  /**
   * With sales pricing, a store can optionally add a sale price to a product price. For example, a store can schedule seasonal pricing on products without creating a new price book and catalog ruleset. Optionally, a store can schedule the date ranges for the sale products. This is the unique identifier of a sale.
   */
  sale_id?: string
  /**
   * The date and time a sale expires.
   */
  sale_expires?: Date | null
  original_price?: Currencies
  original_display_price?: DisplayPrice
  bundle_configuration?: BundleConfiguration
  /**
   * A bundle is a purchasable product, comprising of one or more products that you want to sell together. You can create multiple components within a bundle. Each component must have at least one or more options. Each option is a product and a quantity.
   */
  component_products?: {
    [key: string]: {
      /**
       * With sales pricing, a store can optionally add a sale price to a product price. For example, a store can schedule seasonal pricing on products without creating a new price book and catalog ruleset. Optionally, a store can schedule the date ranges for the sale products. This is the unique identifier of a sale.
       */
      sale_id?: string
      /**
       * The date and time a sale expires.
       */
      sale_expires?: Date | null
      price?: Currencies
      display_price?: DisplayPrice
      original_price?: Currencies
      original_display_price?: DisplayPrice
      pricebook_id?: string | null
    }
  }
  /**
   * You can use price modifiers to change the price property of child products. By default, child products inherit the same price as their base products. Using price modifiers, you can enable child products to inherit a different price.
   */
  price_modifiers?: {
    [key: string]: {
      /**
       * There are three modifier types.
       *
       * - The `price_increment` type increases the prices of a product.
       * - The `price_decrement` type decreases the price of a product.
       * - The `price_equals` type sets the price of a product to an amount you specify.
       *
       */
      modifier_type?: string
      currencies?: Currencies
    }
  }
  /**
   * You can use tiers to allow your store to offer different pricing for minimum quantities of items that your shoppers purchase.
   */
  tiers?: {
    [key: string]: {
      /**
       * The unique identifier of a sale.
       */
      sale_id?: string
      /**
       * The date and time a sale expires.
       */
      sale_expires?: Date | null
      display_price?: DisplayPrice
      original_price?: Currencies
      original_display_price?: DisplayPrice
    }
  }
  /**
   * The `variation_matrix` object lists the variation IDs and variation option IDs and their corresponding product IDs that are generated when the variation and variation options are built with a product. If no variations are available, the `variation_matrix` is empty.
   */
  variation_matrix?: {
    [key: string]: unknown
  }
  /**
   * If you specified `build_rules` for a product, the `variations` object lists the variation option IDs that you specified to include when building your child products. If no `build_rules` are specified, all the variation and variation options available for a product are displayed. If a product does not have any variations, then the `variations` object is not displayed.
   */
  variations?: Array<Variation>
  /**
   * An array of variation options IDs that a child product has.
   */
  child_option_ids?: Array<string> | null
  /**
   * If this is a child product, the `child_variations` object lists the variation option IDs that define this child product.
   */
  child_variations?: Array<Variation> | null
  /**
   * Commerce automatically assigns types to the products you create. In Commerce Manager, you can see at a glance the product types in a list of a products. In addition, you can filter on product types in both the API and Commerce Manager.
   *
   * Product types can also be used in catalogs. For example, in your catalog, you can filter on parent so that only your parent products are displayed in your storefront.
   *
   * Products have one of the following types:
   *
   * - **standard** - Standard products are a standalone products.
   * - **parent** - A parent product is a product that has child products that have been built using the `Build Child Products` endpoint.
   * - **child** - When you configure product variations and variation options for parent products, the child products derived from the parent products are automatically created in Commerce.
   * - **bundle** - A bundle is a purchasable product, comprising two or more standalone products (in other words, components) to be sold together.
   *
   */
  product_types?: Array<string>
  /**
   * If you storefront supports multiple languages, your storefront's preferred language and locale.
   */
  language?: string
}

/**
 * The source of a catalog. Always `pim`.
 */
export type catalog_source = "pim"

/**
 * The options available for a variation.
 */
export type VariationOption = {
  /**
   * A unique identifier for an option.
   */
  id?: string
  /**
   * The name of the option.
   */
  name?: string
  /**
   * If you specified a `sort_order` when creating your variations and variation options, then use the `sort_order` value to program your storefront to display the variations and variation options in the order that you want.
   */
  sort_order?: number | null
  /**
   * The option description to display to customers.
   */
  description?: string
}

export type Variation = {
  /**
   * A unique identifier of a variation.
   */
  id?: string
  /**
   * The name of a variation.
   */
  name?: string
  /**
   * If you specified a `sort_order` when creating your variations and variation options, then use the `sort_order` value to program your storefront to display the variations and variation options in the order that you want.
   */
  sort_order?: number | null
  option?: VariationOption
  /**
   * The options available for this variation.
   */
  options?: Array<VariationOption>
}

/**
 * Container for a bundle configuration.
 */
export type BundleConfigurationData = {
  data: BundleConfiguration
}

/**
 * A bundle is a purchasable product, comprising of one or more products that you want to sell together. You can create multiple components within a bundle. Each component must have at least one or more options. Each option is a product and a quantity.
 */
export type BundleConfiguration = {
  /**
   * The product options included in a component. This can be the ID of another bundle.
   */
  selected_options: {
    [key: string]: {
      [key: string]: number
    }
  }
}

/**
 * A product identifier.
 */
export type ProductReference = {
  /**
   * A unique identifier for a product.
   */
  id?: string
  /**
   * This represents the type of object being returned. Always `product`.
   */
  type?: "product"
}

/**
 * Container for a list of product references.
 */
export type ProductReferenceListData = {
  meta?: PageMeta
  data?: ProductReferences
  links?: Links
}

/**
 * A list of product identifiers.
 */
export type ProductReferences = Array<ProductReference>

/**
 * Relationships allow you to move between requests. Includes links to the parent and child products, bundle component products, files, and main images associated with a product.
 */
export type ProductRelationships = {
  /**
   * The details of a `parent` product. A `parent` product is a product that has child products that have been built using the `Build Child Products` endpoint.
   */
  parent?: {
    data?: ProductReference
  }
  /**
   * The details of a `child` product. When you configure product variations and variation options for parent products, the child products derived from the parent products are automatically created in Commerce.
   */
  children?: {
    data?: ProductReferences
    links?: SelfLink
  }
  files?: FilesRelationship
  main_image?: MainImageRelationship
  component_products?: ComponentProductsRelationship
}

/**
 * Container for product relationships.
 */
export type ProductRelationshipsData = {
  data?: ProductRelationships
  links?: Links
}

/**
 * A list of products to be added to cart. Can be type product-data or error-response.
 */
export type ProductsForCart = {
  data: Array<unknown>
  included?: {
    component_products?: Array<Product>
  } | null
}

/**
 * A list of product id or sku and bundle configuration for cart.
 */
export type ProductsForCartConfiguration = {
  data: Array<{
    id?: string | null
    sku?: string | null
    bundle_configuration?: BundleConfiguration
  }>
}

/**
 * A URL to a related object, for example, catalog rules, hierarchies, price books, products and deltas.
 */
export type RelatedLink = {
  /**
   * A URL to a related object, for example, catalog rules, hierarchies, price books, products and deltas.
   */
  related: string
}

/**
 * Links are used to allow you to move between requests.
 */
export type SelfLink = {
  /**
   * Single entities use a self parameter with a link to that specific resource.
   */
  self: string
}

/**
 * A catalog release represents a collection of hierarchical product data, price books and catalogs rules.
 */
export type Release = {
  /**
   * A unique identifier for the catalog release.
   */
  id?: string
  attributes?: {
    /**
     * The name of a release.
     */
    name?: string
    /**
     * The date and time a release was published.
     */
    published_at?: Date | null
    /**
     * A unique identifier for the catalog.
     */
    catalog_id?: string
    /**
     * A description of the catalog release.
     */
    description?: string
    /**
     * An array of hierarchy IDs associated with the release.
     */
    hierarchies?: Array<NodeReference>
  }
  relationships?: ReleaseRelationships
  /**
   * This represents the type of object being returned. Always `catalog-release`.
   */
  type?: string
  meta?: ReleaseMeta
}

/**
 * Container for a catalog release.
 */
export type ReleaseData = {
  data?: Release
  links?: Links
}

/**
 * Container for a list of catalog releases.
 */
export type ReleaseListData = {
  data?: Array<Release>
  links?: Links
}

/**
 * A release's metadata.
 */
export type ReleaseMeta = {
  /**
   * The date and time a release is created.
   */
  created_at?: Date
  /**
   * The date and time a release is available for use. In other words, the date and time the status of a catalog release changes to PUBLISHED, rather than IN PROGRESS.
   */
  started_at?: Date | null
  /**
   * The date and time a release is updated.
   */
  updated_at?: Date | null
  /**
   * The status of the current release.
   */
  release_status?: "PENDING" | "IN_PROGRESS" | "FAILED" | "PUBLISHED"
  /**
   * Your storefront's preferred language code and locale.
   */
  language?: string
  /**
   * Indicates that a full publish was performed (either because this is the first time a catalog has been published or because of a change that occurred, for example, adding/removing a price book or hierarchy). When determining whether delta data needs to be refreshed, ignore this attribute and always use the `is_full_delta` attribute.
   *
   */
  is_full_publish?: boolean
  /**
   * Indicates whether the release delta file contains the full content of a catalog release. Using a search service as an example, if the `is_full_delta` attribute is `true`, you should remove all data about that catalog release from the search service before injecting fresh data from the delta file. If the `is_full_delta` attribute is `false`, then data from the previous catalog release overlays the existing data in the delta file. The `is_full_delta` attribute is always `true` the first time a catalog is published.
   *
   */
  is_full_delta?: boolean
  /**
   * The total number of products displayed in a catalog release.
   */
  total_products?: number | null
  /**
   * The total number of hierarchy nodes displayed in a catalog release.
   */
  total_nodes?: number | null
  /**
   * An integer that represents the progress of a catalog publish. The attribute starts at `0` and reaches `100` when publishing is complete.
   */
  percent_completed?: number | null
  /**
   * The owner of the resource, can be either `organization` or `store`.
   */
  owner?: "store" | "organization" | null
}

/**
 * The status of the current release.
 */
export type release_status = "PENDING" | "IN_PROGRESS" | "FAILED" | "PUBLISHED"

/**
 * Relationships are established between different catalog entities. For example, products, hierarchies, price books, and catalog rules are related to a catalog, as they are associated with it.
 */
export type ReleaseRelationships = {
  /**
   * A URL to a delta document that describes the changes between catalog releases.
   */
  delta?: {
    links?: RelatedLink
  }
  /**
   * A URL to all products included in a catalog release.
   */
  products?: {
    links?: RelatedLink
  }
  /**
   * A URL to all hierarchies included in a catalog release.
   */
  hierarchies?: {
    links: RelatedLink
  }
}

/**
 * A catalog rule specifies which catalog to use for a given shopper context.
 */
export type Rule = {
  /**
   * The catalog rule ID. Use this to get, modify, or delete the catalog rule.
   */
  id: string
  attributes: {
    /**
     * The name of a catalog rule. The name must not contain any spaces.
     */
    name: string
    /**
     * A brief description of the purpose of a catalog rule.
     */
    description?: string
    /**
     * The list of accounts who are eligible to see this catalog. If this field is empty, the rule matches all accounts.
     */
    account_ids?: Array<string>
    /**
     * The list of customers who are eligible to see this catalog. If empty, the rule matches all customers.
     */
    customer_ids?: Array<string>
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    channels?: Array<string>
    /**
     * A list of user-defined tags that can be used to further restrict the eligibility criteria for this rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    tags?: Array<string>
    /**
     * Specifies a time period when a catalog is displayed, such as on a specific date or during summer. Requests populate the rule tag using the `EP-Context-Tag` header.
     *
     * The schedules attribute must include the following.
     *
     * - `valid_from` matches the date and time that the catalog is displayed from.
     * - `valid_to` matches the date and time the catalog is displayed to.
     *
     * Commerce runs on UTC time.
     *
     * You can offset the timezone by adding the offset to the end of the date and time. For example, a catalog which contains a sale hierarchy that should appear for a set timeframe may be scheduled to publish on a given date and time within a given timezone. For instance, a sale that should begin on 1st of June 2022 05:00 ET and end on the 15th of June 2022 at 23:50 PT would have a valid schedule of `"valid_from": "2022-06-01T05:00:00.000-05:00"`, `"valid_to": "2022-06-15T11:59:99.000-08:00"`.
     *
     */
    schedules?: Array<RuleSchedule>
    /**
     * The unique identifier of a catalog.
     */
    catalog_id: string
    /**
     * The date and time a catalog rule was created.
     */
    created_at: Date
    /**
     * The date and time a catalog release is updated.
     */
    updated_at: Date
  }
  /**
   * This represents the type of object being returned. Always `catalog_rule`.
   */
  type: "catalog_rule"
}

/**
 * This represents the type of object being returned. Always `catalog_rule`.
 */
export type type9 = "catalog_rule"

/**
 * A catalog rule specifies which catalog to use for a given shopper context.
 */
export type RuleCreateData = {
  data: {
    attributes: {
      /**
       * The name of a catalog rule. The name must not contain spaces.
       */
      name: string
      /**
       * A brief description of the purpose of a catalog rule.
       */
      description?: string | null
      /**
       * The list of accounts who are eligible to see this catalog. If this field is empty, the rule matches all accounts.
       */
      account_ids?: Array<string> | null
      /**
       * The list of customers who are eligible to see this catalog. If empty, the rule matches all customers.
       */
      customer_ids?: Array<string> | null
      /**
       * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
       */
      channels?: Array<string> | null
      /**
       * A list of user-defined tags that can be used to further restrict the eligibility criteria for this rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
       */
      tags?: Array<string> | null
      /**
       * Specifies a time period when a catalog is displayed, such as on a specific date or during summer. Requests populate the rule tag using the `EP-Context-Tag` header.
       *
       * The schedules attribute must include the following.
       *
       * - `valid_from` matches the date and time that the catalog is displayed from.
       * - `valid_to` matches the date and time the catalog is displayed to.
       *
       * Commerce runs on UTC time.
       *
       * You can offset the timezone by adding the offset to the end of the date and time. For example, a catalog which contains a sale hierarchy that should appear for a set timeframe may be scheduled to publish on a given date and time within a given timezone. For instance, a sale that should begin on 1st of June 2022 05:00 ET and end on the 15th of June 2022 at 23:50 PT would have a valid schedule of `"valid_from": "2022-06-01T05:00:00.000-05:00"`, `"valid_to": "2022-06-15T11:59:99.000-08:00"`.
       *
       */
      schedules?: Array<RuleSchedule> | null
      /**
       * The unique identifier of a catalog.
       */
      catalog_id: string
    }
    /**
     * This represents the type of object being returned. Always `catalog_rule`.
     */
    type: "catalog_rule"
  }
}

/**
 * Container for a single catalog rule.
 */
export type RuleData = {
  data: Rule
  links?: Links
}

/**
 * Container for a list of catalog rules.
 */
export type RuleListData = {
  meta?: PageMeta
  data: Array<Rule>
  links?: Links
}

/**
 * A period of time during which a catalog is valid
 */
export type RuleSchedule = {
  /**
   * Matches the date and time that the catalog is displayed from.
   */
  valid_from?: Date | null
  /**
   * Matches the date and time the catalog is displayed to.
   */
  valid_to?: Date | null
}

/**
 * A catalog rule specifies which catalog to use for a given shopper context.
 */
export type RuleUpdateData = {
  data: {
    /**
     * The catalog rule ID. Use this to get, modify, or delete the catalog rule.
     */
    id: string
    attributes?: {
      /**
       * The name of a catalog rule. The name must not contain spaces.
       */
      name?: string | null
      /**
       * A description of the purpose of a catalog rule.
       */
      description?: string | null
      /**
       * Specifies the list of accounts who are eligible to see this catalog. If this field is empty, the rule matches all accounts.
       */
      account_ids?: Array<string> | null
      /**
       * The list of customers who are eligible to see this catalog. If empty, the rule matches all customers.
       */
      customer_ids?: Array<string> | null
      /**
       * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
       */
      channels?: Array<string> | null
      /**
       * Specifies a time period when a catalog is displayed, such as on a specific date or during summer. Requests populate the rule tag using the `EP-Context-Tag` header.
       *
       * The schedules attribute must include the following.
       *
       * - `valid_from` matches the date and time that the catalog is displayed from.
       * - `valid_to` matches the date and time the catalog is displayed to.
       *
       * Commerce runs on UTC time.
       *
       * You can offset the timezone by adding the offset to the end of the date and time. For example, a catalog which contains a sale hierarchy that should appear for a set timeframe may be scheduled to publish on a given date and time within a given timezone. For instance, a sale that should begin on 1st of June 2022 05:00 ET and end on the 15th of June 2022 at 23:50 PT would have a valid schedule of `"valid_from": "2022-06-01T05:00:00.000-05:00"`, `"valid_to": "2022-06-15T11:59:99.000-08:00"`.
       *
       */
      schedules?: Array<RuleSchedule> | null
      /**
       * A list of user-defined tags that can be used to further restrict the eligibility criteria for this rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
       */
      tags?: Array<string> | null
      /**
       * The unique identifier of a catalog rule.
       */
      catalog_id?: string | null
    }
    /**
     * This represents the type of object being returned. Always `catalog_rule`.
     */
    type: "catalog_rule"
  }
}

/**
 * A set of sale prices and a validity period.
 */
export type Sale = {
  schedule?: Schedule
  currencies?: TieredCurrencies
}

/**
 * A set of sale specifications
 */
export type Sales = {
  [key: string]: Sale
}

/**
 * A definition of the times at which a sale is valid
 */
export type Schedule = {
  valid_from?: Date | null
  valid_to?: Date | null
}

/**
 * The name of the tier, for example, `Pencils`.
 */
export type Tier = {
  /**
   * The minimum quantity of 1 or more defined for the specified price. If a minimum quantity is not specified, an error is returned.
   */
  minimum_quantity?: number
  price?: Currencies
}

/**
 * The three-letter ISO code for the currency associated with this price.
 */
export type TieredAmount = {
  /**
   * The price in the lowest denomination for the specified currency. This is a product's list price.
   */
  amount?: number
  /**
   * Whether this price includes tax.
   */
  includes_tax?: boolean
  /**
   * The price tier that an item is eligible for based on the quantity purchased. You cannot have conflicting tiers within the same currencies block.
   */
  tiers?: {
    [key: string]: {
      /**
       * The minimum quantity of 1 or more defined for the specified price. If a minimum quantity is not specified, an error is returned.
       */
      minimum_quantity?: number
      /**
       * The price for each quantity.
       */
      amount?: number
    }
  }
}

/**
 * Collection of currency specific prices for a product.
 */
export type TieredCurrencies = {
  [key: string]: TieredAmount
}

/**
 * The price tier that an item is eligible for based on the quantity purchased. You cannot have conflicting tiers within the same currencies block.
 */
export type Tiers = {
  [key: string]: Tier
}

/**
 * Creates a catalog release with the following attributes.
 */
export type CatalogReleaseCreateData = {
  data?: {
    /**
     * Set to `true` if you want to export all the data from a catalog release in a delta link. The `is_full_delta` attribute is returned from the `get a release of a catalog` endpoint. The `is_full_delta` attribute tells you if the delta file contains the full content of a catalog release. You can use the `is_full_delta` to determine if you need to refresh the data in your company system before publishing a catalog release with fresh data in a delta link. Using a search service as an example, if the `is_full_delta` attribute is true, you should remove all data about that catalog from the search service before publishing a catalog release and injecting fresh data from the delta file. If the `is_full_delta` attribute is false, then data from the previous catalog overlays the existing data in the delta file. The `is_full_delta` attribute is always `true` the first time a catalog is published.
     *
     */
    export_full_delta?: boolean
    /**
     * If you are publishing a catalog in a store that contains resources from an organization, you must set this to true and you must enable the **Include Organization Resources in Catalog Publishes** checkbox in Commerce Manager. See [**Multi-Store Management Solutions**](/docs/api/pxm/catalog/publish-release).
     */
    include_organization_resources?: boolean | null
  }
}

export type binary = {
  /**
   * The unique identifier for this file.
   */
  id?: string
  /**
   * The type represents the object being returned.
   */
  type?: string
  /**
   * The name of the file.
   */
  file_name?: string
  /**
   * The mime type of the file.
   */
  mime_type?: string
  /**
   * The size of the file. Required when uploading files.
   */
  file_size?: number
  /**
   * DEPRECATED Whether the file public or not. Required when uploading files.
   */
  public?: boolean
  meta?: FileMeta
  links?: Links
  link?: FileLink
}

export type FileMeta = {
  /**
   * The date and time the file was created.
   */
  timestamps?: {
    /**
     * The date and time the file was created.
     */
    created_at?: string
  }
  /**
   * The file dimensions.
   */
  dimensions?: {
    /**
     * The width of the file.
     */
    width?: number
    /**
     * The height of the file.
     */
    height?: number
  }
}

/**
 * The publicly available URL for this file.
 */
export type FileLink = {
  /**
   * The publicly available URL for this file.
   */
  href?: string
}

/**
 * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
 */
export type ParameterChannel = string

/**
 * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
 */
export type ParameterAcceptLanguage = string

/**
 * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
 */
export type ParameterTag = string

/**
 * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
 */
export type ParameterLimit = number

/**
 * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
 */
export type ParameterOffset = number

/**
 * This endpoint supports filtering. See [Filtering](#filtering).
 *
 */
export type ParameterFilterRule = string

/**
 *
 * This endpoints supports filtering. See [Filtering](#filtering).
 *
 */
export type ParameterFilterHierarchy = string

/**
 * This endpoint supports filtering, see [Filtering](#filtering).
 *
 */
export type ParameterFilterNode = string

/**
 * This endpoints support filtering. See [Filtering](#filtering).
 *
 */
export type ParameterFilterProduct = string

/**
 * Using the `include=component_products` parameter, you can retrieve key attribute data for the bundle component products in the product bundle, such as SKU or slug .
 *
 */
export type ParameterIncludeComponentProducts = string

/**
 * Using the `include` parameter, you can retrieve top-level resources, such as, files or main image, bundle component products.
 *
 */
export type ParameterInclude = Array<
  "main_images" | "files" | "component_products"
>

export type CreateCatalogData = {
  /**
   * Creates a catalog with the following attributes.
   */
  body: CatalogCreateData
}

export type CreateCatalogResponse = CatalogData

export type CreateCatalogError = ErrorResponse

export type GetCatalogsResponse = CatalogListData

export type GetCatalogsError = ErrorResponse

export type GetCatalogByIdData = {
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
  }
}

export type GetCatalogByIdResponse = CatalogData

export type GetCatalogByIdError = ErrorResponse

export type UpdateCatalogData = {
  /**
   * Updated catalog.
   */
  body: CatalogUpdateData
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
  }
}

export type UpdateCatalogResponse = CatalogData

export type UpdateCatalogError = ErrorResponse

export type DeleteCatalogByIdData = {
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
  }
}

export type DeleteCatalogByIdResponse = void

export type DeleteCatalogByIdError = ErrorResponse

export type PublishReleaseData = {
  /**
   * Options for catalog release publishing
   */
  body?: CatalogReleaseCreateData
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
  }
}

export type PublishReleaseResponse = ReleaseData

export type PublishReleaseError = ErrorResponse

export type GetReleasesData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
  }
}

export type GetReleasesResponse = ReleaseListData

export type GetReleasesError = ErrorResponse

export type DeleteReleasesData = {
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
  }
}

export type DeleteReleasesResponse = void

export type DeleteReleasesError = ErrorResponse

export type GetReleaseByIdData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The catalog release ID.
     */
    release_id: string
  }
}

export type GetReleaseByIdResponse = ReleaseData

export type GetReleaseByIdError = ErrorResponse

export type DeleteReleaseByIdData = {
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The catalog release ID.
     */
    release_id: string
  }
}

export type DeleteReleaseByIdResponse = void

export type DeleteReleaseByIdError = ErrorResponse

export type CreateRuleData = {
  /**
   * Creates a catalog rule with the following attributes.
   */
  body: RuleCreateData
}

export type CreateRuleResponse = RuleData

export type CreateRuleError = ErrorResponse

export type GetRulesData = {
  query?: {
    /**
     * This endpoint supports filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetRulesResponse = RuleListData

export type GetRulesError = ErrorResponse

export type GetRuleByIdData = {
  path: {
    /**
     * The catalog rule ID.
     */
    catalog_rule_id: string
  }
}

export type GetRuleByIdResponse = RuleData

export type GetRuleByIdError = ErrorResponse

export type UpdateRuleData = {
  /**
   * An updated catalog rule with the following attributes.
   */
  body: RuleUpdateData
  path: {
    /**
     * The catalog rule ID.
     */
    catalog_rule_id: string
  }
}

export type UpdateRuleResponse = RuleData

export type UpdateRuleError = ErrorResponse

export type DeleteRuleByIdData = {
  path: {
    /**
     * The catalog rule ID.
     */
    catalog_rule_id: string
  }
}

export type DeleteRuleByIdResponse = void

export type DeleteRuleByIdError = ErrorResponse

export type GetAllHierarchiesData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latest` for the most recently published version.
     */
    release_id: string
  }
  query?: {
    /**
     *
     * This endpoints supports filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetAllHierarchiesResponse = HierarchyListData

export type GetAllHierarchiesError = ErrorResponse

export type GetHierarchyData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
    /**
     * The unique identifier of a published release of the catalog or `latest` for the most recently published version.
     */
    release_id: string
  }
}

export type GetHierarchyResponse = HierarchyData

export type GetHierarchyError = ErrorResponse

export type GetHierarchyNodesData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
    /**
     * The catalog release ID.
     */
    release_id: string
  }
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetHierarchyNodesResponse = NodeListData

export type GetHierarchyNodesError = ErrorResponse

export type GetHierarchyChildNodesData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
    /**
     * The unique identifier of a published release of the catalog or `latest` for the most recently published version.
     */
    release_id: string
  }
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetHierarchyChildNodesResponse = NodeListData

export type GetHierarchyChildNodesError = ErrorResponse

export type GetAllNodesData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latest` for the most recently published version.
     */
    release_id: string
  }
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetAllNodesResponse = NodeListData

export type GetAllNodesError = ErrorResponse

export type GetNodeData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The catalog node ID.
     */
    node_id: string
    /**
     * The unique identifier of a published release of the catalog or `latest` for the most recently published version.
     */
    release_id: string
  }
}

export type GetNodeResponse = NodeData

export type GetNodeError = ErrorResponse

export type GetChildNodesData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The catalog node ID.
     */
    node_id: string
    /**
     * The unique identifier of a published release of the catalog or `latest` for the most recently published version.
     */
    release_id: string
  }
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetChildNodesResponse = NodeListData

export type GetChildNodesError = ErrorResponse

export type GetAllProductsData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latest` for the most recently published version.
     */
    release_id: string
  }
  query?: {
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetAllProductsResponse = ProductListData

export type GetAllProductsError = ErrorResponse

export type GetProductData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The product ID.
     */
    product_id: string
    /**
     * The unique identifier of a published release of the catalog or `latest` for the most recently published version.
     */
    release_id: string
  }
}

export type GetProductResponse = ProductData

export type GetProductError = ErrorResponse

export type GetComponentProductIdsData = {
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The product ID.
     */
    product_id: string
    /**
     * The unique identifier of a published release of the catalog or `latest` for the most recently published version.
     */
    release_id: string
  }
  query?: {
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetComponentProductIdsResponse = ProductReferenceListData

export type GetComponentProductIdsError = ErrorResponse

export type GetChildProductsData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The product ID.
     */
    product_id: string
    /**
     * The unique identifier of a published release of the catalog or `latest` for the most recently published version.
     */
    release_id: string
  }
  query?: {
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetChildProductsResponse = ProductListData

export type GetChildProductsError = ErrorResponse

export type GetProductsForHierarchyData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
    /**
     * The unique identifier of a published release of the catalog or `latest` for the most recently published version.
     */
    release_id: string
  }
  query?: {
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetProductsForHierarchyResponse = ProductListData

export type GetProductsForHierarchyError = ErrorResponse

export type GetProductsForNodeData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The catalog node ID.
     */
    node_id: string
    /**
     * The unique identifier of a published release of the catalog or `latest` for the most recently published version.
     */
    release_id: string
  }
  query?: {
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetProductsForNodeResponse = ProductListData

export type GetProductsForNodeError = ErrorResponse

export type GetByContextReleaseData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
}

export type GetByContextReleaseResponse = ReleaseData

export type GetByContextReleaseError = ErrorResponse

export type GetByContextAllHierarchiesData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  query?: {
    /**
     *
     * This endpoints supports filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetByContextAllHierarchiesResponse = HierarchyListData

export type GetByContextAllHierarchiesError = ErrorResponse

export type GetByContextHierarchyData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
  }
}

export type GetByContextHierarchyResponse = HierarchyData

export type GetByContextHierarchyError = ErrorResponse

export type GetByContextHierarchyNodesData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
  }
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetByContextHierarchyNodesResponse = NodeListData

export type GetByContextHierarchyNodesError = ErrorResponse

export type GetByContextHierarchyChildNodesData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
  }
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetByContextHierarchyChildNodesResponse = NodeListData

export type GetByContextHierarchyChildNodesError = ErrorResponse

export type GetByContextAllNodesData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetByContextAllNodesResponse = NodeListData

export type GetByContextAllNodesError = ErrorResponse

export type GetByContextNodeData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The catalog node ID.
     */
    node_id: string
  }
}

export type GetByContextNodeResponse = NodeData

export type GetByContextNodeError = ErrorResponse

export type GetByContextChildNodesData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The catalog node ID.
     */
    node_id: string
  }
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetByContextChildNodesResponse = NodeListData

export type GetByContextChildNodesError = ErrorResponse

export type GetByContextAllProductsData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  query?: {
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetByContextAllProductsResponse = ProductListData

export type GetByContextAllProductsError = ErrorResponse

export type GetByContextProductData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The product ID.
     */
    product_id: string
  }
  query?: {
    /**
     * Using the `include` parameter, you can retrieve top-level resources, such as, files or main image, bundle component products.
     *
     */
    include?: Array<"main_images" | "files" | "component_products">
  }
}

export type GetByContextProductResponse = ProductData

export type GetByContextProductError = ErrorResponse

export type GetByContextComponentProductIdsData = {
  headers?: {
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The product ID.
     */
    product_id: string
  }
  query?: {
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetByContextComponentProductIdsResponse = ProductReferenceListData

export type GetByContextComponentProductIdsError = ErrorResponse

export type GetByContextChildProductsData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The product ID.
     */
    product_id: string
  }
  query?: {
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetByContextChildProductsResponse = ProductListData

export type GetByContextChildProductsError = ErrorResponse

export type GetByContextProductsForHierarchyData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
  }
  query?: {
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetByContextProductsForHierarchyResponse = ProductListData

export type GetByContextProductsForHierarchyError = ErrorResponse

export type GetByContextProductsForNodeData = {
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The catalog node ID.
     */
    node_id: string
  }
  query?: {
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
  }
}

export type GetByContextProductsForNodeResponse = ProductListData

export type GetByContextProductsForNodeError = ErrorResponse

export type ConfigureByContextProductData = {
  /**
   * The bundle configuration.
   */
  body: BundleConfigurationData
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Product tags are used to store or assign a key word against a product. The product tag can then be used to describe or label that product. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on. You can enhance your product list using tags, enabling you to refine your product list and run targeted promotions. Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The product ID.
     */
    product_id: string
  }
}

export type ConfigureByContextProductResponse = ProductData

export type ConfigureByContextProductError = ErrorResponse

export type $OpenApiTs = {
  "/pcm/catalogs": {
    post: {
      req: CreateCatalogData
      res: {
        /**
         * The created catalog
         */
        "201": CatalogData
        /**
         * Unexpected error.
         */
        default: ErrorResponse
      }
    }
    get: {
      res: {
        /**
         * The list of catalogs.
         */
        "200": CatalogListData
        /**
         * An unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}": {
    get: {
      req: GetCatalogByIdData
      res: {
        /**
         * The catalog.
         */
        "200": CatalogData
        /**
         * An unexpected error.
         */
        default: ErrorResponse
      }
    }
    put: {
      req: UpdateCatalogData
      res: {
        /**
         * An updated catalog with the following attributes.
         */
        "200": CatalogData
        /**
         * Unexpected error.
         */
        default: ErrorResponse
      }
    }
    delete: {
      req: DeleteCatalogByIdData
      res: {
        /**
         * A 204 response indicates that the catalog has been deleted.
         */
        "204": void
        /**
         * Unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}/releases": {
    post: {
      req: PublishReleaseData
      res: {
        /**
         * Publishes a catalog release with the following attributes.
         */
        "201": ReleaseData
        /**
         * Unexpected error.
         */
        default: ErrorResponse
      }
    }
    get: {
      req: GetReleasesData
      res: {
        /**
         * The list of catalogs.
         */
        "200": ReleaseListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
    delete: {
      req: DeleteReleasesData
      res: {
        /**
         * A 204 response indicates that the releases have been deleted.
         */
        "204": void
        /**
         * Unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}/releases/{release_id}": {
    get: {
      req: GetReleaseByIdData
      res: {
        /**
         * The catalog.
         */
        "200": ReleaseData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
    delete: {
      req: DeleteReleaseByIdData
      res: {
        /**
         * A 204 response indicates that the release has been deleted.
         */
        "204": void
        /**
         * Unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/rules": {
    post: {
      req: CreateRuleData
      res: {
        /**
         * The created catalog rule
         */
        "201": RuleData
        /**
         * Unexpected error.
         */
        default: ErrorResponse
      }
    }
    get: {
      req: GetRulesData
      res: {
        /**
         * The list of catalog rules.
         */
        "200": RuleListData
        /**
         * An unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/rules/{catalog_rule_id}": {
    get: {
      req: GetRuleByIdData
      res: {
        /**
         * The catalog rile.
         */
        "200": RuleData
        /**
         * An unexpected error.
         */
        default: ErrorResponse
      }
    }
    put: {
      req: UpdateRuleData
      res: {
        /**
         * An Updated catalog rule with the following attributes.
         */
        "200": RuleData
        /**
         * Unexpected error.
         */
        default: ErrorResponse
      }
    }
    delete: {
      req: DeleteRuleByIdData
      res: {
        /**
         * A 204 response indicates that the catalog rule has been deleted.
         */
        "204": void
        /**
         * Unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}/releases/{release_id}/hierarchies": {
    get: {
      req: GetAllHierarchiesData
      res: {
        /**
         * The hierarchies of a catalog.
         */
        "200": HierarchyListData
        /**
         * An unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}/releases/{release_id}/hierarchies/{hierarchy_id}": {
    get: {
      req: GetHierarchyData
      res: {
        /**
         * The catalog hierarchy.
         */
        "200": HierarchyData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}/releases/{release_id}/hierarchies/{hierarchy_id}/nodes": {
    get: {
      req: GetHierarchyNodesData
      res: {
        /**
         * The child nodes of a catalog hierarchy.
         */
        "200": NodeListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}/releases/{release_id}/hierarchies/{hierarchy_id}/children": {
    get: {
      req: GetHierarchyChildNodesData
      res: {
        /**
         * The child nodes of a catalog hierarchy.
         */
        "200": NodeListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}/releases/{release_id}/nodes": {
    get: {
      req: GetAllNodesData
      res: {
        /**
         * The nodes of a catalog.
         */
        "200": NodeListData
        /**
         * An unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}/releases/{release_id}/nodes/{node_id}": {
    get: {
      req: GetNodeData
      res: {
        /**
         * The catalog node.
         */
        "200": NodeData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}/releases/{release_id}/nodes/{node_id}/relationships/children": {
    get: {
      req: GetChildNodesData
      res: {
        /**
         * The child nodes of a catalog node.
         */
        "200": NodeListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}/releases/{release_id}/products": {
    get: {
      req: GetAllProductsData
      res: {
        /**
         * The products of a catalog.
         */
        "200": ProductListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}/releases/{release_id}/products/{product_id}": {
    get: {
      req: GetProductData
      res: {
        /**
         * The product of a catalog.
         */
        "200": ProductData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}/releases/{release_id}/products/{product_id}/relationships/component_products": {
    get: {
      req: GetComponentProductIdsData
      res: {
        /**
         * The list of component product IDs of a specific bundle product from a catalog.
         */
        "200": ProductReferenceListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}/releases/{release_id}/products/{product_id}/relationships/children": {
    get: {
      req: GetChildProductsData
      res: {
        /**
         * The list of child products of a specific base product from a catalog.
         */
        "200": ProductListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}/releases/{release_id}/hierarchies/{hierarchy_id}/products": {
    get: {
      req: GetProductsForHierarchyData
      res: {
        /**
         * The products of a catalog hierarchy.
         */
        "200": ProductListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/pcm/catalogs/{catalog_id}/releases/{release_id}/nodes/{node_id}/relationships/products": {
    get: {
      req: GetProductsForNodeData
      res: {
        /**
         * The products of a catalog node.
         */
        "200": ProductListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/catalog": {
    get: {
      req: GetByContextReleaseData
      res: {
        /**
         * The catalog.
         */
        "200": ReleaseData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/catalog/hierarchies": {
    get: {
      req: GetByContextAllHierarchiesData
      res: {
        /**
         * The hierarchies of the catalog.
         */
        "200": HierarchyListData
        /**
         * An unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/catalog/hierarchies/{hierarchy_id}": {
    get: {
      req: GetByContextHierarchyData
      res: {
        /**
         * The catalog hierarchy.
         */
        "200": HierarchyData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/catalog/hierarchies/{hierarchy_id}/nodes": {
    get: {
      req: GetByContextHierarchyNodesData
      res: {
        /**
         * The child nodes of a catalog hierarchy.
         */
        "200": NodeListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/catalog/hierarchies/{hierarchy_id}/children": {
    get: {
      req: GetByContextHierarchyChildNodesData
      res: {
        /**
         * The child nodes of a catalog hierarchy.
         */
        "200": NodeListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/catalog/nodes": {
    get: {
      req: GetByContextAllNodesData
      res: {
        /**
         * The nodes of the catalog.
         */
        "200": NodeListData
        /**
         * An unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/catalog/nodes/{node_id}": {
    get: {
      req: GetByContextNodeData
      res: {
        /**
         * The catalog node.
         */
        "200": NodeData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/catalog/nodes/{node_id}/relationships/children": {
    get: {
      req: GetByContextChildNodesData
      res: {
        /**
         * The child nodes of a catalog node.
         */
        "200": NodeListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/catalog/products": {
    get: {
      req: GetByContextAllProductsData
      res: {
        /**
         * The products of a catalog.
         */
        "200": ProductListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/catalog/products/{product_id}": {
    get: {
      req: GetByContextProductData
      res: {
        /**
         * The product of a catalog.
         */
        "200": ProductData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/catalog/products/{product_id}/relationships/component_products": {
    get: {
      req: GetByContextComponentProductIdsData
      res: {
        /**
         * The list of component product IDs of a bundle product from a catalog.
         */
        "200": ProductReferenceListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/catalog/products/{product_id}/relationships/children": {
    get: {
      req: GetByContextChildProductsData
      res: {
        /**
         * The list of child products of a parent product from a catalog.
         */
        "200": ProductListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/catalog/hierarchies/{hierarchy_id}/products": {
    get: {
      req: GetByContextProductsForHierarchyData
      res: {
        /**
         * The products of a catalog hierarchy.
         */
        "200": ProductListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/catalog/nodes/{node_id}/relationships/products": {
    get: {
      req: GetByContextProductsForNodeData
      res: {
        /**
         * The products of a catalog node.
         */
        "200": ProductListData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
  "/catalog/products/{product_id}/configure": {
    post: {
      req: ConfigureByContextProductData
      res: {
        /**
         * The configured product of a catalog.
         */
        "200": ProductData
        /**
         * The unexpected error.
         */
        default: ErrorResponse
      }
    }
  }
}

export type CreateCatalogResponseTransformer = (
  data: any,
) => Promise<CreateCatalogResponse>

export type CatalogDataModelResponseTransformer = (data: any) => CatalogData

export type CatalogModelResponseTransformer = (data: any) => Catalog

export const CatalogModelResponseTransformer: CatalogModelResponseTransformer =
  (data) => {
    if (data?.attributes?.created_at) {
      data.attributes.created_at = new Date(data.attributes.created_at)
    }
    if (data?.attributes?.updated_at) {
      data.attributes.updated_at = new Date(data.attributes.updated_at)
    }
    return data
  }

export const CatalogDataModelResponseTransformer: CatalogDataModelResponseTransformer =
  (data) => {
    if (data?.data) {
      CatalogModelResponseTransformer(data.data)
    }
    return data
  }

export const CreateCatalogResponseTransformer: CreateCatalogResponseTransformer =
  async (data) => {
    CatalogDataModelResponseTransformer(data)
    return data
  }

export type GetCatalogsResponseTransformer = (
  data: any,
) => Promise<GetCatalogsResponse>

export type CatalogListDataModelResponseTransformer = (
  data: any,
) => CatalogListData

export const CatalogListDataModelResponseTransformer: CatalogListDataModelResponseTransformer =
  (data) => {
    if (Array.isArray(data?.data)) {
      data.data.forEach(CatalogModelResponseTransformer)
    }
    return data
  }

export const GetCatalogsResponseTransformer: GetCatalogsResponseTransformer =
  async (data) => {
    CatalogListDataModelResponseTransformer(data)
    return data
  }

export type GetCatalogByIdResponseTransformer = (
  data: any,
) => Promise<GetCatalogByIdResponse>

export const GetCatalogByIdResponseTransformer: GetCatalogByIdResponseTransformer =
  async (data) => {
    CatalogDataModelResponseTransformer(data)
    return data
  }

export type UpdateCatalogResponseTransformer = (
  data: any,
) => Promise<UpdateCatalogResponse>

export const UpdateCatalogResponseTransformer: UpdateCatalogResponseTransformer =
  async (data) => {
    CatalogDataModelResponseTransformer(data)
    return data
  }

export type PublishReleaseResponseTransformer = (
  data: any,
) => Promise<PublishReleaseResponse>

export type ReleaseDataModelResponseTransformer = (data: any) => ReleaseData

export type ReleaseModelResponseTransformer = (data: any) => Release

export type ReleaseMetaModelResponseTransformer = (data: any) => ReleaseMeta

export const ReleaseMetaModelResponseTransformer: ReleaseMetaModelResponseTransformer =
  (data) => {
    if (data?.created_at) {
      data.created_at = new Date(data.created_at)
    }
    if (data?.started_at) {
      data.started_at = new Date(data.started_at)
    }
    if (data?.updated_at) {
      data.updated_at = new Date(data.updated_at)
    }
    return data
  }

export const ReleaseModelResponseTransformer: ReleaseModelResponseTransformer =
  (data) => {
    if (data?.attributes?.published_at) {
      data.attributes.published_at = new Date(data.attributes.published_at)
    }
    if (data?.meta) {
      ReleaseMetaModelResponseTransformer(data.meta)
    }
    return data
  }

export const ReleaseDataModelResponseTransformer: ReleaseDataModelResponseTransformer =
  (data) => {
    if (data?.data) {
      ReleaseModelResponseTransformer(data.data)
    }
    return data
  }

export const PublishReleaseResponseTransformer: PublishReleaseResponseTransformer =
  async (data) => {
    ReleaseDataModelResponseTransformer(data)
    return data
  }

export type GetReleasesResponseTransformer = (
  data: any,
) => Promise<GetReleasesResponse>

export type ReleaseListDataModelResponseTransformer = (
  data: any,
) => ReleaseListData

export const ReleaseListDataModelResponseTransformer: ReleaseListDataModelResponseTransformer =
  (data) => {
    if (Array.isArray(data?.data)) {
      data.data.forEach(ReleaseModelResponseTransformer)
    }
    return data
  }

export const GetReleasesResponseTransformer: GetReleasesResponseTransformer =
  async (data) => {
    ReleaseListDataModelResponseTransformer(data)
    return data
  }

export type GetReleaseByIdResponseTransformer = (
  data: any,
) => Promise<GetReleaseByIdResponse>

export const GetReleaseByIdResponseTransformer: GetReleaseByIdResponseTransformer =
  async (data) => {
    ReleaseDataModelResponseTransformer(data)
    return data
  }

export type CreateRuleResponseTransformer = (
  data: any,
) => Promise<CreateRuleResponse>

export type RuleDataModelResponseTransformer = (data: any) => RuleData

export type RuleModelResponseTransformer = (data: any) => Rule

export type RuleScheduleModelResponseTransformer = (data: any) => RuleSchedule

export const RuleScheduleModelResponseTransformer: RuleScheduleModelResponseTransformer =
  (data) => {
    if (data?.valid_from) {
      data.valid_from = new Date(data.valid_from)
    }
    if (data?.valid_to) {
      data.valid_to = new Date(data.valid_to)
    }
    return data
  }

export const RuleModelResponseTransformer: RuleModelResponseTransformer = (
  data,
) => {
  if (Array.isArray(data?.attributes?.schedules)) {
    data.attributes.schedules.forEach(RuleScheduleModelResponseTransformer)
  }
  if (data?.attributes?.created_at) {
    data.attributes.created_at = new Date(data.attributes.created_at)
  }
  if (data?.attributes?.updated_at) {
    data.attributes.updated_at = new Date(data.attributes.updated_at)
  }
  return data
}

export const RuleDataModelResponseTransformer: RuleDataModelResponseTransformer =
  (data) => {
    if (data?.data) {
      RuleModelResponseTransformer(data.data)
    }
    return data
  }

export const CreateRuleResponseTransformer: CreateRuleResponseTransformer =
  async (data) => {
    RuleDataModelResponseTransformer(data)
    return data
  }

export type GetRulesResponseTransformer = (
  data: any,
) => Promise<GetRulesResponse>

export type RuleListDataModelResponseTransformer = (data: any) => RuleListData

export const RuleListDataModelResponseTransformer: RuleListDataModelResponseTransformer =
  (data) => {
    if (Array.isArray(data?.data)) {
      data.data.forEach(RuleModelResponseTransformer)
    }
    return data
  }

export const GetRulesResponseTransformer: GetRulesResponseTransformer = async (
  data,
) => {
  RuleListDataModelResponseTransformer(data)
  return data
}

export type GetRuleByIdResponseTransformer = (
  data: any,
) => Promise<GetRuleByIdResponse>

export const GetRuleByIdResponseTransformer: GetRuleByIdResponseTransformer =
  async (data) => {
    RuleDataModelResponseTransformer(data)
    return data
  }

export type UpdateRuleResponseTransformer = (
  data: any,
) => Promise<UpdateRuleResponse>

export const UpdateRuleResponseTransformer: UpdateRuleResponseTransformer =
  async (data) => {
    RuleDataModelResponseTransformer(data)
    return data
  }

export type GetAllHierarchiesResponseTransformer = (
  data: any,
) => Promise<GetAllHierarchiesResponse>

export type HierarchyListDataModelResponseTransformer = (
  data: any,
) => HierarchyListData

export type HierarchyModelResponseTransformer = (data: any) => Hierarchy

export type HierarchyAttributesModelResponseTransformer = (
  data: any,
) => HierarchyAttributes

export const HierarchyAttributesModelResponseTransformer: HierarchyAttributesModelResponseTransformer =
  (data) => {
    if (data?.created_at) {
      data.created_at = new Date(data.created_at)
    }
    if (data?.published_at) {
      data.published_at = new Date(data.published_at)
    }
    if (data?.updated_at) {
      data.updated_at = new Date(data.updated_at)
    }
    return data
  }

export const HierarchyModelResponseTransformer: HierarchyModelResponseTransformer =
  (data) => {
    if (data?.attributes) {
      HierarchyAttributesModelResponseTransformer(data.attributes)
    }
    return data
  }

export const HierarchyListDataModelResponseTransformer: HierarchyListDataModelResponseTransformer =
  (data) => {
    if (Array.isArray(data?.data)) {
      data.data.forEach(HierarchyModelResponseTransformer)
    }
    return data
  }

export const GetAllHierarchiesResponseTransformer: GetAllHierarchiesResponseTransformer =
  async (data) => {
    HierarchyListDataModelResponseTransformer(data)
    return data
  }

export type GetHierarchyResponseTransformer = (
  data: any,
) => Promise<GetHierarchyResponse>

export type HierarchyDataModelResponseTransformer = (data: any) => HierarchyData

export const HierarchyDataModelResponseTransformer: HierarchyDataModelResponseTransformer =
  (data) => {
    if (data?.data) {
      HierarchyModelResponseTransformer(data.data)
    }
    return data
  }

export const GetHierarchyResponseTransformer: GetHierarchyResponseTransformer =
  async (data) => {
    HierarchyDataModelResponseTransformer(data)
    return data
  }

export type GetHierarchyNodesResponseTransformer = (
  data: any,
) => Promise<GetHierarchyNodesResponse>

export type NodeListDataModelResponseTransformer = (data: any) => NodeListData

export type NodeModelResponseTransformer = (data: any) => Node

export type NodeAttributesModelResponseTransformer = (
  data: any,
) => NodeAttributes

export const NodeAttributesModelResponseTransformer: NodeAttributesModelResponseTransformer =
  (data) => {
    if (data?.created_at) {
      data.created_at = new Date(data.created_at)
    }
    if (data?.published_at) {
      data.published_at = new Date(data.published_at)
    }
    if (data?.updated_at) {
      data.updated_at = new Date(data.updated_at)
    }
    return data
  }

export const NodeModelResponseTransformer: NodeModelResponseTransformer = (
  data,
) => {
  if (data?.attributes) {
    NodeAttributesModelResponseTransformer(data.attributes)
  }
  return data
}

export const NodeListDataModelResponseTransformer: NodeListDataModelResponseTransformer =
  (data) => {
    if (Array.isArray(data?.data)) {
      data.data.forEach(NodeModelResponseTransformer)
    }
    return data
  }

export const GetHierarchyNodesResponseTransformer: GetHierarchyNodesResponseTransformer =
  async (data) => {
    NodeListDataModelResponseTransformer(data)
    return data
  }

export type GetHierarchyChildNodesResponseTransformer = (
  data: any,
) => Promise<GetHierarchyChildNodesResponse>

export const GetHierarchyChildNodesResponseTransformer: GetHierarchyChildNodesResponseTransformer =
  async (data) => {
    NodeListDataModelResponseTransformer(data)
    return data
  }

export type GetAllNodesResponseTransformer = (
  data: any,
) => Promise<GetAllNodesResponse>

export const GetAllNodesResponseTransformer: GetAllNodesResponseTransformer =
  async (data) => {
    NodeListDataModelResponseTransformer(data)
    return data
  }

export type GetNodeResponseTransformer = (data: any) => Promise<GetNodeResponse>

export type NodeDataModelResponseTransformer = (data: any) => NodeData

export const NodeDataModelResponseTransformer: NodeDataModelResponseTransformer =
  (data) => {
    if (data?.data) {
      NodeModelResponseTransformer(data.data)
    }
    return data
  }

export const GetNodeResponseTransformer: GetNodeResponseTransformer = async (
  data,
) => {
  NodeDataModelResponseTransformer(data)
  return data
}

export type GetChildNodesResponseTransformer = (
  data: any,
) => Promise<GetChildNodesResponse>

export const GetChildNodesResponseTransformer: GetChildNodesResponseTransformer =
  async (data) => {
    NodeListDataModelResponseTransformer(data)
    return data
  }

export type GetAllProductsResponseTransformer = (
  data: any,
) => Promise<GetAllProductsResponse>

export type ProductListDataModelResponseTransformer = (
  data: any,
) => ProductListData

export type ProductModelResponseTransformer = (data: any) => Product

export type ProductAttributesModelResponseTransformer = (
  data: any,
) => ProductAttributes

export const ProductAttributesModelResponseTransformer: ProductAttributesModelResponseTransformer =
  (data) => {
    if (data?.published_at) {
      data.published_at = new Date(data.published_at)
    }
    if (data?.created_at) {
      data.created_at = new Date(data.created_at)
    }
    if (data?.updated_at) {
      data.updated_at = new Date(data.updated_at)
    }
    return data
  }

export type ProductRelationshipsModelResponseTransformer = (
  data: any,
) => ProductRelationships

export type FilesRelationshipModelResponseTransformer = (
  data: any,
) => FilesRelationship

export type FileReferenceModelResponseTransformer = (data: any) => FileReference

export const FileReferenceModelResponseTransformer: FileReferenceModelResponseTransformer =
  (data) => {
    if (data?.created_at) {
      data.created_at = new Date(data.created_at)
    }
    return data
  }

export const FilesRelationshipModelResponseTransformer: FilesRelationshipModelResponseTransformer =
  (data) => {
    if (Array.isArray(data?.data)) {
      data.data.forEach(FileReferenceModelResponseTransformer)
    }
    return data
  }

export const ProductRelationshipsModelResponseTransformer: ProductRelationshipsModelResponseTransformer =
  (data) => {
    if (data?.files) {
      FilesRelationshipModelResponseTransformer(data.files)
    }
    return data
  }

export type ProductMetaModelResponseTransformer = (data: any) => ProductMeta

export const ProductMetaModelResponseTransformer: ProductMetaModelResponseTransformer =
  (data) => {
    if (data?.sale_expires) {
      data.sale_expires = new Date(data.sale_expires)
    }
    return data
  }

export const ProductModelResponseTransformer: ProductModelResponseTransformer =
  (data) => {
    if (data?.attributes) {
      ProductAttributesModelResponseTransformer(data.attributes)
    }
    if (data?.relationships) {
      ProductRelationshipsModelResponseTransformer(data.relationships)
    }
    if (data?.meta) {
      ProductMetaModelResponseTransformer(data.meta)
    }
    return data
  }

export const ProductListDataModelResponseTransformer: ProductListDataModelResponseTransformer =
  (data) => {
    if (Array.isArray(data?.data)) {
      data.data.forEach(ProductModelResponseTransformer)
    }
    return data
  }

export const GetAllProductsResponseTransformer: GetAllProductsResponseTransformer =
  async (data) => {
    ProductListDataModelResponseTransformer(data)
    return data
  }

export type GetProductResponseTransformer = (
  data: any,
) => Promise<GetProductResponse>

export type ProductDataModelResponseTransformer = (data: any) => ProductData

export type IncludedModelResponseTransformer = (data: any) => Included

export const IncludedModelResponseTransformer: IncludedModelResponseTransformer =
  (data) => {
    if (Array.isArray(data?.component_products)) {
      data.component_products.forEach(ProductModelResponseTransformer)
    }
    return data
  }

export const ProductDataModelResponseTransformer: ProductDataModelResponseTransformer =
  (data) => {
    if (data?.data) {
      ProductModelResponseTransformer(data.data)
    }
    if (data?.included) {
      IncludedModelResponseTransformer(data.included)
    }
    return data
  }

export const GetProductResponseTransformer: GetProductResponseTransformer =
  async (data) => {
    ProductDataModelResponseTransformer(data)
    return data
  }

export type GetChildProductsResponseTransformer = (
  data: any,
) => Promise<GetChildProductsResponse>

export const GetChildProductsResponseTransformer: GetChildProductsResponseTransformer =
  async (data) => {
    ProductListDataModelResponseTransformer(data)
    return data
  }

export type GetProductsForHierarchyResponseTransformer = (
  data: any,
) => Promise<GetProductsForHierarchyResponse>

export const GetProductsForHierarchyResponseTransformer: GetProductsForHierarchyResponseTransformer =
  async (data) => {
    ProductListDataModelResponseTransformer(data)
    return data
  }

export type GetProductsForNodeResponseTransformer = (
  data: any,
) => Promise<GetProductsForNodeResponse>

export const GetProductsForNodeResponseTransformer: GetProductsForNodeResponseTransformer =
  async (data) => {
    ProductListDataModelResponseTransformer(data)
    return data
  }

export type GetByContextReleaseResponseTransformer = (
  data: any,
) => Promise<GetByContextReleaseResponse>

export const GetByContextReleaseResponseTransformer: GetByContextReleaseResponseTransformer =
  async (data) => {
    ReleaseDataModelResponseTransformer(data)
    return data
  }

export type GetByContextAllHierarchiesResponseTransformer = (
  data: any,
) => Promise<GetByContextAllHierarchiesResponse>

export const GetByContextAllHierarchiesResponseTransformer: GetByContextAllHierarchiesResponseTransformer =
  async (data) => {
    HierarchyListDataModelResponseTransformer(data)
    return data
  }

export type GetByContextHierarchyResponseTransformer = (
  data: any,
) => Promise<GetByContextHierarchyResponse>

export const GetByContextHierarchyResponseTransformer: GetByContextHierarchyResponseTransformer =
  async (data) => {
    HierarchyDataModelResponseTransformer(data)
    return data
  }

export type GetByContextHierarchyNodesResponseTransformer = (
  data: any,
) => Promise<GetByContextHierarchyNodesResponse>

export const GetByContextHierarchyNodesResponseTransformer: GetByContextHierarchyNodesResponseTransformer =
  async (data) => {
    NodeListDataModelResponseTransformer(data)
    return data
  }

export type GetByContextHierarchyChildNodesResponseTransformer = (
  data: any,
) => Promise<GetByContextHierarchyChildNodesResponse>

export const GetByContextHierarchyChildNodesResponseTransformer: GetByContextHierarchyChildNodesResponseTransformer =
  async (data) => {
    NodeListDataModelResponseTransformer(data)
    return data
  }

export type GetByContextAllNodesResponseTransformer = (
  data: any,
) => Promise<GetByContextAllNodesResponse>

export const GetByContextAllNodesResponseTransformer: GetByContextAllNodesResponseTransformer =
  async (data) => {
    NodeListDataModelResponseTransformer(data)
    return data
  }

export type GetByContextNodeResponseTransformer = (
  data: any,
) => Promise<GetByContextNodeResponse>

export const GetByContextNodeResponseTransformer: GetByContextNodeResponseTransformer =
  async (data) => {
    NodeDataModelResponseTransformer(data)
    return data
  }

export type GetByContextChildNodesResponseTransformer = (
  data: any,
) => Promise<GetByContextChildNodesResponse>

export const GetByContextChildNodesResponseTransformer: GetByContextChildNodesResponseTransformer =
  async (data) => {
    NodeListDataModelResponseTransformer(data)
    return data
  }

export type GetByContextAllProductsResponseTransformer = (
  data: any,
) => Promise<GetByContextAllProductsResponse>

export const GetByContextAllProductsResponseTransformer: GetByContextAllProductsResponseTransformer =
  async (data) => {
    ProductListDataModelResponseTransformer(data)
    return data
  }

export type GetByContextProductResponseTransformer = (
  data: any,
) => Promise<GetByContextProductResponse>

export const GetByContextProductResponseTransformer: GetByContextProductResponseTransformer =
  async (data) => {
    ProductDataModelResponseTransformer(data)
    return data
  }

export type GetByContextChildProductsResponseTransformer = (
  data: any,
) => Promise<GetByContextChildProductsResponse>

export const GetByContextChildProductsResponseTransformer: GetByContextChildProductsResponseTransformer =
  async (data) => {
    ProductListDataModelResponseTransformer(data)
    return data
  }

export type GetByContextProductsForHierarchyResponseTransformer = (
  data: any,
) => Promise<GetByContextProductsForHierarchyResponse>

export const GetByContextProductsForHierarchyResponseTransformer: GetByContextProductsForHierarchyResponseTransformer =
  async (data) => {
    ProductListDataModelResponseTransformer(data)
    return data
  }

export type GetByContextProductsForNodeResponseTransformer = (
  data: any,
) => Promise<GetByContextProductsForNodeResponse>

export const GetByContextProductsForNodeResponseTransformer: GetByContextProductsForNodeResponseTransformer =
  async (data) => {
    ProductListDataModelResponseTransformer(data)
    return data
  }

export type ConfigureByContextProductResponseTransformer = (
  data: any,
) => Promise<ConfigureByContextProductResponse>

export const ConfigureByContextProductResponseTransformer: ConfigureByContextProductResponseTransformer =
  async (data) => {
    ProductDataModelResponseTransformer(data)
    return data
  }
