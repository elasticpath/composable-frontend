// This file is auto-generated by @hey-api/openapi-ts

/**
 * The three-letter ISO code for the currency associated with this price.
 */
export type Amount = {
  /**
   * The price in the lowest denomination for the specified currency. This is a product's list price.
   */
  amount?: BigInt
  /**
   * Whether this price includes tax.
   */
  includes_tax?: boolean
}

/**
 * If you want multiple price books for different scenarios, such as seasonal sales, business versus retail pricing, and reward programs, when creating a catalog, you can specify up to five price books. You must configure a priority for your price books. Product prices are displayed in the catalog according to the priority of the price books.
 */
export type PrioritizedPricebooks = Array<{
  /**
   * A unique identifier of a price book.
   */
  id: string
  /**
   * Priority is a number and the price book with the highest number has the highest priority.
   */
  priority: number
}>

/**
 * The owner of this resource, can be either `organization` or `store`.
 */
export type Owner = "store" | "organization"

/**
 * Creates a catalog with the following attributes.
 */
export type Catalog = {
  /**
   * A unique identifier of a catalog.
   */
  id: string
  attributes: {
    /**
     * The name of a catalog.
     */
    name: string
    /**
     * A brief description of the catalog, such as the purpose of the catalog.
     */
    description?: string
    /**
     * The unique identifiers of the hierarchies associated with a catalog.
     */
    hierarchy_ids: Array<string>
    /**
     * The unique identifier of a price book associated with a catalog. If no price book is selected, the catalog is displayed without prices.
     */
    pricebook_id?: string
    pricebook_ids?: PrioritizedPricebooks
    /**
     * Product Experience Manager supports localization of products and hierarchies. If you store supports multiple languages, you can localize product names and descriptions.
     */
    locales?: {
      [key: string]: {
        [key: string]: string
      }
    }
    /**
     * The date and time a catalog is created.
     */
    created_at: Date
    /**
     * The date and time a catalog was updated.
     */
    updated_at: Date
    /**
     * The owner of this resource, can be either `organization` or `store`.
     */
    owner?: "store" | "organization"
    /**
     * This indicates whether the catalog will support price segmentation using catalog rules to define which pricebook(s) to use for pricing
     */
    enable_price_segmentation?: boolean
  }
  /**
   * Relationships are established between different catalog entities. For example, a catalog rule and a price book are related to a catalog, as both are associated with it.
   */
  relationships?: {
    /**
     * The catalog rules related to a catalog.
     */
    rules?: {
      links?: RelatedLink
    }
    /**
     * When a catalog is published, a catalog release is created. This is a URL to all catalog published releases available for this catalog.
     */
    releases?: {
      links?: RelatedLink
      meta?: {
        /**
         * The number releases available for a catalog.
         */
        count?: number
      }
    }
  }
  type: "catalog"
}

/**
 * Creates a catalog with the following attributes.
 */
export type CatalogCreateData = {
  data: {
    attributes: {
      /**
       * The name of the catalog.
       */
      name: string
      /**
       * A brief description of the catalog.
       */
      description?: string | null
      /**
       * The unique identifiers of the hierarchies to associate with a catalog.
       */
      hierarchy_ids: Array<string>
      /**
       * The unique identifier of the price book to associate with this catalog. You can specify either a `pricebook_id` or `pricebook_ids` but not both. If you specify both a `pricebook_id` and `pricebook_ids`, a `422 Unprocessable Entity` error is displayed.
       *
       */
      pricebook_id?: string
      pricebook_ids?: PrioritizedPricebooks
      /**
       * Product Experience Manager supports localization of products and hierarchies. If you store supports multiple languages, you can localize product names and descriptions.
       */
      locales?: {
        [key: string]: {
          [key: string]: string
        }
      }
      /**
       * This indicates whether the catalog will support price segmentation using catalog rules to define which pricebook(s) to use for pricing
       */
      enable_price_segmentation?: boolean
    }
    /**
     * Represents the type of object being returned. Always `Catalog`.
     */
    type: "catalog"
  }
}

/**
 * Container for a single catalog.
 */
export type CatalogData = {
  data: Catalog
  links?: Links
}

/**
 * Container for a list of catalogs.
 */
export type CatalogListData = {
  data: Array<Catalog>
  meta?: PageMeta
  links?: Links
}

/**
 * A catalog combines price books, product lists, and hierarchies.
 */
export type CatalogUpdateData = {
  data: {
    attributes: {
      /**
       * The name of the catalog.
       */
      name?: string | null
      /**
       * A brief description of the catalog.
       */
      description?: string | null
      /**
       * The unique identifiers of the hierarchies to associate with a catalog.
       */
      hierarchy_ids?: Array<string> | null
      /**
       * The unique identifier of a price book to associate with a catalog. You can specify a `pricebook_id` or a `pricebook_ids` but not both. If you specify both, a `422 unprocessable entity` error is displayed.
       */
      pricebook_id?: string | null
      pricebook_ids?: PrioritizedPricebooks
      /**
       * Product Experience Manager supports localization of products and hierarchies. If you store supports multiple languages, you can localize product names and descriptions.
       */
      locales?: {
        [key: string]: {
          [key: string]: string
        }
      }
      /**
       * This indicates whether the catalog will support price segmentation using catalog rules to define which pricebook(s) to use for pricing
       */
      enable_price_segmentation?: boolean
    }
    /**
     * The unique identifier of the catalog to be updated.
     */
    id: string
    /**
     * This represents the type of object being returned. Always `catalog`.
     */
    type: "catalog"
  }
}

/**
 * The unique identifier of the component, for example, `games`.
 */
export type ComponentProduct = {
  /**
   * The component name is the name that is displayed in your storefront.
   */
  name?: string
  /**
   * The minimum number of product options a shopper can select from this component.
   */
  min?: number | null
  /**
   * The maximum number of product options a shopper can select from this component.
   */
  max?: number | null
  /**
   * The sort order of the components. The `create a bundle` and `update a bundle` endpoints do not sort the components. You can use the `sort_order` attribute when programming your storefront to display the components in the order that you want.
   */
  sort_order?: number | null
  /**
   * The product options included in a component. This can be the ID of another bundle.
   */
  options?: Array<ComponentProductOption>
}

/**
 * The product options included in a component. This can be the ID of another bundle.
 */
export type ComponentProductOption = {
  /**
   * A unique identifier of the product you want to add to a component.
   */
  id?: string
  /**
   * This represents the type of object being returned. Always `product`.
   */
  type?: "product"
  /**
   * The number of this product option that a shopper must purchase.
   */
  quantity?: number
  /**
   * The minimum quantity of this product option that a shopper can select.
   */
  min?: number | null
  /**
   * The maximum quantity of this product option that a shopper can select.
   */
  max?: number | null
  /**
   * The sort order of the options. The `create a bundle` and `update a bundle` endpoints do not sort the options. You can use the `sort_order` attribute when programming your storefront to display the options in the order that you want.
   */
  sort_order?: number | null
  /**
   * The boolean indicates whether the current option is a default option for the component.
   */
  default?: boolean | null
  /**
   * Indicates that the parent product added to a bundle is not directly purchasable. When set to true, the child products of the parent product should be displayed as options for selection in the bundle.
   */
  product_should_be_substituted_with_child?: boolean | null
  /**
   * Merchants can exclude specific child products from a parent product when configuring a bundle.
   */
  excluded_children?: Array<string>
}

/**
 * A bundle is a purchasable product, comprising of one or more products that you want to sell together. You can create multiple components within a bundle. Each component must have at least one or more options. Each option is a product and a quantity.
 */
export type Components = {
  [key: string]: ComponentProduct
}

/**
 * The length of the custom input text field.
 */
export type CustomInputValidationRuleOptions = {
  /**
   * The number of characters the custom text field can be. You can specify a maximum length up to 255 characters, as the limit is 255 characters.
   */
  max_length?: number
}

/**
 * The validation rules for the custom text.
 */
export type CustomInputValidationRule = {
  /**
   * This represents the type of object being returned. Must be `string`.
   */
  type?: "string"
  options?: CustomInputValidationRuleOptions
}

/**
 * The name of the custom input. You can rename the input to something more representative of the input that shoppers are adding, for example, `message` or `front`.
 */
export type CustomInput = {
  /**
   * The name for the custom text field that is displayed in your storefront.
   */
  name?: string
  /**
   * The validation rules for the custom text.
   */
  validation_rules?: Array<CustomInputValidationRule>
  /**
   * This is `true` or `false` depending on whether the custom text is required.
   */
  required?: boolean | null
}

/**
 * You can allow your shoppers to add custom text to a product when adding product items to their carts. This is useful, for example, if you have a product like a T-shirt that can be personalized or you sell greetings cards that can be printed with your shoppers personalized messages.  You can do this using the `custom_inputs` attribute.
 *
 * - You can rename input to something more representative of the input that shoppers are adding, for example, `message` or `front`.
 * - `name` is the name that is displayed in your storefront.
 * - You can add validation rules. For example, the input field must be a string and/or up to 255 characters in length. The limit is 255 characters.
 *
 */
export type CustomInputs = {
  [key: string]: CustomInput
}

/**
 * A collection of one or more currencies objects that consists of the [**three-letter ISO code**](https://www.iso.org/iso-3166-country-codes.html) of the currencies associated with this price and the amount. This is the product's price.
 */
export type Currencies = {
  [key: string]: Amount
}

/**
 * A collection of key-value string pairs, viewable by shoppers.
 */
export type ShopperAttributes = {
  [key: string]: string
}

/**
 * A list of differences between two releases.
 */
export type DiffListData = {
  data?: Array<ProductDiff>
  links?: Links
}

/**
 * A price formatted for display.
 */
export type DisplayPrice = {
  with_tax?: FormattedPrice
  without_tax?: FormattedPrice
}

/**
 * APIError is a json-api style part of an error response.
 */
export type _Error = {
  detail?: string
  status?: string
  title?: string
}

/**
 * ErrorResponse is a json-api style Error response.
 */
export type ErrorResponse = {
  errors?: Array<_Error>
}

/**
 * The name of the product template.
 */
export type Extension = {
  [key: string]: {
    [key: string]: unknown
  }
}

/**
 * With extension templates, you can attach a specific set of custom fields to your products in Product Experience Manager. For example, a **Book** template might contain the attributes, such as **ISBN**, **Author**, **Number of pages**, **Year Published**, or **Condition (New/Used)**.
 */
export type Extensions = {
  [key: string]: Extension
}

/**
 * In Product Experience Manager, products can have associated rich media assets, such as product images or a file containing additional product details.
 */
export type FileReference = {
  /**
   * This represents the type of object being returned. Always `file`.
   */
  type?: "file"
  /**
   * A unique identifier for a file.
   */
  id?: string
  /**
   * The date and time a file is created.
   */
  created_at?: Date
}

/**
 * In Product Experience Manager, products can have associated rich media assets, such as product images or a file containing additional product details.
 */
export type FilesRelationship = {
  data?: Array<FileReference>
}

/**
 * A bundle is a purchasable product, comprising of one or more products that you want to sell together. You can create multiple components within a bundle. Each component must have at least one or more options. Each option is a product and a quantity. You can link to the products that make up your bundle components.
 */
export type ComponentProductsRelationship = {
  data?: ProductReferences
  links?: SelfLink
}

/**
 * A product can have custom relationships added that link to other products. These can be used for Parent/Child relationships as well as products that you want to Cross Sell/Promote.
 */
export type CustomRelationship = {
  data?: ProductReferences
  links?: CustomRelationshipLinks
}

/**
 * A price formatted for display.
 */
export type FormattedPrice = {
  /**
   * The price in the lowest denomination for the specified currency. This is a product's list price.
   */
  amount?: number
  /**
   * The three-letter ISO code of the currencies associated with this price and the amount.
   */
  currency?: string
  /**
   * The format of the price for display.
   */
  formatted?: string
}

/**
 * A category hierarchy in a catalog. Hierarchies can have parent nodes and child nodes, as well as a list of attached products.
 */
export type Hierarchy = {
  attributes?: HierarchyAttributes
  /**
   * A unique identifier of a hierarchy.
   */
  id?: string
  relationships?: HierarchyRelationships
  /**
   * This represents the type of object being returned. Always `hierarchy`.
   */
  type?: string
  meta?: HierarchyMeta
}

/**
 * A hierarchy's metadata.
 */
export type HierarchyMeta = {
  /**
   * Product Experience Manager supports localization of hierarchies. If your store supports multiple languages, you can localize hierarchy names and descriptions. This is [**three-letter language code**](https://www.iso.org/iso-639-language-code) that represents the name of the language you have used.
   */
  language?: string
  /**
   * Hierarchy Breadcrumbs
   */
  breadcrumbs?: Array<{
    /**
     * The unique identifier of a hierarchy.
     */
    id?: string
    /**
     * The name of the hierarchy.
     */
    name?: string
    /**
     * A slug for the hierarchy.
     */
    slug?: string
  }>
  /**
   * Indicates whether a node has child nodes. `true` if the node has at least one child, `false` if it has none.
   */
  has_children?: boolean | null
}

/**
 * Resource attributes of a catalog hierarchy.
 */
export type HierarchyAttributes = {
  /**
   * The date and time a hierarchy is created.
   */
  created_at?: Date
  /**
   * The date and time a hierarchy is published in a catalog.
   */
  published_at?: Date | null
  /**
   * A description of a hierarchy.
   */
  description?: string
  /**
   * The name of a hierarchy.
   */
  name?: string
  /**
   * A unique slug for a hierarchy.
   */
  slug?: string
  shopper_attributes?: ShopperAttributes
  /**
   * The date and time a hierarchy was updated.
   */
  updated_at?: Date
}

/**
 * Container for hierarchies.
 */
export type HierarchyData = {
  data?: Hierarchy
  links?: Links
}

/**
 * Container for a list of hierarchies.
 */
export type HierarchyListData = {
  meta?: PageMeta
  data?: Array<Hierarchy>
  links?: Links
}

/**
 * Relationships to child nodes, and products.
 */
export type HierarchyRelationships = {
  /**
   * A URL to all the products associated with a hierarchy.
   */
  products?: {
    links?: RelatedLink
  }
  /**
   * A URL to all the child products associated with a hierarchy.
   */
  children?: {
    links: RelatedLink
  }
  /**
   * A URL to all the nodes associated with a hierarchy.
   */
  nodes?: {
    links: RelatedLink
  }
}

/**
 * Links allow you to move between requests.
 */
export type Links = {
  /**
   * Single entities use a `self` parameter with a link the specific resource.
   */
  self?: string | null
  /**
   * Always the first page.
   */
  first?: string | null
  /**
   * This is `null` if there is only one page.
   */
  last?: string | null
  /**
   * This is `null` if there is only one page.
   */
  prev?: string | null
  /**
   * This is `null` if there is only one page.
   */
  next?: string | null
}

/**
 * Included is an array of resources that are included in the response.
 */
export type IncludedResponse = {
  /**
   * The main images associated with a product.
   */
  main_images?: Array<ElasticPathFile>
  /**
   * Returns a list of component products in a product bundle. If a bundle has no component products (in other words, is not a product bundle), an empty array is returned.
   */
  component_products?: Array<Product>
  /**
   * The files associated with a product.
   */
  files?: Array<ElasticPathFile>
}

export type ElasticPathFile = {
  /**
   * The unique identifier for this file.
   */
  id?: string
  /**
   * The type represents the object being returned.
   */
  type?: string
  /**
   * The name of the file.
   */
  file_name?: string
  /**
   * The mime type of the file.
   */
  mime_type?: string
  /**
   * The size of the file. Required when uploading files.
   */
  file_size?: number
  /**
   * DEPRECATED Whether the file public or not. Required when uploading files.
   */
  public?: boolean
  meta?: {
    /**
     * The date and time the file was created.
     */
    timestamps?: {
      /**
       * The date and time the file was created.
       */
      created_at?: string
    }
    /**
     * The file dimensions.
     */
    dimensions?: {
      /**
       * The width of the file.
       */
      width?: number
      /**
       * The height of the file.
       */
      height?: number
    }
  }
  /**
   * Links are used to allow you to move between requests.
   */
  links?: {
    /**
     * Single entities use a self parameter with a link to that specific resource.
     */
    self?: string
  }
  /**
   * The publicly available URL for this file.
   */
  link?: {
    /**
     * The publicly available URL for this file.
     */
    href?: string
    meta?: {
      /**
       * Contains the results for the entire collection.
       */
      results?: {
        /**
         * Total number of results for the entire collection.
         */
        total?: number
      }
    }
  }
}

/**
 * In Product Experience Manager, products can also have associated product images.
 */
export type MainImageRelationship = {
  /**
   * The images associated with a product.
   */
  data?: {
    /**
     * This represents the type of object being returned. Always `main_image`.
     */
    type?: "main_image"
    /**
     * A unique identifier for an image.
     */
    id?: string
  }
}

/**
 * A category node in a catalog. Nodes can have child nodes, as well as a list of attached products.
 */
export type Node = {
  attributes?: NodeAttributes
  /**
   * The unique identifier of a node.
   */
  id?: string
  relationships?: NodeRelationships
  /**
   * This represents the type of object being returned. Always `node`.
   */
  type?: string
  meta?: NodeMeta
}

/**
 * Resource attributes of a catalog node.
 */
export type NodeAttributes = {
  /**
   * The date and time a node was created.
   */
  created_at?: Date
  /**
   * The date and time a node was published in a catalog.
   */
  published_at?: Date | null
  /**
   * A description of a node.
   */
  description?: string
  label?: string
  /**
   * The name of a node. Names must be unique among sibling nodes in a hierarchy. Otherwise, a name can be non-unique within the hierarchy and across multiple hierarchies.
   */
  name?: string
  /**
   * A slug for the node. Slugs must be unique among sibling nodes in the hierarchy. Otherwise, a slug can be non-unique within the hierarchy and across multiple hierarchies.
   */
  slug?: string
  /**
   * A list of curated products for a node. You can curate your products in your nodes product lists. Product curation allows you to promote specific products within each node in a hierarchy, enabling you to create unique product collections in your storefront.
   */
  curated_products?: Array<string>
  status?: string
  shopper_attributes?: ShopperAttributes
  /**
   * The date and time a node was updated.
   */
  updated_at?: Date
}

/**
 * Container for nodes.
 */
export type NodeCreateData = {
  /**
   * A node in a catalog (e.g. a category node). Nodes can have child nodes, as well as a list of attached products
   */
  data: {
    /**
     * Resource attributes of a catalog node.
     */
    attributes: {
      description?: string
      /**
       * hierarchy id of the node
       */
      hierarchy_id?: string
      label?: string
      name: string
      slug?: string
      status?: string
      locales?: {
        [key: string]: {
          [key: string]: string
        }
      }
    }
    relationships?: NodeRelationships
    id?: string
    type: string
  }
  links?: Links
}

/**
 * Container for nodes.
 */
export type NodeData = {
  data?: Node
  links?: Links
}

/**
 * Container for a list of nodes.
 */
export type NodeListData = {
  meta?: PageMeta
  data?: Array<Node>
  links?: Links
}

/**
 * A node's metadata.
 */
export type NodeMeta = {
  /**
   * The node details localized in the supported languages.
   */
  language?: string
  /**
   * Helps you understand the association of products with nodes. It explains how products are associated with parent nodes and the relationship among the array of nodes. This is useful if you want to improve how your shoppers search within you store.
   * @deprecated
   */
  bread_crumb?: Array<string>
  /**
   * Node Breadcrumbs
   */
  breadcrumbs?: Array<{
    /**
     * The unique identifier of a hierarchy/node.
     */
    id?: string
    /**
     * The name of the hierarchy/node.
     */
    name?: string
    /**
     * A slug for the hierarchy/node.
     */
    slug?: string
  }>
  /**
   * Indicates whether a node has child nodes. `true` if the node has at least one child, `false` if it has none.
   */
  has_children?: boolean | null
}

/**
 * Minimum set of information to identify a catalog node.
 */
export type NodeReference = {
  /**
   * The unique identifier of a hierarchy.
   */
  id?: string
  /**
   * A label for a hierarchy.
   */
  label?: string
  /**
   * The name of a hierarchy.
   */
  name?: string
}

/**
 * Relationships to parent and child nodes, and products.
 */
export type NodeRelationships = {
  /**
   * A URL to all products associated with a node.
   */
  products?: {
    data?: Array<ProductReference>
    links?: RelatedLink
  }
  /**
   * A URL to all child nodes associated with a node.
   */
  children?: {
    links: RelatedLink
  }
  /**
   * A URL to all parent nodes associated with a node.
   */
  parent?: {
    data: {
      type: "node"
      id: string
    }
    links?: RelatedLink
  }
  /**
   * A URL to the hierarchies associated with a node.
   */
  hierarchy?: {
    data: {
      type: "hierarchy"
      id: string
    }
    links?: RelatedLink
  }
}

/**
 * Container for node relationships.
 */
export type NodeRelationshipsData = {
  data?: NodeRelationships
  links?: Links
}

/**
 * Contains the results for the entire collection.
 */
export type PageMeta = {
  /**
   * Total number of results for the entire collection.
   */
  results?: {
    /**
     * Total number of results for the entire collection.
     */
    total?: BigInt
  }
  page?: {
    /**
     * The maximum number of records for all pages.
     */
    limit?: BigInt
    /**
     * The current offset by number of pages.
     */
    offset?: BigInt
    /**
     * The current number of pages.
     */
    current?: BigInt
    /**
     * The total number of records for the entire collection.
     */
    total?: BigInt
  }
}

/**
 * Top level entity in the pricebooks domain model. It contains a list of product prices.
 */
export type Pricebook = {
  /**
   * The unique identifier of a price book.
   */
  id?: string
  /**
   * This represents the type of object being returned. Always `pricebook`.
   */
  type: "pricebook"
  attributes: {
    created_at?: Date
    description?: string | null
    name: string | null
    updated_at?: Date
  }
}

/**
 * Container for pricebooks.
 */
export type PricebookCreateData = {
  /**
   * New top level pricebook.
   */
  data: {
    type: "pricebook"
    attributes: {
      description?: string | null
      name: string | null
    }
  }
  links?: Links
}

/**
 * Container for pricebooks.
 */
export type PricebookData = {
  data: Pricebook
  links?: Links
}

/**
 * ProductPrice associates a collection of locale specific prices with a product ID.
 */
export type PricebookPrice = {
  type: "product-price"
  attributes: {
    currencies: TieredCurrencies
    sales?: Sales
    sku: string
  }
  id: string
}

/**
 * Container for pricebook prices.
 */
export type PricebookPriceCreateData = {
  /**
   * ProductPrice associates a collection of locale specific prices with a product ID.
   */
  data: {
    type: "product-price"
    attributes: {
      currencies: TieredCurrencies
      sales?: Sales
      sku: string
    }
  }
  links?: Links
}

/**
 * Container for pricebook prices.
 */
export type PricebookPriceData = {
  data: PricebookPrice
  links?: Links
}

/**
 * A product in a catalog with the following attributes.
 */
export type Product = {
  attributes?: ProductAttributes
  /**
   * A unique identifier for a product.
   */
  id?: string
  relationships?: ProductRelationships
  /**
   * This represents the type of object being returned. Always `product`.
   */
  type?: string
  meta?: ProductMeta
}

/**
 * A product's attributes.
 */
export type ProductAttributes = {
  /**
   * The date and time a product was published in a catalog.
   */
  published_at?: Date | null
  /**
   * If this product is a `parent` product. A `parent` product is a product that has child products that have been built using the `build child products` endpoint.
   */
  base_product?: boolean
  /**
   * The unique identifier of a `parent` product.
   */
  base_product_id?: string
  /**
   * The commodity type, either `physical` or `digital`.
   */
  commodity_type?: string
  /**
   * If a product is curated, then the `curated_product` attribute with a value of `true` is displayed. If a product is not curated, the `curated_product` attribute is not displayed.
   */
  curated_product?: boolean
  /**
   * The universal product code or european article number of the product.
   */
  upc_ean?: string
  /**
   * The manufacturer part number of the product.
   */
  manufacturer_part_num?: string
  /**
   * A list of tags associated with the product. A tag must be HTML compatible characters excluding commas and will be stored in lowercase letters.
   */
  tags?: Array<string>
  /**
   * A list of price modifier names.
   */
  price_modifiers?: Array<string>
  /**
   * The date and time a product was created.
   */
  created_at?: Date
  /**
   * A description of the product.
   */
  description?: string
  /**
   * A name of a product.
   */
  name?: string
  price?: Currencies
  shopper_attributes?: ShopperAttributes
  tiers?: Tiers
  components?: Components
  custom_inputs?: CustomInputs
  /**
   * The unique stock keeping unit of the product.
   */
  sku?: string
  /**
   * A label for the product that is used in the URL paths. A slug can contain A to Z, a to z, 0 to 9, hyphen, underscore, and period. Spaces or other special characters like ^, [], *, and $ are not allowed. By default, the product name is used as the slug.
   */
  slug?: string
  /**
   * The status of the product, either `live` or `draft`.
   */
  status?: string
  /**
   * The unique attribute associated with the product. This could be an external reference from a separate company system, for example.
   */
  external_ref?: string | null
  /**
   * The date and time a product was updated.
   */
  updated_at?: Date
  extensions?: Extensions
}

/**
 * Container for products.
 */
export type ProductCreateData = {
  /**
   * A new product in a catalog.
   */
  data?: {
    /**
     * A product's attributes.
     */
    attributes: {
      description?: string
      name: string
      sku?: string
      slug?: string
      status: string
      locales?: {
        [key: string]: {
          [key: string]: string
        }
      }
    }
    id?: string
    type: string
  }
  links?: Links
}

/**
 * Container for products.
 */
export type ProductData = {
  data?: Product
  included?: IncludedResponse
  links?: Links
}

export type ProductDiff = {
  id?: string
  type?: string
  attributes?: {
    sku?: string
    this_release_id?: string
    other_release_id?: string
    diff_created_at?: Date
    exists?: {
      this: boolean
      other: boolean
    }
    updated_at?: {
      this?: Date | null
      other?: Date | null
    }
  }
}

/**
 * Container for a list of products.
 */
export type ProductListData = {
  meta?: PageMeta
  data?: Array<Product>
  included?: IncludedResponse
  links?: Links
}

/**
 * A product's metadata contains information about products, for example, the nodes a product is associated with, any child products, bundle configurations, and so on.
 */
export type ProductMeta = {
  /**
   * The relationship among the array of nodes a product is associated with, demonstrating the linking of the children nodes with the parent nodes. Up to 10 levels of parent nodes are displayed, depending on the number of levels of parent nodes you have.
   */
  bread_crumbs?: {
    [key: string]: Array<string>
  }
  /**
   * An array of parent node IDs that a product is associated with. Up to 10 levels of parent nodes are displayed, depending on the number of levels of parent nodes you have.
   */
  bread_crumb_nodes?: Array<string>
  /**
   * A unique identifier of the catalog a product is associated with.
   */
  catalog_id?: string
  /**
   * The unique identifier of the price book a product is associated with.
   */
  pricebook_id?: string | null
  display_price?: DisplayPrice
  /**
   * The source of a catalog. Always `pim`.
   */
  catalog_source?: "pim"
  /**
   * With sales pricing, a store can optionally add a sale price to a product price. For example, a store can schedule seasonal pricing on products without creating a new price book and catalog ruleset. Optionally, a store can schedule the date ranges for the sale products. This is the unique identifier of a sale.
   */
  sale_id?: string
  /**
   * The date and time a sale expires.
   */
  sale_expires?: Date | null
  original_price?: Currencies
  original_display_price?: DisplayPrice
  bundle_configuration?: BundleConfiguration
  /**
   * A bundle is a purchasable product, comprising of one or more products that you want to sell together. You can create multiple components within a bundle. Each component must have at least one or more options. Each option is a product and a quantity.
   */
  component_products?: {
    [key: string]: {
      /**
       * With sales pricing, a store can optionally add a sale price to a product price. For example, a store can schedule seasonal pricing on products without creating a new price book and catalog ruleset. Optionally, a store can schedule the date ranges for the sale products. This is the unique identifier of a sale.
       */
      sale_id?: string
      /**
       * The date and time a sale expires.
       */
      sale_expires?: Date | null
      price?: Currencies
      display_price?: DisplayPrice
      original_price?: Currencies
      original_display_price?: DisplayPrice
      pricebook_id?: string | null
    }
  }
  /**
   * This will contain the component product details (with bundle specific pricing) in the configure bundle response for the selected options.
   */
  component_product_data?: {
    [key: string]: Product
  }
  /**
   * You can use price modifiers to change the price property of child products. By default, child products inherit the same price as their base products. Using price modifiers, you can enable child products to inherit a different price.
   */
  price_modifiers?: {
    [key: string]: {
      /**
       * There are three modifier types.
       *
       * - The `price_increment` type increases the prices of a product.
       * - The `price_decrement` type decreases the price of a product.
       * - The `price_equals` type sets the price of a product to an amount you specify.
       *
       */
      modifier_type?: string
      currencies?: Currencies
    }
  }
  /**
   * You can use tiers to allow your store to offer different pricing for minimum quantities of items that your shoppers purchase.
   */
  tiers?: {
    [key: string]: {
      /**
       * The unique identifier of a sale.
       */
      sale_id?: string
      /**
       * The date and time a sale expires.
       */
      sale_expires?: Date | null
      display_price?: DisplayPrice
      original_price?: Currencies
      original_display_price?: DisplayPrice
    }
  }
  /**
   * The `variation_matrix` object lists the variation IDs and variation option IDs and their corresponding product IDs that are generated when the variation and variation options are built with a product. If no variations are available, the `variation_matrix` is empty.
   */
  variation_matrix?: {
    [key: string]: unknown
  }
  /**
   * If you specified `build_rules` for a product, the `variations` object lists the variation option IDs that you specified to include when building your child products. If no `build_rules` are specified, all the variation and variation options available for a product are displayed. If a product does not have any variations, then the `variations` object is not displayed.
   */
  variations?: Array<Variation>
  /**
   * An array of variation options IDs that a child product has.
   */
  child_option_ids?: Array<string> | null
  /**
   * If this is a child product, the `child_variations` object lists the variation option IDs that define this child product.
   */
  child_variations?: Array<Variation> | null
  /**
   * Commerce automatically assigns types to the products you create. In Commerce Manager, you can see at a glance the product types in a list of a products. In addition, you can filter on product types in both the API and Commerce Manager.
   *
   * Product types can also be used in catalogs. For example, in your catalog, you can filter on parent so that only your parent products are displayed in your storefront.
   *
   * Products have one of the following types:
   *
   * - **standard** - Standard products are a standalone products.
   * - **parent** - A parent product is a product that has child products that have been built using the `Build Child Products` endpoint.
   * - **child** - When you configure product variations and variation options for parent products, the child products derived from the parent products are automatically created in Commerce.
   * - **bundle** - A bundle is a purchasable product, comprising two or more standalone products (in other words, components) to be sold together.
   *
   */
  product_types?: Array<string>
  /**
   * If you storefront supports multiple languages, your storefront's preferred language and locale.
   */
  language?: string
  /**
   * In Commerce Manager you can define Custom Relationships for Products. These allow Merchandisers to set up Cross Sell/Parent Child Relationships between products for display to shoppers.
   * This field will list the slugs(identifiers) of Custom Relationships that have been associated with this product. This will allow conditional rendering of related product sections if needed
   * and provides the slug(s) needed to list the related products for the Product
   *
   */
  custom_relationships?: Array<string>
}

/**
 * The options available for a variation.
 */
export type VariationOption = {
  /**
   * A unique identifier for an option.
   */
  id?: string
  /**
   * The name of the option.
   */
  name?: string
  /**
   * If you specified a `sort_order` when creating your variations and variation options, then use the `sort_order` value to program your storefront to display the variations and variation options in the order that you want.
   */
  sort_order?: number | null
  /**
   * The option description to display to customers.
   */
  description?: string
}

export type Variation = {
  /**
   * A unique identifier of a variation.
   */
  id?: string
  /**
   * The name of a variation.
   */
  name?: string
  /**
   * If you specified a `sort_order` when creating your variations and variation options, then use the `sort_order` value to program your storefront to display the variations and variation options in the order that you want.
   */
  sort_order?: number | null
  option?: VariationOption
  /**
   * The options available for this variation.
   */
  options?: Array<VariationOption>
}

/**
 * Container for a bundle configuration.
 */
export type BundleConfigurationData = {
  data: BundleConfiguration
}

/**
 * A bundle is a purchasable product, comprising of one or more products that you want to sell together. You can create multiple components within a bundle. Each component must have at least one or more options. Each option is a product and a quantity.
 */
export type BundleConfiguration = {
  /**
   * The product options included in a component. This can be the ID of another bundle.
   */
  selected_options: {
    [key: string]: {
      [key: string]: BigInt
    }
  }
}

/**
 * A product identifier.
 */
export type ProductReference = {
  /**
   * A unique identifier for a product.
   */
  id?: string
  /**
   * This represents the type of object being returned. Always `product`.
   */
  type?: "product"
}

/**
 * Container for a list of product references.
 */
export type ProductReferenceListData = {
  meta?: PageMeta
  data?: ProductReferences
  links?: Links
}

/**
 * A list of product identifiers.
 */
export type ProductReferences = Array<ProductReference>

/**
 * Relationships allow you to move between requests. Includes links to the parent and child products, bundle component products, files, and main images associated with a product.
 */
export type ProductRelationships = {
  /**
   * The details of a `parent` product. A `parent` product is a product that has child products that have been built using the `Build Child Products` endpoint.
   */
  parent?: {
    data?: ProductReference
  }
  /**
   * The details of a `child` product. When you configure product variations and variation options for parent products, the child products derived from the parent products are automatically created in Commerce.
   */
  children?: {
    data?: ProductReferences
    links?: SelfLink
  }
  files?: FilesRelationship
  main_image?: MainImageRelationship
  component_products?: ComponentProductsRelationship
  custom_relationships?: CustomRelationship
}

/**
 * Container for product relationships.
 */
export type ProductRelationshipsData = {
  data?: ProductRelationships
  links?: Links
}

/**
 * A list of products to be added to cart. Can be type product-data or error-response.
 */
export type ProductsForCart = {
  data: Array<unknown>
  included?: {
    component_products?: Array<Product>
  } | null
}

/**
 * A list of product id or sku and bundle configuration for cart.
 */
export type ProductsForCartConfiguration = {
  data: Array<{
    id?: string | null
    sku?: string | null
    bundle_configuration?: BundleConfiguration
  }>
}

/**
 * A URL to a related object, for example, catalog rules, hierarchies, price books, products and deltas.
 */
export type RelatedLink = {
  /**
   * A URL to a related object, for example, catalog rules, hierarchies, price books, products and deltas.
   */
  related: string
}

/**
 * For each custom relationship in use on the product, there will be a link to follow.
 */
export type CustomRelationshipLinks = {
  [key: string]: unknown
}

/**
 * Links are used to allow you to move between requests.
 */
export type SelfLink = {
  /**
   * Single entities use a self parameter with a link to that specific resource.
   */
  self: string
}

/**
 * A catalog release represents a collection of hierarchical product data, price books and catalogs rules.
 */
export type Release = {
  /**
   * A unique identifier for the catalog release.
   */
  id?: string
  attributes?: {
    /**
     * The name of a release.
     */
    name?: string
    /**
     * The date and time a release was published.
     */
    published_at?: Date | null
    /**
     * A unique identifier for the catalog.
     */
    catalog_id?: string
    /**
     * A description of the catalog release.
     */
    description?: string
    /**
     * An array of hierarchy IDs associated with the release.
     */
    hierarchies?: Array<NodeReference>
  }
  relationships?: ReleaseRelationships
  /**
   * This represents the type of object being returned. Always `catalog-release`.
   */
  type?: string
  meta?: ReleaseMeta
}

/**
 * Container for a catalog release.
 */
export type ReleaseData = {
  data?: Release
  links?: Links
}

/**
 * Container for a list of catalog releases.
 */
export type ReleaseListData = {
  data?: Array<Release>
  links?: Links
}

/**
 * The status of the current release.
 */
export type ReleaseStatus = "PENDING" | "IN_PROGRESS" | "FAILED" | "PUBLISHED"

/**
 * A release's metadata.
 */
export type ReleaseMeta = {
  /**
   * The date and time a release is created.
   */
  created_at?: Date
  /**
   * The date and time a release is available for use. In other words, the date and time the status of a catalog release changes to PUBLISHED, rather than IN PROGRESS.
   */
  started_at?: Date | null
  /**
   * The date and time a release is updated.
   */
  updated_at?: Date | null
  /**
   * The status of the current release.
   */
  release_status?: "PENDING" | "IN_PROGRESS" | "FAILED" | "PUBLISHED"
  /**
   * Your storefront's preferred language code and locale.
   */
  language?: string
  /**
   * Indicates that a full publish was performed (either because this is the first time a catalog has been published or because of a change that occurred, for example, adding/removing a price book or hierarchy). When determining whether delta data needs to be refreshed, ignore this attribute and always use the `is_full_delta` attribute.
   *
   */
  is_full_publish?: boolean
  /**
   * Indicates whether the release delta file contains the full content of a catalog release. Using a search service as an example, if the `is_full_delta` attribute is `true`, you should remove all data about that catalog release from the search service before injecting fresh data from the delta file. If the `is_full_delta` attribute is `false`, then data from the previous catalog release overlays the existing data in the delta file. The `is_full_delta` attribute is always `true` the first time a catalog is published.
   *
   */
  is_full_delta?: boolean
  /**
   * The total number of products displayed in a catalog release.
   */
  total_products?: BigInt | null
  /**
   * The total number of hierarchy nodes displayed in a catalog release.
   */
  total_nodes?: BigInt | null
  /**
   * An integer that represents the progress of a catalog publish. The attribute starts at `0` and reaches `100` when publishing is complete.
   */
  percent_completed?: number | null
  /**
   * The owner of the resource, can be either `organization` or `store`.
   */
  owner?: "store" | "organization"
  /**
   * This indicates whether the catalog release will support price segmentation using catalog rules to define which pricebook(s) to use for pricing
   */
  price_segmentation_enabled?: boolean
}

/**
 * Relationships are established between different catalog entities. For example, products, hierarchies, price books, and catalog rules are related to a catalog, as they are associated with it.
 */
export type ReleaseRelationships = {
  /**
   * A URL to a delta document that describes the changes between catalog releases.
   */
  delta?: {
    links?: RelatedLink
  }
  /**
   * A URL to all products included in a catalog release.
   */
  products?: {
    links?: RelatedLink
  }
  /**
   * A URL to all hierarchies included in a catalog release.
   */
  hierarchies?: {
    links: RelatedLink
  }
}

/**
 * A catalog rule specifies which catalog to use for a given shopper context.
 */
export type Rule = {
  /**
   * The catalog rule ID. Use this to get, modify, or delete the catalog rule.
   */
  id: string
  attributes: {
    /**
     * The name of a catalog rule. The name must not contain any spaces.
     */
    name: string
    /**
     * A brief description of the purpose of a catalog rule.
     */
    description?: string
    /**
     * The list of accounts who are eligible to see this catalog. If this field is empty, the rule matches all accounts.
     */
    account_ids?: Array<string>
    /**
     * The list of customers who are eligible to see this catalog. If empty, the rule matches all customers.
     */
    customer_ids?: Array<string>
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    channels?: Array<string>
    /**
     * A list of user-defined tags that can be used to further restrict the eligibility criteria for this rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    tags?: Array<string>
    /**
     * Specifies a time period when a catalog is displayed, such as on a specific date or during summer. Requests populate the rule tag using the `EP-Context-Tag` header.
     *
     * The schedules attribute must include the following.
     *
     * - `valid_from` matches the date and time that the catalog is displayed from.
     * - `valid_to` matches the date and time the catalog is displayed to.
     *
     * Commerce runs on UTC time.
     *
     * You can offset the timezone by adding the offset to the end of the date and time. For example, a catalog which contains a sale hierarchy that should appear for a set timeframe may be scheduled to publish on a given date and time within a given timezone. For instance, a sale that should begin on 1st of June 2022 05:00 ET and end on the 15th of June 2022 at 23:50 PT would have a valid schedule of `"valid_from": "2022-06-01T05:00:00.000-05:00"`, `"valid_to": "2022-06-15T11:59:99.000-08:00"`.
     *
     */
    schedules?: Array<RuleSchedule>
    /**
     * The unique identifier of a catalog.
     */
    catalog_id: string
    /**
     * The date and time a catalog rule was created.
     */
    created_at: Date
    /**
     * The date and time a catalog release is updated.
     */
    updated_at: Date
    /**
     * The unique identifier of a price book to associate with a rule. You can specify a `pricebook_id` or a `pricebook_ids` but not both. If you specify both, a `422 unprocessable entity` error is displayed.
     */
    pricebook_id?: string | null
    pricebook_ids?: PrioritizedPricebooks
  }
  /**
   * This represents the type of object being returned. Always `catalog_rule`.
   */
  type: "catalog_rule"
}

/**
 * A catalog rule specifies which catalog to use for a given shopper context.
 */
export type RuleCreateData = {
  data: {
    attributes: {
      /**
       * The name of a catalog rule. The name must not contain spaces.
       */
      name: string
      /**
       * A brief description of the purpose of a catalog rule.
       */
      description?: string | null
      /**
       * The list of accounts who are eligible to see this catalog. If this field is empty, the rule matches all accounts.
       */
      account_ids?: Array<string> | null
      /**
       * The list of customers who are eligible to see this catalog. If empty, the rule matches all customers.
       */
      customer_ids?: Array<string> | null
      /**
       * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
       */
      channels?: Array<string> | null
      /**
       * A list of user-defined tags that can be used to further restrict the eligibility criteria for this rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
       */
      tags?: Array<string> | null
      /**
       * Specifies a time period when a catalog is displayed, such as on a specific date or during summer. Requests populate the rule tag using the `EP-Context-Tag` header.
       *
       * The schedules attribute must include the following.
       *
       * - `valid_from` matches the date and time that the catalog is displayed from.
       * - `valid_to` matches the date and time the catalog is displayed to.
       *
       * Commerce runs on UTC time.
       *
       * You can offset the timezone by adding the offset to the end of the date and time. For example, a catalog which contains a sale hierarchy that should appear for a set timeframe may be scheduled to publish on a given date and time within a given timezone. For instance, a sale that should begin on 1st of June 2022 05:00 ET and end on the 15th of June 2022 at 23:50 PT would have a valid schedule of `"valid_from": "2022-06-01T05:00:00.000-05:00"`, `"valid_to": "2022-06-15T11:59:99.000-08:00"`.
       *
       */
      schedules?: Array<RuleSchedule> | null
      /**
       * The unique identifier of a catalog.
       */
      catalog_id: string
      /**
       * The unique identifier of a price book to associate with a rule. You can specify a `pricebook_id` or a `pricebook_ids` but not both. If you specify both, a `422 unprocessable entity` error is displayed.
       */
      pricebook_id?: string | null
      pricebook_ids?: PrioritizedPricebooks
    }
    /**
     * This represents the type of object being returned. Always `catalog_rule`.
     */
    type: "catalog_rule"
  }
}

/**
 * Container for a single catalog rule.
 */
export type RuleData = {
  data: Rule
  links?: Links
}

/**
 * Container for a list of catalog rules.
 */
export type RuleListData = {
  meta?: PageMeta
  data: Array<Rule>
  links?: Links
}

/**
 * A period of time during which a catalog is valid
 */
export type RuleSchedule = {
  /**
   * Matches the date and time that the catalog is displayed from.
   */
  valid_from?: Date | null
  /**
   * Matches the date and time the catalog is displayed to.
   */
  valid_to?: Date | null
}

/**
 * A catalog rule specifies which catalog to use for a given shopper context.
 */
export type RuleUpdateData = {
  data: {
    /**
     * The catalog rule ID. Use this to get, modify, or delete the catalog rule.
     */
    id: string
    attributes?: {
      /**
       * The name of a catalog rule. The name must not contain spaces.
       */
      name?: string | null
      /**
       * A description of the purpose of a catalog rule.
       */
      description?: string | null
      /**
       * Specifies the list of accounts who are eligible to see this catalog. If this field is empty, the rule matches all accounts.
       */
      account_ids?: Array<string> | null
      /**
       * The list of customers who are eligible to see this catalog. If empty, the rule matches all customers.
       */
      customer_ids?: Array<string> | null
      /**
       * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
       */
      channels?: Array<string> | null
      /**
       * Specifies a time period when a catalog is displayed, such as on a specific date or during summer. Requests populate the rule tag using the `EP-Context-Tag` header.
       *
       * The schedules attribute must include the following.
       *
       * - `valid_from` matches the date and time that the catalog is displayed from.
       * - `valid_to` matches the date and time the catalog is displayed to.
       *
       * Commerce runs on UTC time.
       *
       * You can offset the timezone by adding the offset to the end of the date and time. For example, a catalog which contains a sale hierarchy that should appear for a set timeframe may be scheduled to publish on a given date and time within a given timezone. For instance, a sale that should begin on 1st of June 2022 05:00 ET and end on the 15th of June 2022 at 23:50 PT would have a valid schedule of `"valid_from": "2022-06-01T05:00:00.000-05:00"`, `"valid_to": "2022-06-15T11:59:99.000-08:00"`.
       *
       */
      schedules?: Array<RuleSchedule> | null
      /**
       * A list of user-defined tags that can be used to further restrict the eligibility criteria for this rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
       */
      tags?: Array<string> | null
      /**
       * The unique identifier of a catalog rule.
       */
      catalog_id?: string | null
      /**
       * The unique identifier of a price book to associate with a rule. You can specify a `pricebook_id` or a `pricebook_ids` but not both. If you specify both, a `422 unprocessable entity` error is displayed.
       */
      pricebook_id?: string | null
      pricebook_ids?: PrioritizedPricebooks
    }
    /**
     * This represents the type of object being returned. Always `catalog_rule`.
     */
    type: "catalog_rule"
  }
}

/**
 * A set of sale prices and a validity period.
 */
export type Sale = {
  schedule?: Schedule
  currencies?: TieredCurrencies
}

/**
 * A set of sale specifications
 */
export type Sales = {
  [key: string]: Sale
}

/**
 * A definition of the times at which a sale is valid
 */
export type Schedule = {
  valid_from?: Date | null
  valid_to?: Date | null
}

/**
 * The name of the tier, for example, `Pencils`.
 */
export type Tier = {
  /**
   * The minimum quantity of 1 or more defined for the specified price. If a minimum quantity is not specified, an error is returned.
   */
  minimum_quantity?: number
  price?: Currencies
}

/**
 * The three-letter ISO code for the currency associated with this price.
 */
export type TieredAmount = {
  /**
   * The price in the lowest denomination for the specified currency. This is a product's list price.
   */
  amount?: BigInt
  /**
   * Whether this price includes tax.
   */
  includes_tax?: boolean
  /**
   * The price tier that an item is eligible for based on the quantity purchased. You cannot have conflicting tiers within the same currencies block.
   */
  tiers?: {
    [key: string]: {
      /**
       * The minimum quantity of 1 or more defined for the specified price. If a minimum quantity is not specified, an error is returned.
       */
      minimum_quantity?: number
      /**
       * The price for each quantity.
       */
      amount?: BigInt
    }
  }
}

/**
 * Collection of currency specific prices for a product.
 */
export type TieredCurrencies = {
  [key: string]: TieredAmount
}

/**
 * The price tier that an item is eligible for based on the quantity purchased. You cannot have conflicting tiers within the same currencies block.
 */
export type Tiers = {
  [key: string]: Tier
}

/**
 * Creates a catalog release with the following attributes.
 */
export type CatalogReleaseCreateData = {
  data?: {
    /**
     * Set to `true` if you want to export all the data from a catalog release in a delta link. The `is_full_delta` attribute is returned from the `get a release of a catalog` endpoint. The `is_full_delta` attribute tells you if the delta file contains the full content of a catalog release. You can use the `is_full_delta` to determine if you need to refresh the data in your company system before publishing a catalog release with fresh data in a delta link. Using a search service as an example, if the `is_full_delta` attribute is true, you should remove all data about that catalog from the search service before publishing a catalog release and injecting fresh data from the delta file. If the `is_full_delta` attribute is false, then data from the previous catalog overlays the existing data in the delta file. The `is_full_delta` attribute is always `true` the first time a catalog is published.
     *
     */
    export_full_delta?: boolean
    /**
     * If you are publishing a catalog in a store that contains resources from an organization, you must set this to true and you must enable the **Include Organization Resources in Catalog Publishes** checkbox in Commerce Manager. See [**Multi-Store Management Solutions**](/docs/api/pxm/catalog/publish-release).
     */
    include_organization_resources?: boolean | null
  }
}

export type CartContact = {
  /**
   * The email address attached to a cart.
   */
  email?: string
}

export type DiscountSettings = {
  /**
   * This parameter enables custom discounts for a cart. When set to true, Elastic Path promotions will not be applied to the new carts. Default is set from cart discount settings for the store. See [Cart Settings](/docs/api/settings/put-v-2-settings-cart).
   */
  custom_discounts_enabled?: boolean
  /**
   * When set to true, this parameter allows the cart to use rule promotions.
   */
  use_rule_promotions?: boolean
}

export type InventorySettings = {
  /**
   * This parameter enables deferring inventory checks on the cart. This allows items to be added to or updating in the cart without checking stock levels. Inventory checks are still performed as normal on checkout
   */
  defer_inventory_check?: boolean
}

/**
 * Specifies custom attributes for cart or order objects. Each attribute includes a top-level key, as well as corresponding type and value entries. Attribute values must correspond to the assigned types.
 *
 * Example:
 * ```
 * "custom_attributes": {
 * "is_member": {
 * "type": "boolean",
 * "value": true
 * },
 * "membership_level": {
 * "type": "string",
 * "value": "premium"
 * }
 * }
 * ```
 *
 */
export type CustomAttributes = {
  [key: string]: unknown
}

export type FormattedPriceData = {
  /**
   * The raw total.
   */
  amount?: number
  /**
   * The currency set for this amount.
   */
  currency?: string
  /**
   * The formatted total based on the amount and currency.
   */
  formatted?: string
}

/**
 * Relationship data entry
 */
export type RelationshipItem = {
  /**
   * The type of related resource.
   */
  type?: string
  /**
   * The ID of the related resource.
   */
  id?: string
}

/**
 * Array of relationships
 */
export type RelationshipArray = {
  /**
   * Individual relationships
   */
  data?: Array<RelationshipItem>
}

export type CartResponse = {
  /**
   * The unique identifier for the cart. Use SDK or create it yourself.
   */
  id?: string
  /**
   * The type of object being returned.
   */
  type?: string
  /**
   * The name of this cart.
   */
  name?: string
  /**
   * A description of the cart.
   */
  description?: string
  contact?: CartContact
  discount_settings?: DiscountSettings
  inventory_settings?: InventorySettings
  /**
   * Stripe-assigned unique identifier for the linked Payment Intent
   */
  payment_intent_id?: string
  custom_attributes?: CustomAttributes
  links?: {
    /**
     * A link to that specific resource.
     */
    self?: string
  }
  meta?: {
    display_price?: {
      with_tax?: FormattedPriceData
      without_tax?: FormattedPriceData
      tax?: FormattedPriceData
      discount?: FormattedPriceData
      without_discount?: FormattedPriceData
      shipping?: FormattedPriceData
    }
    timestamps?: CartCheckoutTimestamps
  }
  relationships?: {
    customers?: RelationshipArray
    items?:
      | RelationshipArray
      | {
          data?: null
        }
    accounts?: RelationshipArray
    custom_discounts?: RelationshipArray
    promotions?: RelationshipArray
  }
}

export type ResponsePageLinks = {
  /**
   * Always the current page.
   */
  current?: string
  /**
   * Always the first page.
   */
  first?: string
  /**
   * If there is only one page, it is `null`.
   */
  last?: string
  /**
   * If there is only one page, it is `null`.
   */
  next?: string
  /**
   * if the user is on the first page, it is `null`.
   */
  prev?: string
}

export type ResponsePaginationPage = {
  /**
   * The current page.
   */
  current?: number
  /**
   * The maximum number of records per page for this response. You can set this value up to 100.
   */
  limit?: number
  /**
   * The current offset by number of records, not pages. Offset is zero-based.
   */
  offset?: number
  /**
   * The total page count.
   */
  total?: number
}

export type ResponsePaginationResults = {
  /**
   * The total page count.
   */
  total?: number
}

export type ResponseMetaCarts = {
  page?: ResponsePaginationPage
  results?: ResponsePaginationResults
}

export type CartCollectionResponse = {
  data: Array<CartResponse>
  links?: ResponsePageLinks
  meta?: ResponseMetaCarts
}

export type ResponseErrorItem = {
  /**
   * A brief summary of the error.
   */
  title: string
  /**
   * The HTTP response code of the error.
   */
  status: number
  /**
   * Optional additional detail about the error.
   */
  detail?: string
  meta?: {
    /**
     * The resource id associated with the error
     */
    id?: string
    ids?: Array<string>
    item_ids?: Array<string>
    /**
     * The shipping group id associated with the error
     */
    shipping_group_id?: string
    shipping_group_ids?: Array<string>
    /**
     * The cart id associated with the error
     */
    cart_id?: string
    /**
     * The code associated with the error.
     */
    code?: string
    /**
     * The order id associated with the error.
     */
    order_id?: string
    /**
     * The value associated with the error.
     */
    value?:
      | Array<unknown>
      | Array<unknown>
      | Array<unknown>
      | Array<unknown>
      | Array<unknown>
  }
}

export type ResponseErrorResponse = {
  errors: Array<ResponseErrorItem>
}

export type CartsRequest = {
  data?: {
    /**
     * The cart description.
     */
    description?: string
    discount_settings?: DiscountSettings
    inventory_settings?: InventorySettings
    /**
     * The cart name provided by the shopper. A cart name must contain 1 to 255 characters. You cannot use whitespace characters, but special characters are permitted. For more information, see the [Safe Characters](/guides/Getting-Started/safe-characters) section.
     */
    name?: string
    contact?: CartContact
    /**
     * This optional parameter sets a reference date for the cart. If this parameter is set, it allows the cart to act as one that might occur on that specified date. For example, such future carts might acquire future-enabled discounts, allowing users to test and validate future interactions with carts. The snapshot_date must be in the format 2026-02-21T15:07:25Z. By default, this parameter is left empty.
     */
    snapshot_date?: string
    /**
     * Specifies custom attributes for cart objects. Each attribute includes a top-level key, as well as corresponding type and value entries. Attribute values must correspond to the assigned types.
     *
     * Attribute types include:
     * - string
     * - boolean
     * - integer
     * - float
     *
     * Multiple custom attributes may be submitted together.  A cart can have a maximum of 20 custom attributes.
     *
     * Example:
     * ```
     * "custom_attributes": {
     * "is_member": {
     * "type": "boolean",
     * "value": true
     * },
     * "membership_level": {
     * "type": "string",
     * "value": "premium"
     * }
     * }
     * ```
     *
     * Updating an existing cart with new custom attributes clears previously-saved attributes.  In order to maintain existing custom attributes on a cart, please include them in the update request along with any new attributes.
     *
     */
    custom_attributes?: CustomAttributes
    /**
     * To remove the Stripe payment intent from a cart, pass the empty value in the `payment_intent_id` field.  You must use an empty value for this field. You cannot use this endpoint to directly update the cart to use an existing Payment Intent.
     */
    payment_intent_id?: string
  }
}

export type CartEntityResponse = {
  data: CartResponse
  included?: CartIncluded
}

/**
 * The type of object being returned.
 */
export type Type = "cart_item"

export type CartItemObjectData = {
  /**
   * The type of object being returned.
   */
  type: "cart_item"
  /**
   * The number of items added to the cart.
   */
  quantity: number
  /**
   * Specifies the ID of the product you want to add to cart. (use this OR sku)
   */
  id?: string
  /**
   * Specifies the item SKU that you want to add to cart. (use this OR id)
   */
  sku?: string
  /**
   * The custom text to be added to a product.
   */
  custom_inputs?: {
    [key: string]: unknown
  }
  /**
   * Object used to describe the bundle options selected.
   */
  bundle_configuration?: {
    /**
     * Specifies selected options.
     */
    selected_options?: {
      [key: string]: unknown
    }
    /**
     * Array of component products for the selected options.
     */
    component_products?: Array<unknown>
  }
  /**
   * Identifier for a created Cart Shipping Group
   */
  shipping_group_id?: string
  /**
   * The slug of a stock location.
   */
  location?: string
}

export type ItemPriceData = {
  /**
   * The amount for this item as an integer.
   */
  readonly amount?: number
  /**
   * The currency this item was added to the cart as.
   */
  readonly currency?: string
  /**
   * Whether or not this price is tax inclusive.
   */
  readonly includes_tax?: boolean
}

export type CartItemFormattedPriceData = {
  /**
   * The amount per each single unit.
   */
  unit?: FormattedPriceData
  /**
   * The total amount of the item (i.e., unit * quantity).
   */
  value?: FormattedPriceData
}

export type CartItemResponse = {
  /**
   * The unique ID of the product.
   */
  readonly product_id?: string
  /**
   * The unique ID of the subscription offering for subscription items.
   */
  readonly subscription_offering_id?: string
  /**
   * The name of this item
   */
  readonly name?: string
  /**
   * A description of the cart item.
   */
  readonly description?: string
  /**
   * The unique identifier of the catalog associated with the product is shown if catalog_source=pim is set.
   */
  readonly catalog_id?: string
  /**
   * The catalog source. Always `pim` or `legacy`.
   */
  readonly catalog_source?: string
  readonly image?: {
    /**
     * The MIME type for the uploaded file.
     */
    readonly mime_type?: string
    /**
     * The name of the image file that was uploaded.
     */
    readonly file_name?: string
    /**
     * The link to the image.
     */
    readonly href?: string
  }
  /**
   * Whether or not the quantity of the item will be checked against inventory.
   */
  readonly manage_stock?: boolean
  /**
   * The unit price of the item.
   */
  unit_price?: ItemPriceData
  /**
   * The total price of the item (i.e., unit * quantity).
   */
  value?: ItemPriceData
  readonly links?: {
    /**
     * A URL related to the resource.
     */
    product?: string
  }
  readonly meta?: {
    display_price?: {
      /**
       * The amount of this item after discounts and taxes are applied.
       */
      with_tax?: CartItemFormattedPriceData
      /**
       * The amount of this item after discounts are applied and before taxes.
       */
      without_tax?: CartItemFormattedPriceData
      /**
       * The amount of taxes applied to this item.
       */
      tax?: CartItemFormattedPriceData
      /**
       * The amount of the discount applied to this item.
       */
      discount?: CartItemFormattedPriceData
      without_discount?: CartItemFormattedPriceData
    }
    timestamps?: CartCheckoutTimestamps
  }
}

export type CartItemObject = CartItemObjectData & CartItemResponse

export type CustomItemObjectData = {
  /**
   * The type of object being returned. Must be `custom_item`.
   */
  type: "custom_item"
  /**
   * The number of custom items to add to cart.
   */
  quantity: number
  price: {
    /**
     * The unit price of the custom item.
     */
    amount: number
    /**
     * Set to`true` if relevant taxes have been included in the price, `false` if not. Defaults to `true`.
     */
    includes_tax?: boolean
  }
  /**
   * A description of the custom item.
   */
  description?: string
  /**
   * The `SKU` code to use for the custom item. See [best practices](https://elasticpath.dev/docs/commerce-cloud/carts/cart-items/add-custom-item-to-cart#best-practices) to use the `SKU` code.
   */
  sku?: string
  /**
   * The name of the custom item.
   */
  name: string
  /**
   * The custom text to be added to a product.
   */
  custom_inputs?: {
    [key: string]: unknown
  }
  /**
   * Identifier for a created Cart Shipping Group
   */
  shipping_group_id?: string
}

export type CustomItemObject = {
  data?: CustomItemObjectData
}

export type SubscriptionItemObjectData = {
  /**
   * The type of object being returned.
   */
  type: "subscription_item"
  /**
   * The number of items added to the cart.
   */
  quantity: number
  /**
   * Specifies the ID of the subscription offering you want to add to cart.
   */
  id: string
  /**
   * Specifies how the subscription offering should be configured.
   */
  subscription_configuration: {
    /**
     * The ID of the pricing option within the offering to use for the subscription.
     */
    pricing_option: string
    /**
     * The ID of the plan within the offering to use for the subscription.
     */
    plan: string
  }
}

export type SubscriptionItemObject = {
  data?: SubscriptionItemObjectData & CartItemResponse
}

export type PromotionItemObjectData = {
  /**
   * Specifies the type of resource, which is `promotion_item`.
   */
  type: "promotion_item"
  /**
   * Specifies the promotion code. For more information about codes[].user[], see the [Create Promotion codes](/docs/api/promotions/create-promotion-codes) section.
   */
  code: string
}

export type PromotionItemObject = {
  data?: PromotionItemObjectData
}

export type CartItemsResponse = {
  data?: Array<
    | CartItemObject
    | CustomItemObject
    | SubscriptionItemObject
    | PromotionItemObject
  >
}

export type UpdateAllOrNothingOptionsObject = {
  /**
   * When set to`true`, if an error occurs for any item, no items are updated in the cart. When set to `false`, valid items are updated in the cart and the items with errors are reported in the response. Default is `true`.
   */
  update_all_or_nothing?: boolean
}

export type BulkUpdateCartsItems = {
  data?: Array<{
    /**
     * Specifies the ID of the cart item that you want to update in cart.
     */
    id?: string
    /**
     * Specifies the amount of items to update in the cart.
     */
    quantity?: number
    /**
     * Specifies the custom text to be added to a product. See [custom inputs](https://elasticpath.dev/docs/pxm/products/ep-pxm-products-api/update-a-product#using-custom-inputs-attribute).
     */
    custom_inputs?: {
      [key: string]: unknown
    }
  }>
  options?: UpdateAllOrNothingOptionsObject
}

export type CartItemObjectRequest = {
  data?: CartItemObject
}

export type CartMergeObject = {
  /**
   * The type of object being returned. Must be `cart_items`.
   */
  type: "cart_items"
  /**
   * The original cart to be merged from.
   */
  cart_id: string
}

export type AddAllOrNothingOptionsObject = {
  /**
   * When `true`, if an error occurs for any item, no items are added to the cart. When `false`, valid items are added to the cart and the items with errors are reported in the response. Default is `false`.
   */
  add_all_or_nothing?: boolean
}

export type CartMergeObjectRequest = {
  data?: CartMergeObject
  options?: AddAllOrNothingOptionsObject
}

export type ReOrderObject = {
  /**
   * The type of resource being returned. Use `order_items`.
   */
  type: "order_items"
  /**
   * The unique identifier of the order.
   */
  order_id: string
}

export type ReOrderObjectRequest = {
  data?: ReOrderObject
  options?: AddAllOrNothingOptionsObject
}

export type BulkAddItemsRequest = {
  data?: Array<
    | CartItemObjectData
    | CartMergeObject
    | CustomItemObjectData
    | ReOrderObject
    | PromotionItemObjectData
  >
  options?: AddAllOrNothingOptionsObject
}

export type CartTimestamps = {
  created_at?: string
  updated_at?: unknown
  expires_at?: unknown
}

export type CartsResponse = {
  data?: Array<
    | CartItemObject
    | CustomItemObject
    | SubscriptionItemObject
    | PromotionItemObject
  >
  meta?: {
    display_price?: {
      with_tax?: FormattedPriceData
      without_tax?: FormattedPriceData
      tax?: FormattedPriceData
      discount?: FormattedPriceData
      without_discount?: FormattedPriceData
      discounts?: {
        [key: string]: {
          amount?: number
          currency?: string
          formatted?: string
        }
      }
    }
    timestamps?: CartTimestamps
  }
}

export type UpdateCartsItems = {
  data?: {
    /**
     * The type of the cart item.
     */
    type?: "cart_item"
    /**
     * The unique identifier of the cart item.
     */
    id?: string
    /**
     * The amount of products to add to cart.
     */
    quantity?: number
    /**
     * The custom text to be added to a product.
     */
    custom_inputs?: {
      [key: string]: unknown
    }
    /**
     * The unique identifier of the shipping group to be added to the cart.
     */
    shipping_group_id?: string
  }
}

export type CartsRelationshipsAccountsData = {
  data?: Array<{
    /**
     * The ID of the account.
     */
    id?: string
    /**
     * The type of related object. Ensure that it is account.
     */
    type?: string
  }>
}

export type CartsRelationshipsCustomersData = {
  data?: Array<{
    /**
     * The ID of the customer.
     */
    id?: string
    /**
     * The type of related object. Ensure that it is customer.
     */
    type?: string
  }>
}

export type CartsItemsTaxesObject = {
  /**
   * A unique tax code in this jurisdiction.
   */
  code?: string
  /**
   * The relevant tax jurisdiction.
   */
  jurisdiction?: string
  /**
   * The name of the tax item.
   */
  name?: string
  /**
   * The tax rate represented as a decimal (12.5% -> 0.125). You can specify either `rate` or `amount`, but not both. Supplying both fields will result in an error.
   */
  rate?: number
  /**
   * The tax rate represented as a number ($10 -> 1000). You can specify either `rate` or `amount`, but not both. Supplying both fields will result in an error.
   */
  amount?: number
  /**
   * The type of object being returned. Use `tax_item`.
   */
  type: string
  /**
   * The unique identifier for this tax item.
   */
  readonly id?: string
}

export type CartItemTaxesEntityResponse = {
  data: CartsItemsTaxesObject
}

export type CartItemRelationship = {
  relationships?: {
    order?: {
      data?: {
        /**
         * This specifies the type of item.
         */
        type?: string
        /**
         * This specifies the ID of the cart_item or custom_item in the cart.
         */
        id?: string
      }
    }
  }
}

export type CartsBulkTaxes = {
  data?: Array<CartsItemsTaxesObject & CartItemRelationship>
  options?: AddAllOrNothingOptionsObject
}

export type CartsCustomDiscountsObject = {
  amount:
    | number
    | {
        amount?: number
        currency?: string
        formatted?: string
      }
  /**
   * Specifies a description for the custom discount.
   */
  description: string
  /**
   * Specifies the discount code used for the custom discount.
   */
  discount_code: string
  /**
   * Specifies from where the custom discount is applied. For example, Talon.one.
   */
  discount_engine: string
  /**
   * Specifies an external id for the custom discount.
   */
  external_id: string
  /**
   * Specifies the type of the resource. Always `custom_discount`.
   */
  type: string
}

export type CustomDiscountRelationshipsCartItemRequest = {
  relationships?: {
    item?: {
      data?: {
        /**
         * Specifies the type of item. For example, `custom_item` or `cart_item`.
         */
        type?: string
        /**
         * Specifies the unique identifier of the `cart_item` or `custom_item` in the cart.
         */
        id?: string
      }
    }
  }
}

export type CartItemBulkCustomDiscountObject = CartsCustomDiscountsObject &
  CustomDiscountRelationshipsCartItemRequest

export type CartsBulkCustomDiscounts = {
  data?: Array<CartsCustomDiscountsObject & CartItemBulkCustomDiscountObject>
  options?: AddAllOrNothingOptionsObject
}

export type CartsBulkCustomDiscountsResponse = {
  data?: CartsCustomDiscountsObject
  options?: AddAllOrNothingOptionsObject
}

export type CartsBulkCustomDiscountsCollectionResponse = {
  data?: Array<CartsCustomDiscountsObject>
  options?: AddAllOrNothingOptionsObject
}

export type CartsCustomDiscountsResponseObject = {
  amount?: {
    /**
     * Specifies an amount to be applied for the custom discount. It must be less than zero.
     */
    amount?: number
    /**
     * The currency set for the custom discount.
     */
    currency?: string
    /**
     * The formatted value for the custom discount.
     */
    formatted?: string
  }
  /**
   * Specifies a description for the custom discount.
   */
  description?: string
  /**
   * Specifies the discount code used for the custom discount.
   */
  discount_code?: string
  /**
   * Specifies from where the custom discount is applied. For example, Talon.one.
   */
  discount_engine?: string
  /**
   * Specifies an external id for the custom discount.
   */
  external_id?: string
  /**
   * Specifies the type of the resource. Always `custom_discount`.
   */
  type?: string
  /**
   * Specifies the UUID of the custom discount.
   */
  readonly id?: string
}

export type CartsCustomDiscountsEntityRequest = {
  data?: CartsCustomDiscountsResponseObject
}

export type CartsCustomDiscountsEntityResponse = {
  data?: CartsCustomDiscountsObject
}

export type CartsCustomDiscountsCollectionResponse = {
  data?: Array<CartsCustomDiscountsObject>
}

export type ShippingAddress = {
  /**
   * First name of the shipping recipient.
   */
  first_name: string
  /**
   * Last name of the shipping recipient.
   */
  last_name: string
  /**
   * Phone number of the shipping recipient.
   */
  phone_number: string
  /**
   * Company of the shipping recipient.
   */
  company_name: string
  /**
   * First line of the shipping address.
   */
  line_1: string
  /**
   * Second line of the shipping address.
   */
  line_2: string
  /**
   * City of the shipping address.
   */
  city: string
  /**
   * Post code of the shipping address.
   */
  postcode: string
  /**
   * County of the shipping address.
   */
  county: string
  /**
   * Country of the shipping address.
   */
  country: string
  /**
   * State, province, or region of the shipping address.
   */
  region?: string
  /**
   * Delivery instructions.
   */
  instructions: string
}

export type DeliveryEstimate = {
  start?: Date
  end?: Date
}

export type Money = {
  /**
   * Amount in minor currency units (e.g., cents).
   */
  amount: number
  /**
   * ISO 4217 currency code (e.g., "USD").
   */
  currency: string
  /**
   * Whether the amount includes tax.
   */
  includes_tax: boolean
}

export type Discount = {
  amount: Money
  /**
   * The discount code used, if applicable.
   */
  code?: string
  /**
   * Unique identifier for the discount.
   */
  id: string
  /**
   * The source or origin of the promotion, if applicable.
   */
  promotion_source?: string
  /**
   * Indicates whether the discount applies to the entire cart.
   */
  is_cart_discount?: boolean
  /**
   * Order in which the discount was applied.
   */
  ordinal?: number
}

export type Discounts = Array<Discount>

export type ShippingPriceResponse = {
  total: FormattedPriceData
  base: FormattedPriceData
  tax?: FormattedPriceData
  fees?: FormattedPriceData
  discount?: FormattedPriceData
}

export type OrderPriceWrapperMeta = {
  with_tax: FormattedPriceData
  without_tax: FormattedPriceData
  tax: FormattedPriceData
  discount: FormattedPriceData
  balance_owing: FormattedPriceData
  paid: FormattedPriceData
  authorized: FormattedPriceData
  without_discount: FormattedPriceData
  shipping: FormattedPriceData
  shipping_discount: FormattedPriceData
}

export type ShippingGroupMeta = {
  shipping_display_price?: ShippingPriceResponse
  total_display_price?: OrderPriceWrapperMeta
}

export type ShippingGroupResponse = {
  type?: "shipping_group"
  id?: string
  relation?: string
  cart_id?: string
  order_id?: string
  shipping_type?: string
  tracking_reference?: string
  address?: ShippingAddress
  delivery_estimate?: DeliveryEstimate
  createdAt?: Date
  updatedAt?: Date
  relationships?: {
    cart?: RelationshipItem
    order?: RelationshipItem
  }
  discounts?: Discounts
  meta?: ShippingGroupMeta
}

export type ShippingPriceRequest = {
  total?: number
  base?: number
  tax?: number
  fees?: number
  discount?: number
}

export type CreateShippingGroupRequest = {
  data?: {
    type?: "shipping_group"
    shipping_type?: string
    tracking_reference?: string
    shipping_price?: ShippingPriceRequest
    address?: ShippingAddress
    includes_tax?: boolean
    delivery_estimate?: DeliveryEstimate
  }
}

export type UpdateCartShippingGroupRequest = {
  data?: {
    type?: "shipping_group"
    shipping_type?: string
    tracking_reference?: string
    shipping_price?: ShippingPriceRequest
    address?: ShippingAddress
    includes_tax?: boolean
    delivery_estimate?: DeliveryEstimate
  }
}

export type Gateway =
  | "adyen"
  | "authorize_net"
  | "braintree"
  | "card_connect"
  | "cyber_source"
  | "elastic_path_payments_stripe"
  | "manual"
  | "paypal_express_checkout"
  | "stripe"
  | "stripe_connect"
  | "stripe_payment_intents"

/**
 * Specifies the transaction method, such as `purchase` or `authorize`.
 */
export type Method =
  | "authorize"
  | "purchase"
  | "purchase_setup"
  | "authorize_setup"

export type DataBasePayments = {
  gateway:
    | "adyen"
    | "authorize_net"
    | "braintree"
    | "card_connect"
    | "cyber_source"
    | "elastic_path_payments_stripe"
    | "manual"
    | "paypal_express_checkout"
    | "stripe"
    | "stripe_connect"
    | "stripe_payment_intents"
  /**
   * Specifies the transaction method, such as `purchase` or `authorize`.
   */
  method: "authorize" | "purchase" | "purchase_setup" | "authorize_setup"
  /**
   * The amount to be paid for the transaction.
   */
  amount?: number
}

export type ElasticPathPaymentsPoweredByStripePayment = {
  data?: DataBasePayments & {
    /**
     * Specifies the gateway. You must use `elastic_path_payments_stripe`.
     */
    gateway?: "elastic_path_payments_stripe"
    options?: {
      /**
       * Provides the email address to which you want to send the Stripe receipts for the transactions within the store. This feature is available only in the live mode.
       */
      receipt_email?: string
      /**
       * Parent object determining whether to use Stripe's `automatic_payment_methods` setting.
       */
      automatic_payment_methods?: {
        /**
         * When set to true, it displays all enabled payment methods from the Stripe dashboard. When set to false, the Stripe default, which is card, is used.
         */
        enabled?: boolean
      }
    }
    /**
     * Specifies the Stripe payment method types configured for the store. See [Stripe Documentation](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_types).
     */
    payment_method_types?: Array<string>
    /**
     * Specifies the Stripe token or source.
     */
    payment?: string
  }
}

export type CartPaymentUpdate = {
  data: {
    gateway: string
    method: string
    payment_method_types: Array<string>
    amount: number
    options?: {
      [key: string]: unknown
    }
  }
}

export type BillingAddress = {
  /**
   * First name of the billing recipient.
   */
  first_name: string
  /**
   * Last name of the billing recipient.
   */
  last_name: string
  /**
   * Company name of the billing recipient.
   */
  company_name: string
  /**
   * First line of the billing address.
   */
  line_1: string
  /**
   * Second line of the billing address.
   */
  line_2: string
  /**
   * City of the billing address.
   */
  city: string
  /**
   * Postcode of the billing address.
   */
  postcode: string
  /**
   * County of the billing address.
   */
  county: string
  /**
   * Country of the billing address.
   */
  country: string
  /**
   * State, province, or region of the billing address.
   */
  region?: string
}

export type CustomerCheckout = {
  data?: {
    /**
     * A user-managed, optional field used as an alternative to the existing `order_id`. If provided, the order-number will be sent to Authorize.net instead of the `order_id`, and will appear as the invoice number in Authorize.net transactions.
     */
    order_number?: string
    /**
     * An optional external ID reference for an order. It can contain alphanumeric characters, special characters, and spaces, and is not required to be unique. The maximum allowed length is 64 characters. It can be used to include an external reference from a separate company system.
     */
    external_ref?: string
    customer?: {
      /**
       * The ID of the customer.
       */
      id?: string
      /**
       * The email of the customer.
       */
      email?: string
      /**
       * The name of the customer.
       */
      name?: string
    }
    billing_address?: BillingAddress
    shipping_address?: ShippingAddress
  }
}

export type AccountCheckout = {
  data?: {
    /**
     * A user-managed, optional field used as an alternative to the existing `order_id`. If provided, the order-number will be sent to Authorize.net instead of the `order_id`, and will appear as the invoice number in Authorize.net transactions.
     */
    order_number?: string
    /**
     * An optional external ID reference for an order. It can contain alphanumeric characters, special characters, and spaces, and is not required to be unique. The maximum allowed length is 64 characters. It can be used to include an external reference from a separate company system.
     */
    external_ref?: string
    account?: {
      /**
       * The account ID.
       */
      id?: string
      /**
       * The account member ID.
       */
      member_id?: string
    }
    contact?: {
      /**
       * The name of the account member.
       */
      name?: string
      /**
       * The email address of the account member.
       */
      email?: string
    }
    billing_address?: BillingAddress
    shipping_address?: ShippingAddress
  }
}

export type OrderMeta = {
  timestamps?: CartCheckoutTimestamps
  display_price?: {
    with_tax?: FormattedPriceData
    without_tax?: FormattedPriceData
    tax?: FormattedPriceData
    discount?: FormattedPriceData
    balance_owing?: FormattedPriceData
    paid?: FormattedPriceData
    authorized?: FormattedPriceData
    without_discount?: FormattedPriceData
    shipping?: FormattedPriceData
    shipping_discount?: FormattedPriceData
  }
}

export type Contact = {
  /**
   * The email address of the contact.
   */
  email?: string
  /**
   * The name of the contact.
   */
  name?: string
}

/**
 * Single relationship
 */
export type SingleRelationship = {
  data?: RelationshipItem
}

/**
 * Specifies the status of the order, such as `incomplete`, `complete`, `processing`, or `cancelled`.
 */
export type Status = "complete" | "incomplete" | "cancelled" | "processing"

/**
 * Specifies the status of the payment, such as `unpaid`, `authorized`, `paid`, or `refunded`.
 */
export type Payment =
  | "authorized"
  | "paid"
  | "unpaid"
  | "refunded"
  | "partially_paid"
  | "partially_authorized"

/**
 * Specifies the status of the shipment, such as `fulfilled` or `unfulfilled`.
 */
export type Shipping = "unfulfilled" | "fulfilled"

export type OrderResponse = {
  /**
   * Specifies the type of object being returned. You must use `order`.
   */
  type?: "order"
  /**
   * Specifies a user-managed, optional field used as an alternative to the existing `order_id`. If provided, the order-number will be sent to Authorize.net instead of the `order_id`, and will appear as the invoice number in Authorize.net transactions.
   */
  order_number?: string
  /**
   * An optional external ID reference for an order. It can contain alphanumeric characters, special characters, and spaces, and is not required to be unique. The maximum allowed length is 64 characters. It can be used to include an external reference from a separate company system.
   */
  external_ref?: string
  /**
   * Specifies the unique identifier of the order.
   */
  readonly id?: string
  /**
   * Specifies the status of the order, such as `incomplete`, `complete`, `processing`, or `cancelled`.
   */
  status?: "complete" | "incomplete" | "cancelled" | "processing"
  /**
   * Specifies the status of the payment, such as `unpaid`, `authorized`, `paid`, or `refunded`.
   */
  payment?:
    | "authorized"
    | "paid"
    | "unpaid"
    | "refunded"
    | "partially_paid"
    | "partially_authorized"
  /**
   * Specifies the status of the shipment, such as `fulfilled` or `unfulfilled`.
   */
  shipping?: "unfulfilled" | "fulfilled"
  /**
   * Specifies if the order is anonymized.
   */
  anonymized?: boolean
  /**
   * Stripe Payment Intent ID.  Please see Stripe's Payment Intent [documentation](https://docs.stripe.com/api/payment_intents) for more information on Payment Intents.
   */
  payment_intent_id?: string
  custom_attributes?: CustomAttributes
  meta?: OrderMeta
  billing_address?: BillingAddress
  contact?: Contact
  customer?: Contact
  shipping_address?: ShippingAddress
  relationships?: {
    items?: RelationshipArray
    custom_discounts?: RelationshipArray
    promotions?: RelationshipArray
    customer?: SingleRelationship
    account?: SingleRelationship
    account_member?: SingleRelationship
  }
}

export type OrderEntityResponse = {
  data?: OrderResponse
}

export type ResponseMetaOrders = {
  page?: ResponsePaginationPage
  results?: ResponsePaginationResults
}

export type OrderCollectionResponse = {
  data?: Array<OrderResponse>
  links?: ResponsePageLinks
  meta?: ResponseMetaOrders
}

export type OrdersAddressData = {
  /**
   * Specifies a user-managed, optional field used as an alternative to the existing order_id. If provided, the order-number will be sent to Authorize.net instead of the order_id, and will appear as the invoice number in Authorize.net transactions.
   */
  order_number?: string
  /**
   * Represents an optional external ID reference for an order. It can contain alphanumeric characters, special characters, and spaces, and is not required to be unique. The maximum allowed length is 64 characters. It can be used to include an external reference from a separate company system.
   */
  external_ref?: string
  shipping_address: {
    /**
     * Specifies the first name of the address holder.
     */
    first_name?: string
    /**
     * Specifies the last name of the address holder.
     */
    last_name?: string
    /**
     * Specifies the phone number of the address holder.
     */
    phone_number?: string
    /**
     * Specifies the company name.
     */
    company_name?: string
    /**
     * Specifies the first line of the address.
     */
    line_1?: string
    /**
     * Specifies the second line of the address.
     */
    line_2?: string
    /**
     * Specifies the name of the city in the shipping address.
     */
    city?: string
    /**
     * Specifies the county of the shipping address.
     */
    county?: string
    /**
     * Specifies the state, province, or region of the shipping address.
     */
    region?: string
    /**
     * Specifies the postcode or ZIP code of the address.
     */
    postcode?: string
    /**
     * Specifies the country in the shipping address.
     */
    country?: string
    /**
     * Specifies any instructions provided with the shipping address.
     */
    instructions?: string
  }
}

export type OrdersCancelData = {
  /**
   * The status of the order. You can only update the status to `cancelled`.
   */
  status: string
  /**
   * The type of the resource. You must use order.
   */
  type: string
  /**
   * Represents an optional external ID reference for an order. It can contain alphanumeric characters, special characters, and spaces, and is not required to be unique. The maximum allowed length is 64 characters. It can be used to include an external reference from a separate company system.
   */
  external_ref?: string
}

export type OrdersFulfilledData = {
  /**
   * The shipping status of the order. You can only update the shipping status to `fulfilled`.
   */
  shipping: string
  /**
   * The type of the resource. You must use order.
   */
  type: string
  /**
   * Represents an optional external ID reference for an order. It can contain alphanumeric characters, special characters, and spaces, and is not required to be unique. The maximum allowed length is 64 characters. It can be used to include an external reference from a separate company system.
   */
  external_ref?: string
}

export type OrdersUpdateRequest = {
  data?: OrdersAddressData | OrdersCancelData | OrdersFulfilledData
}

export type OrderPriceData = {
  /**
   * The amount for this item.
   */
  amount?: number
  /**
   * The currency this item.
   */
  currency?: string
  /**
   * Whether this price is tax inclusive.
   */
  includes_tax?: boolean
}

export type DiscountData = {
  amount?: OrderPriceData
  code?: string
  readonly id?: string
}

export type OrderItemFormattedUnitPriceData = {
  unit?: FormattedPriceData
  value?: FormattedPriceData
}

export type OrderItemResponse = {
  /**
   * The type represents the object being returned.
   */
  type?: string
  /**
   * The unique identifier for this order item.
   */
  readonly id?: string
  /**
   * The quantity of this item were ordered.
   */
  quantity?: number
  /**
   * The unique identifier for this order item.
   */
  readonly product_id?: string
  /**
   * The unique identifier for the subscription offering for this order item.
   */
  readonly subscription_offering_id?: string
  /**
   * The name of this order item.
   */
  name?: string
  /**
   * The SKU code for the order item.
   */
  sku?: string
  unit_price?: OrderPriceData
  value?: OrderPriceData
  discounts?: Array<DiscountData>
  links?: {
    [key: string]: unknown
  }
  meta?: {
    display_price?: {
      with_tax?: OrderItemFormattedUnitPriceData
      without_tax?: OrderItemFormattedUnitPriceData
      tax?: OrderItemFormattedUnitPriceData
      discount?: OrderItemFormattedUnitPriceData
      without_discount?: OrderItemFormattedUnitPriceData
      discounts?: {
        [key: string]: {
          amount?: number
          currency?: string
          formatted?: string
        }
      }
    }
    timestamps?: CartCheckoutTimestamps
  }
  relationships?: {
    cart_item?: {
      data?: {
        /**
         * The type represents the object being returned.
         */
        type?: string
        /**
         * The unique identifier for this item.
         */
        readonly id?: string
      }
    }
  }
  /**
   * The unique identifier of the catalog associated with the product is shown if `catalog_source=pim` is set.
   */
  catalog_id?: string
  /**
   * The catalog source. Always `pim` or `legacy`.
   */
  catalog_source?: string
}

export type OrderItemCollectionResponse = {
  data?: Array<OrderItemResponse>
}

export type OrdersAnonymizeData = {
  /**
   * The unique identifiers of the orders to be anonymized. You can anonymize multiple orders at the same time.
   */
  order_ids?: Array<string>
}

export type OrdersAnonymizeRequest = {
  data?: OrdersAnonymizeData
}

export type OrdersListResponse = {
  data: Array<OrderResponse>
}

export type DataAdyenPayment = DataBasePayments & {
  /**
   * Specifies the gateway. You must use `adyen`.
   */
  gateway: "adyen"
  options?: {
    /**
     * The shopper reference token associated with the saved payment method.
     */
    shopper_reference?: string
    /**
     * Enter CardOnFile for a one-time purchase.
     */
    recurring_processing_model?: string
  }
  /**
   * The Adyen recurringDetailReference payment method identifier.
   */
  payment: string
}

export type DataAuthorizeNetPayment = DataBasePayments & {
  /**
   * Specifies the gateway. You must use `authorize_net`.
   */
  gateway: "authorize_net"
  options?: {
    /**
     * The Authorize.net customer payment profile ID.
     */
    customer_payment_profile_id?: string
  }
  /**
   * The Authorize.net customer profile ID.
   */
  payment: string
}

export type DataBraintreePayment = DataBasePayments & {
  /**
   * Specifies the gateway. You must use `braintree`.
   */
  gateway: "braintree"
  /**
   * The Braintree Customer ID that you want to bill.
   */
  payment: string
}

export type DataCardConnectPayment = DataBasePayments & {
  /**
   * Specifies the gateway. You must use `card_connect`.
   */
  gateway: "card_connect"
  /**
   * Enter account_id, profile_id from CardPointe API. For example, 1|16178397535388255208.
   */
  payment: string
}

export type DataCyberSourcePayment = DataBasePayments & {
  /**
   * Specifies the gateway. You must use `cyber_source`.
   */
  gateway: "cyber_source"
  /**
   * The CyberSource token.
   */
  payment: string
}

export type DataManualPayment = DataBasePayments & {
  /**
   * Specifies the type of payment gateway. You must use `manual`.
   */
  gateway: "manual"
  paymentmethod_meta?: {
    /**
     * A reference associated with the payment method. This might include loyalty points or gift card identifiers. We recommend not to include personal information in this field.
     */
    custom_reference?: string
    /**
     * A custom name associated with the payment method.
     */
    name?: string
  }
}

export type DataPayPalExpressCheckoutPayment = DataBasePayments & {
  /**
   * Specifies the type of payment gateway. You must use `paypal_express_checkout`.
   */
  gateway: "paypal_express_checkout"
  options?: {
    /**
     * The description for the payment.
     */
    description?: string
    /**
     * The descriptor appended to PayPal generated descriptor that is visible on the card statement of the payer.
     */
    soft_descriptor?: string
    application_context?: {
      /**
       * The label that overrides the business name in the PayPal account on the PayPal site.
       */
      brand_name?: string
      /**
       * The locale pages that appear based on language and country code. PayPal supports a five-character code. For example, ja-JP.
       */
      locale?: string
      /**
       * The type of landing page to show on the PayPal site for customer checkout. Use values LOGIN, BILLING, or NO_PREFERENCE.
       */
      landing_page?: string
      /**
       * The shipping preference. Use SET_PROVIDED_ADDRESS value. This parameter does allow the user to change their address on PayPal site.
       */
      shipping_preference?: string
      /**
       * If you set `useraction=commit` in the query string, the flow redirects the buyer to the PayPal payment page and displays a Pay Now button. When the shopper clicks **Pay Now**, call `DoExpressCheckoutPayment` to complete the payment without additional interaction from the shopper. Choose this flow when you know the final payment amount when you initiate the checkout flow.
       */
      user_action?: string
      /**
       * The callback URL for PayPal to redirect the user in the case of approved payment.
       */
      return_url?: string
      /**
       * The callback URL for PayPal to redirect user in the case a cancelled payment.
       */
      cancel_url?: string
    }
  }
}

export type DataStripePayment = DataBasePayments & {
  /**
   * Specifies the type of payment gateway. You must use `stripe`.
   */
  gateway: "stripe"
  options?: {
    /**
     * The option to provide an email for Stripe receipts. Specify live mode to access this feature.
     */
    receipt_email?: string
  }
  /**
   * The Stripe token or source.
   */
  payment?: string
}

export type DataStripeConnectPayment = DataBasePayments & {
  /**
   * Specifies the type of payment gateway. You must use `stripe_connect`.
   */
  gateway: "stripe_connect"
  options?: {
    /**
     * Provides the email address to which you want to send the Stripe receipts for the transactions within the store. This feature is available only in the live mode.
     */
    receipt_email?: string
  }
  /**
   * Specifies the Stripe token or source.
   */
  payment?: string
}

export type DataStripePaymentIntentsPayment = DataBasePayments & {
  /**
   * Specifies the type of payment gateway. You must use `stripe_payment_intents`.
   */
  gateway: "stripe_payment_intents"
  options?: {
    /**
     * Provides the email address to which you want to send the Stripe receipts for the transactions within the store. This feature is available only in the live mode.
     */
    receipt_email?: string
  }
  /**
   * Specifies the Stripe token or source.
   */
  payment?: string
}

export type DataPaymentObject =
  | DataAdyenPayment
  | DataAuthorizeNetPayment
  | DataBraintreePayment
  | DataCardConnectPayment
  | DataCyberSourcePayment
  | ElasticPathPaymentsPoweredByStripePayment
  | DataManualPayment
  | DataPayPalExpressCheckoutPayment
  | DataStripePayment
  | DataStripeConnectPayment
  | DataStripePaymentIntentsPayment

export type PaymentsRequest = {
  data?: DataPaymentObject
}

export type TransactionResponse = {
  /**
   * The ID of the transaction.
   */
  readonly id?: string
  /**
   * The payment gateway reference.
   */
  reference?: string
  /**
   * A custom name associated with the payment method.
   */
  name?: string
  /**
   * A reference associated with the payment method. This might include loyalty points or gift card identifiers. We recommend you not to include personal information in this field.
   */
  custom_reference?: string
  /**
   * The name of the payment gateway used.
   */
  gateway?:
    | "adyen"
    | "authorize_net"
    | "braintree"
    | "card_connect"
    | "cyber_source"
    | "elastic_path_payments_stripe"
    | "manual"
    | "paypal_express_checkout"
    | "stripe"
    | "stripe_connect"
    | "stripe_payment_intents"
    | "stripe_platform_account"
  /**
   * The amount for this transaction.
   */
  amount?: number
  /**
   * The refunded amount.
   */
  refunded_amount?: number
  /**
   * The transaction currency.
   */
  currency?: string
  /**
   * The type of transaction, such as `purchase`, `capture`, `authorize` or `refund`.
   */
  "transaction-type"?: string
  /**
   * The status provided by the gateway for this transaction, such as `complete` or `failed`.
   */
  status?: string
  relationships?: {
    order?: {
      data?: {
        /**
         * Represents the type of the object being returned. It is always `order`.
         */
        type?: string
        /**
         * The ID of the order.
         */
        id?: string
      }
    }
  }
  meta?: {
    display_price?: FormattedPriceData
    display_refunded_amount?: FormattedPriceData
    timestamps?: CartCheckoutTimestamps
  }
}

export type TransactionEntityResponse = {
  data: TransactionResponse
}

export type OrdersTransactionsConfirmRequest = {
  data?: {
    [key: string]: unknown
  }
}

export type OrdersTransactionsCaptureRequest = {
  data?: {
    options?: {
      soft_descriptor?: string
      note_to_payer?: string
    }
  }
}

export type OrdersTransactionsRefundRequest = {
  data?: {
    /**
     * The amount value to be refunded. If this field is not provided, it will be considered as manual refund (Mark as Refunded) and the refund process must be manually handled via payment provider. If the amount value is same as payment value, then it will be treated as a full refund and sent to the payment provider to process refund automatically.
     */
    amount?: number
    options?: {
      /**
       * Provides comments about the refund. It is used by PayPal Express.
       */
      note?: string
    }
  }
}

export type TransactionListResponse = {
  data: Array<TransactionResponse>
}

export type ResponseData = {
  data?: unknown
}

export type OrdersTransactionsCancelRequest = {
  data?: {
    options?: {
      [key: string]: unknown
    }
    /**
     * Specifies the reason for canceling the transaction. The reason may include `duplicate`, `fraudulent`, `requested_by_customer`, or `abandoned`.
     */
    reason?: string
  }
}

export type UpdateOrderShippingGroupRequest = {
  data?: {
    type?: "shipping_group"
    shipping_type?: string
    tracking_reference?: string
    address?: ShippingAddress
    delivery_estimate?: DeliveryEstimate
  }
}

export type CartCheckoutTimestamps = {
  /**
   * The date this was created.
   */
  created_at?: string
  /**
   * The date this was last updated.
   */
  updated_at?: unknown
}

export type CartIncludedPromotion = {
  /**
   * The unique identifier of the promotion.
   */
  id: string
  /**
   * The name of the promotion.
   */
  name: string
  /**
   * A description of the promotion.
   */
  description?: string
  /**
   * Indicates if the promotion is automatic.
   */
  automatic: boolean
  /**
   * The source of the promotion.
   */
  promotion_source: string
  /**
   * The start date and time of the promotion.
   */
  start: Date
  /**
   * The end date and time of the promotion.
   */
  end: Date
}

/**
 * Included is an array of resources that are included in the response.
 */
export type CartIncluded = {
  /**
   * The cart items associated with a cart.
   */
  items?: Array<
    | CartItemObject
    | CustomItemObject
    | SubscriptionItemObject
    | PromotionItemObject
  >
  /**
   * The tax items associated with a cart.
   */
  tax_items?: Array<CartsItemsTaxesObject>
  /**
   * The custom discounts associated with a cart.
   */
  custom_discounts?: Array<CartsCustomDiscountsObject>
  /**
   * The promotions associated with a cart.
   */
  promotions?: Array<CartIncludedPromotion>
}

/**
 * Whether a pricing option is active on a subscription using that offering. The `active_pricing_option` attribute is null if a pricing option is not active in a subscription.
 */
export type ActivePricingOption = boolean

/**
 * Whether a plan is active on a subscription using that offering. The `active_plan` attribute is null if a plan is not active in a subscription.
 */
export type ActivePlan = boolean

/**
 * A unique attribute that you could use to contain information from another company system, for example. The maximum length is 2048 characters.
 */
export type ExternalRef = string

/**
 * A unique attribute that you could use to contain information from another company system, for example. The maximum length is 2048 characters.
 */
export type ExternalRefUpdate = string | null

export type SubscriptionType = "subscription"

export type ProrationPolicyType = "subscription_proration_policy"

export type SubscriptionDunningRuleType = "subscription_dunning_rule"

export type SubscriptionFeatureType = "subscription_feature"

export type SubscriptionOfferingType = "subscription_offering"

export type SubscriptionOfferingFeatureType = "subscription_offering_feature"

export type SubscriptionOfferingPlanType = "subscription_offering_plan"

export type SubscriptionOfferingPricingOptionType =
  "subscription_offering_pricing_option"

export type SubscriptionJobType = "subscription_job"

export type SubscriptionImportType = "subscription_import"

export type SubscriptionImportErrorType = "subscription_import_error"

export type SubscriptionImportError = {
  id: SubscriptionsUuid
  type: SubscriptionImportErrorType
  meta: SubscriptionImportErrorMeta
}

export type SubscriptionImportErrorMeta = {
  owner: string
  timestamps: SubscriptionsTimestamps
  error: string
  field: string
  /**
   * The line in the imported JSONL file at which the validation error occurred. Starts from 1.
   */
  line_number: number
  external_ref?: ExternalRef
}

/**
 * This represents the type of resource object being returned. Always `subscription_invoice`.
 */
export type SubscriptionInvoiceType = "subscription_invoice"

/**
 * This represents the type of resource object being returned. Always `subscription_invoice_payment`.
 */
export type SubscriptionInvoicePaymentType = "subscription_invoice_payment"

export type Links2 = {
  [key: string]: Link
}

export type Link = LinkUri | LinkObject

export type LinkUri = string | null

export type LinkObject = {
  href?: string
  title?: string
  describedby?: string
}

/**
 * The status of a subscription, either `active` or `inactive`.
 */
export type Status2 = "active" | "inactive"

/**
 * Enumerates a list of resources that are related.
 */
export type RelationshipsRequest = {
  data: Array<RelationshipData>
}

/**
 * Relationships are established between different subscription entities. For example, a plan and a pricing option are related to an offering, as both are attached to it.
 */
export type Relationships = unknown

export type Relationship = SubscriptionsSingleRelationship | ManyRelationship

/**
 * The list of resources that are related.
 */
export type ManyRelationship = {
  data?: Array<RelationshipData>
  links?: RelationshipLinks
}

export type RelationshipData = {
  id: SubscriptionsUuid
  /**
   * This represents the type of resource being returned.
   */
  type: string
}

/**
 * Links are used to allow you, as an API consumer, to move between requests. Single entities use a self parameter with a link to that specific resource. Sometimes, there arent enough entities for a project to fill multiple pages. In this situation, we return some defaults, instead of expecting you to check for these special cases.
 *
 * - current - Always the current page.
 * - first - Always the first page.
 * - last - always `null`.
 * - next - `null` if the user is on the first page.
 * - previous - `null` if there is only one page.
 *
 */
export type RelationshipLinks = {
  related?: string
}

/**
 * A period of time between a start and end point.
 */
export type TimePeriod = {
  /**
   * The date and time a billing period started.
   */
  start: Date
  /**
   * The date and time a billing period ended.
   */
  end: Date
}

/**
 * A price in a single currency.
 */
export type SingleCurrencyPrice = {
  /**
   * The three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html) in uppercase, associated with a price.
   */
  currency: string
  /**
   * The value as a whole number of the currency's smallest subdivision.
   */
  amount: BigInt
  /**
   * Whether the amount includes any taxes.
   */
  includes_tax?: boolean
}

/**
 * A unit of time.
 */
export type Unit = "day" | "month"

/**
 * The timeframe during which the plan price is applicable. For example, for a streaming service, the price is $12.99 and the `unit` is `months` and the `amount` is `1`. In other words, the streaming service is available for $12.99 a month. You may want to specify a unit price if you have many plans that all have different prices. Rather than having to create separate pricing options for each plan, you can specify the timeframe during which the plan price is applicable and then create one pricing option that determines the billing frequency for those plans.
 */
export type PriceUnits = {
  /**
   * A unit of time.
   */
  unit: "day" | "month"
  /**
   * The number of days or months the period covers.
   */
  amount: number
}

/**
 * The timeframe during which the plan price is applicable. For example, for a streaming service, the price is $12.99 and the `unit` is `months` and the `amount` is `1`. In other words, the streaming service is available for $12.99 a month. You may want to specify a unit price if you have many plans that all have different prices. Rather than having to create separate pricing options for each plan, you can specify the timeframe during which the plan price is applicable and then create one pricing option that determines the billing frequency for those plans.
 */
export type NullablePriceUnits = {
  /**
   * A unit of time, either days or months.
   */
  unit: "day" | "month"
  /**
   * The number of days or months the period covers.
   */
  amount: number
} | null

export type Price = unknown

export type NullablePrice = {
  [key: string]: {
    /**
     * The value as a whole number of the currency's smallest subdivision.
     */
    amount: BigInt
    /**
     * Whether the amount includes any taxes.
     */
    includes_tax?: boolean
  } | null
} | null

/**
 * A list of plan prices for each of its pricing options.
 */
export type OfferingPlanPrices = {
  [key: string]: OfferingPlanPriceForPricingOption
}

export type OfferingPlanPriceForPricingOption = {
  price?: Price
  display_price?: DisplayPrice2
}

export type DisplayPrice2 = {
  without_tax?: PriceFormatting
  with_tax?: PriceFormatting
}

export type PriceFormatting = {
  /**
   * The unformatted amount for the objects.
   */
  amount: BigInt
  /**
   * The three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html) in uppercase, associated with a price.
   */
  currency: string
  /**
   * The formatted amount for the objects.
   */
  formatted: string
}

export type Feature = {
  id?: SubscriptionsUuid
  type: SubscriptionFeatureType
  attributes: FeatureResponseAttributes
  meta: FeatureMeta
}

export type FeatureMeta = {
  owner: OwnerMeta
  timestamps: SubscriptionsTimestamps
}

export type FeatureCreate = {
  type: SubscriptionFeatureType
  attributes: FeatureAttributes
}

export type FeatureUpdate = {
  id: SubscriptionsUuid
  type: SubscriptionFeatureType
  attributes: FeatureUpdateAttributes
}

export type OfferingFeatureCreate = {
  type: SubscriptionOfferingFeatureType
  attributes: FeatureAttributes
}

export type FeatureResponseAttributes = FeatureAttributes

/**
 * A tag to add to the customer's account when entitled to the feature.
 */
export type FeatureTag = string

export type FeatureAccessAttributes = {
  type: "access"
  tag: FeatureTag
}

export type FeaturePromotion = {
  /**
   * The name of the feature.
   */
  name: string
  tag: FeatureTag
  promotion_id?: SubscriptionsUuid
}

export type FeaturePromotionAttributes = {
  type: "promotion"
  promotions: Array<FeaturePromotion>
}

export type FeatureUsageAttributes = {
  type: "usage"
  tag: FeatureTag
  /**
   * The property that has a usage limit.
   */
  label: string
  /**
   * The default initial value
   */
  default_value: number
}

export type FeatureConfiguration = (
  | ({
      type?: "access"
    } & FeatureAccessAttributes)
  | ({
      type?: "promotion"
    } & FeaturePromotionAttributes)
  | ({
      type?: "usage"
    } & FeatureUsageAttributes)
) & {
  /**
   * The type of feature, one of access, promotion or usage.
   */
  type: "access" | "promotion" | "usage"
}

export type FeatureAttributes = {
  external_ref?: ExternalRef
  /**
   * The name of the feature.
   */
  name: string
  /**
   * The feature description to display to customers.
   */
  description?: string
  configuration: FeatureConfiguration
}

export type FeatureUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  /**
   * The name of the feature.
   */
  name?: string
  /**
   * The feature description to display to customers.
   */
  description?: string | null
  configuration?: FeatureConfiguration
}

export type PlanMeta = {
  prices?: OfferingPlanPrices
  display_price?: DisplayPrice2
  owner: OwnerMeta
  timestamps: SubscriptionsTimestamps
  active_plan?: ActivePlan
}

export type OfferingPlanCreate = {
  type: SubscriptionOfferingPlanType
  attributes: OfferingPlanAttributes
  relationships?: Relationships
}

export type OfferingPlanAttributes = PlanAttributes &
  OfferingPlanExtraAttributes

export type OfferingPlanResponseAttributes = PlanResponseAttributes &
  OfferingPlanResponseExtraAttributes

export type OfferingPlanExtraAttributes = {
  /**
   * A map of configurations indicating which features are available for the plan
   */
  feature_configurations?: {
    [key: string]: FeaturePlanConfiguration
  }
}

export type OfferingPlanResponseExtraAttributes = {
  /**
   * A map of configurations indicating which features are available for the plan
   */
  feature_configurations: {
    [key: string]: FeaturePlanConfiguration
  }
}

export type PlanResponseAttributes = PlanAttributes & SubscriptionsTimestamps

export type PlanAttributes = {
  external_ref?: ExternalRef
  /**
   * The name of the plan.
   */
  name: string
  /**
   * The plan or service description to display to customers.
   */
  description?: string
  /**
   * A stock keeping unit for the plan, if appropriate.
   */
  sku?: string
  /**
   * A URL from which an image or file for the plan can be fetched. You can either upload your images and files to Commerce using the Commerce Files API or you can use your own content delivery network. If you are using the Commerce Files API, use [**Create a File**](/docs/api/pxm/files/create-a-file) to upload your file and return an HREF link in the response. An extensive range of [**media and file extensions**](/docs/api/pxm/files/files-service-api) are supported.
   */
  main_image?: string
  price?: Price
  price_units?: PriceUnits
}

export type OfferingPlanUpdateAttributes = PlanUpdateAttributes &
  OfferingPlanUpdateExtraAttributes

export type OfferingPlanUpdateExtraAttributes = {
  /**
   * A map of configurations indicating which features are available for the plan
   */
  feature_configurations?: {
    [key: string]: FeaturePlanConfigurationUpdate
  }
}

export type PlanUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  /**
   * The name of the plan.
   */
  name?: string
  /**
   * The plan or service description to display to customers.
   */
  description?: string | null
  /**
   * A stock keeping unit for the plan, if appropriate.
   */
  sku?: string | null
  /**
   * A URL from which an image or file for the plan can be fetched. You can either upload your images and files to Commerce using the Commerce Files API or you can use your own content delivery network. If you are using the Commerce Files API, use [**Create a File**](/docs/api/pxm/files/create-a-file) to upload your file and return an HREF link in the response. An extensive range of [**media and file extensions**](/docs/api/pxm/files/files-service-api) are supported.
   */
  main_image?: string | null
  price?: NullablePrice
  price_units?: NullablePriceUnits
}

export type DunningRule = {
  id?: SubscriptionsUuid
  type: SubscriptionDunningRuleType
  attributes: DunningRuleAttributes
  meta: DunningRuleMeta
}

export type DunningRuleMeta = {
  owner: OwnerMeta
  timestamps: SubscriptionsTimestamps
}

export type DunningRuleCreate = {
  type: SubscriptionDunningRuleType
  attributes: DunningRuleAttributes
}

export type DunningRuleUpdate = {
  id: SubscriptionsUuid
  type: SubscriptionDunningRuleType
  attributes: DunningRuleUpdateAttributes
}

/**
 * The strategy used to make payments. Always `fixed`. This means payments are retried on a fixed schedule as defined by the `payment_retry_unit` and `payment_retry_interval`, for example, every two days.
 *
 */
export type PaymentRetryType = "fixed" | "backoff" | "tiered"

/**
 * The unit of time used to measure the intervals between payment attempts or retries.
 */
export type PaymentRetryUnit = "day" | "week"

/**
 * The action to take after all payment attempts for an invoice have failed.
 *
 * - None - the subscription remains active and Subscriptions does not attempt to retry the payment. However, the subscription is still available for a subscriber to use.
 * - Suspend the subscription. Subscriptions does not attempt to retry the payment. A subscriber can choose to pay the outstanding invoice. However, a subscriber cannot renew their subscription; a merchandizer must renew the subscription on behalf of the subscriber.
 * - close a subscription. The subscription ends and it's status becomes `inactive`. However, a merchandizer can choose to resume the subscription if a subscriber pays the outstanding payment.
 *
 */
export type Action = "none" | "pause" | "close" | "suspend"

/**
 * The dunning rule attributes you can use to configure your payment retry strategy.
 *
 */
export type DunningRuleAttributes = {
  /**
   * The strategy used to make payments. Always `fixed`. This means payments are retried on a fixed schedule as defined by the `payment_retry_unit` and `payment_retry_interval`, for example, every two days.
   *
   */
  payment_retry_type: "fixed" | "backoff" | "tiered"
  /**
   * The number of `payment_interval_unit`s to wait between each payment retry attempt.
   */
  payment_retry_interval?: BigInt
  /**
   * The unit of time used to measure the intervals between payment attempts or retries.
   */
  payment_retry_unit?: "day" | "week"
  /**
   * The multiplier that increases the interval between consecutive each payment attempts or retries. This is typically used to gradually extend the time between retries. Allowing more time between attempts as failures persist, helps reduce the risk of triggering multiple failures in a short period and gives the subscriber more time to resolve the issue. Must only be set for backup types.
   */
  payment_retry_multiplier?: number
  /**
   * The number of times Subscriptions attempts payment retries before `action` is taken.
   */
  payment_retries_limit: BigInt
  /**
   * The action to take after all payment attempts for an invoice have failed.
   *
   * - None - the subscription remains active and Subscriptions does not attempt to retry the payment. However, the subscription is still available for a subscriber to use.
   * - Suspend the subscription. Subscriptions does not attempt to retry the payment. A subscriber can choose to pay the outstanding invoice. However, a subscriber cannot renew their subscription; a merchandizer must renew the subscription on behalf of the subscriber.
   * - close a subscription. The subscription ends and it's status becomes `inactive`. However, a merchandizer can choose to resume the subscription if a subscriber pays the outstanding payment.
   *
   */
  action: "none" | "pause" | "close" | "suspend"
  /**
   * Set to `true` if you want this rule to be the default for the store.
   */
  default?: boolean
}

export type DunningRuleUpdateAttributes = {
  /**
   * The strategy used to make payments. Always `fixed`. This means payments are retried on a fixed schedule as defined by the `payment_retry_unit` and `payment_retry_interval`, for example, every two days.
   *
   */
  payment_retry_type?: "fixed" | "backoff" | "tiered"
  /**
   * The number of `payment_interval_unit`s to wait between each payment retry attempt.
   */
  payment_retry_interval?: BigInt | null
  /**
   * The unit of time used to measure the intervals between payment attempts or retries.
   */
  payment_retry_unit?: "day" | "week"
  /**
   * The multiplier that increases the interval between consecutive each payment attempts or retries. This is typically used to gradually extend the time between retries. Allowing more time between attempts as failures persist, helps reduce the risk of triggering multiple failures in a short period and gives the subscriber more time to resolve the issue. Must only be set for backup types.
   */
  payment_retry_multiplier?: number | null
  /**
   * The number of times Subscriptions attempts payment retries before `action` is taken.
   */
  payment_retries_limit?: BigInt
  /**
   * The action to take after all payment attempts for an invoice have failed.
   */
  action?: "none" | "pause" | "close" | "suspend"
  /**
   * Set to `true` if you want this rule to be the default for the store.
   */
  default?: boolean
}

export type ProrationPolicy = {
  id?: SubscriptionsUuid
  type: ProrationPolicyType
  attributes: ProrationPolicyResponseAttributes
  meta: ProrationPolicyMeta
}

export type ProrationPolicyUpdate = {
  id: SubscriptionsUuid
  type: ProrationPolicyType
  attributes: ProrationPolicyUpdateAttributes
}

export type ProrationPolicyRelationshipAttributes = {
  type: ProrationPolicyType
  id: SubscriptionsUuid
}

export type ProrationPolicyUpdateRelationshipAttributes = {
  type: ProrationPolicyType
  id: SubscriptionsUuid
} | null

export type ProrationPolicyResponseAttributes = ProrationPolicyAttributes

export type ProrationPolicyCreate = {
  type: ProrationPolicyType
  attributes: ProrationPolicyAttributes
}

/**
 * When rounding in proration, you must decide how to round the units of time used to calculate the charges.
 *
 * - round up to the next unit, ensuring subscribers are charged slightly more to cover any partial use.
 * - round down to the previous whole unit, providing subscribers with a slight benefit by not charging for partial use.
 * - round to the nearest whole unit, whether up or down, based on standard rounding rules. For example, rounding 0.5 up and rounding 0.5 down.
 *
 */
export type Rounding = "up" | "down" | "nearest"

export type ProrationPolicyAttributes = {
  /**
   * A name for the proration policy.
   */
  name: string
  /**
   * When rounding in proration, you must decide how to round the units of time used to calculate the charges.
   *
   * - round up to the next unit, ensuring subscribers are charged slightly more to cover any partial use.
   * - round down to the previous whole unit, providing subscribers with a slight benefit by not charging for partial use.
   * - round to the nearest whole unit, whether up or down, based on standard rounding rules. For example, rounding 0.5 up and rounding 0.5 down.
   *
   */
  rounding: "up" | "down" | "nearest"
  external_ref?: ExternalRef
}

export type ProrationPolicyUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  /**
   * The name of the proration policy.
   */
  name?: string
  /**
   * Whether to round up or down
   */
  rounding?: "up" | "down" | "nearest"
}

export type ProrationPolicyMeta = {
  owner: OwnerMeta
  timestamps: SubscriptionsTimestamps
}

export type OfferingPricingOptionCreate = {
  type: SubscriptionOfferingPricingOptionType
  attributes: PricingOptionAttributes
}

export type PricingOptionResponseAttributes = PricingOptionAttributes &
  SubscriptionsTimestamps

/**
 * The unit of time that billing intervals are measured.
 */
export type BillingIntervalType = "day" | "week" | "month" | "year"

/**
 * Enables you to specify recurring payments. If `end_behavior` is `roll`, customers pay regularly and repeatedly. If `end_behavior` is `close`, customers pay a total amount in a limited number of partial payments.
 */
export type EndBehavior = "close" | "roll"

export type PricingOptionAttributes = {
  external_ref?: ExternalRef
  /**
   * A name for the pricing option.
   */
  name: string
  /**
   * The pricing option description to display to customers.
   */
  description?: string
  /**
   * The unit of time that billing intervals are measured.
   */
  billing_interval_type: "day" | "week" | "month" | "year"
  /**
   * The number of intervals between issuing bills.
   */
  billing_frequency: number
  /**
   * The number of intervals from the start of the subscription before billing starts. Used with `billing_interval_type`. For example, if `billing_interval_type` is `months`, and `trial_period` is `1`, the trial period is 1 month.
   */
  trial_period?: number
  /**
   * The number of intervals that the subscription runs for.
   */
  plan_length: number
  /**
   * Enables you to specify recurring payments. If `end_behavior` is `roll`, customers pay regularly and repeatedly. If `end_behavior` is `close`, customers pay a total amount in a limited number of partial payments.
   */
  end_behavior: "close" | "roll"
  /**
   * The subscriber can pause a subscription.
   */
  can_pause: boolean
  /**
   * The subscriber can resume a paused subscription.
   */
  can_resume: boolean
  /**
   * The subscriber can cancel a subscription.
   */
  can_cancel: boolean
  /**
   * A percentage discount on the total cost of any plans within an offering. For example, you can configure a percentage that equates the cost of a pricing option to the total value of all plans within the offering, reduced by a percentage. For example, if you specify `10`, a 10% discount is applied to the total value of all repeat plans in an offering.
   */
  base_price_percentage?: number
  fixed_price?: Price
}

export type PricingOptionUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  name?: string
  /**
   * The pricing option description to display to customers.
   */
  description?: string | null
  /**
   * The unit of time in which billing intervals are measured.
   */
  billing_interval_type?: "day" | "week" | "month" | "year"
  /**
   * The number of intervals between issuing bills.
   */
  billing_frequency?: number
  /**
   * The number of intervals from the start of the subscription before billing starts. Used with `billing_interval_type`. For example, if `billing_interval_type` is `months`, and `trial_period` is `1`, the trial period is 1 month.
   */
  trial_period?: number | null
  /**
   * The length of time for which a subscription plan is valid. For example, six months after which the plan is renewed.
   */
  plan_length?: number
  /**
   * Enables you to specify recurring payments. If `end_behavior` is `roll`, customers pay regularly and repeatedly. If `end_behavior` is `close`, customers pay a total amount in a limited number of partial payments.
   */
  end_behavior?: "close" | "roll"
  /**
   * The subscriber can pause a subscription.
   */
  can_pause?: boolean
  /**
   * The subscriber can resume a paused subscription.
   */
  can_resume?: boolean
  /**
   * The subscriber can cancel a subscription.
   */
  can_cancel?: boolean
  /**
   * A percentage discount on the total cost of any plans within an offering. For example, you can configure a percentage that equates the cost of a pricing option to the total value of all plans within the offering, reduced by a percentage. For example, if you specify `10`, a 10% discount is applied to the total value of all repeat plans in an offering.
   */
  base_price_percentage?: number | null
  fixed_price?: NullablePrice
}

export type BuildOffering = {
  external_ref?: ExternalRef
  /**
   * The name of the offering.
   */
  name: string
  /**
   * The offering description to display to customers.
   */
  description?: string
  /**
   * The unique ID or external ref of the proration policy
   */
  proration_policy_id?: string
  configured_features?: OfferingBuildConfiguredFeatures
  pricing_option_associations?: OfferingBuildPricingOptionAssociations
  /**
   * Either references of existing features (id or external_ref) to be attached to the offering or feature information to be created directly within the offering
   */
  features?: Array<ExternalRef | FeatureAttributes | SubscriptionsUuid>
  /**
   * Plan information to be created within the offering
   */
  plans: Array<OfferingPlanAttributes>
  /**
   * Pricing options information to be created within the offering
   */
  pricing_options: Array<PricingOptionAttributes>
}

export type Offering = {
  id?: SubscriptionsUuid
  type: SubscriptionOfferingType
  attributes: OfferingResponseAttributes
  relationships?: Relationships
  meta: OfferingMeta
}

export type OfferingIncludes = {
  features?: Array<OfferingFeature>
  plans?: Array<OfferingPlan>
  pricing_options?: Array<OfferingPricingOption>
}

export type OfferingMeta = {
  external_plan_refs: Array<OfferingPlanExternalRefMeta>
  owner: OwnerMeta
  timestamps: SubscriptionsTimestamps
}

export type OfferingCreate = {
  type: SubscriptionOfferingType
  attributes: OfferingAttributes
  relationships?: OfferingRelationships
}

export type OfferingPlanUpdate = {
  id: SubscriptionsUuid
  type: SubscriptionOfferingPlanType
  attributes: OfferingPlanUpdateAttributes
}

/**
 * Configures an access feature against a plan in an offering, indicating that the referenced feature is a benefit of that plan.
 */
export type FeatureConfigAccessAttributes = {
  type: "access"
}

/**
 * Configures a promotion feature against a plan in an offering, indicating that the referenced feature is a benefit of that plan. The tag of the specific promotion that it to be made available must be supplied.
 */
export type FeatureConfigPromotionAttributes = {
  type: "promotion"
  tag: FeatureTag
}

/**
 * Configures a usage feature against a plan in an offering, indicating that the referenced feature is a benefit of that plan. The default value that the usage metrics adopts must be supplied.
 */
export type FeatureConfigUsageAttributes = {
  type: "usage"
  /**
   * The default initial value
   */
  default_value: number
}

export type FeaturePlanConfiguration = (
  | ({
      type?: "access"
    } & FeatureConfigAccessAttributes)
  | ({
      type?: "promotion"
    } & FeatureConfigPromotionAttributes)
  | ({
      type?: "usage"
    } & FeatureConfigUsageAttributes)
) & {
  /**
   * The type of feature, one of access, promotion or usage.
   */
  type: "access" | "promotion" | "usage"
}

export type FeaturePlanConfigurationUpdate = (
  | ({
      type?: "access"
    } & FeatureConfigAccessAttributes)
  | ({
      type?: "promotion"
    } & FeatureConfigPromotionAttributes)
  | ({
      type?: "usage"
    } & FeatureConfigUsageAttributes)
  | null
) & {
  /**
   * The type of feature, one of access, promotion or usage.
   */
  type: "access" | "promotion" | "usage"
}

export type OfferingBuildPlanPricingOptions = Array<string>

/**
 * A map of plans keyed by plan UUID or external_ref to a list of associated pricing options, similarly keyed.
 */
export type OfferingBuildPricingOptionAssociations = {
  [key: string]: OfferingBuildPlanPricingOptions
}

/**
 * Map of feature configurations keyed by plan UUID or external_ref
 */
export type OfferingBuildConfiguredFeatures = {
  [key: string]: OfferingBuildPlanFeatures
}

/**
 * A map of configurations indicating which features are available for the plan
 */
export type OfferingBuildPlanFeatures = {
  [key: string]: FeaturePlanConfiguration
}

export type OfferingFeatureUpdate = {
  id: SubscriptionsUuid
  type: SubscriptionOfferingFeatureType
  attributes: FeatureUpdateAttributes
}

export type OfferingFeature = {
  id?: SubscriptionsUuid
  type: SubscriptionOfferingFeatureType
  attributes: FeatureResponseAttributes
  relationships?: Relationships
  meta: FeatureMeta
}

export type OfferingPlan = {
  id?: SubscriptionsUuid
  type: SubscriptionOfferingPlanType
  attributes: OfferingPlanResponseAttributes
  relationships?: Relationships
  meta: PlanMeta
}

export type OfferingPricingOptionUpdate = {
  id: SubscriptionsUuid
  type: SubscriptionOfferingPricingOptionType
  attributes: PricingOptionUpdateAttributes
}

export type OfferingPricingOption = {
  id?: SubscriptionsUuid
  type: SubscriptionOfferingPricingOptionType
  attributes: PricingOptionResponseAttributes
  relationships?: Relationships
  meta: OfferingPricingOptionMeta
}

export type OfferingPricingOptionMeta = {
  prices?: OfferingPricingOptionPrices
  price?: Price
  display_price?: DisplayPrice2
  active_pricing_option?: ActivePricingOption
  owner: OwnerMeta
  timestamps: SubscriptionsTimestamps
}

/**
 * The price of each plan within the offering that this pricing option may be applied to.
 */
export type OfferingPricingOptionPrices = {
  [key: string]: OfferingPricingOptionPriceForPlan
}

export type OfferingPricingOptionPriceForPlan = {
  price?: Price
  display_price?: DisplayPrice2
}

/**
 * A list of feature IDs to attach to the offering. See [**List Features**](/docs/api/subscriptions/list-features).
 */
export type OfferingFeatureAttach = {
  features: Array<SubscriptionsUuid>
}

export type OfferingUpdate = unknown & {
  id: SubscriptionsUuid
  type: SubscriptionOfferingType
  attributes?: OfferingUpdateAttributes
  relationships?: OfferingUpdateRelationships
}

export type OfferingResponseAttributes = OfferingAttributes &
  SubscriptionsTimestamps

export type OfferingAttributes = {
  external_ref?: ExternalRef
  /**
   * The name of the offering.
   */
  name: string
  /**
   * The offering description to display to customers.
   */
  description?: string
}

export type OfferingUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  /**
   * The name of the offering.
   */
  name?: string
  /**
   * The offering description to display to customers.
   */
  description?: string | null
}

export type OfferingRelationships = {
  proration_policy?: ProrationPolicyRelationshipAttributes
}

export type OfferingUpdateRelationships = {
  proration_policy?: ProrationPolicyUpdateRelationshipAttributes
}

/**
 * A subscription may optionally be associated with an item in an order by supplying both the order ID and the ID of the item within that order.
 */
export type BuildSubscriptionOrder = {
  order_id: SubscriptionsUuid
  order_item_id: SubscriptionsUuid
}

export type BuildSubscription = {
  external_ref?: ExternalRef
  account_id: SubscriptionsUuid
  address_id?: SubscriptionsUuid
  offering_external_ref?: ExternalRef
  offering_id?: SubscriptionsUuid
  plan_id?: SubscriptionsUuid
  pricing_option_id?: SubscriptionsUuid
  currency: CurrencyIdentifier
  payment_authority?: PaymentAuthority
  manual_payments: ManualPayments
  name: string
  email: string
  /**
   * Whether a subscription is pending activation or not. See [Creating a pending subscription](/docs/api/subscriptions/subscriptions#creating-a-pending-subscription).
   */
  pending?: boolean
  /**
   * Indicates that payment for the first billing period of the subscription has already been taken. As well as creating the subscription a settled invoice is created to cover the first period.
   */
  first_invoice_paid?: boolean
  /**
   * When importing an active subscription from an existing system you can specify the date and time of the start of the most recent period. This may only be supplied when `first_invoice_paid` is true. As well as creating the subscription a settled invoice is created to cover the correct billing period.
   */
  started_at?: string
  offering?: OfferingAttributes
  /**
   * Either references of existing features (id or external_ref) to be attached to the offering or feature information to be created directly within the offering
   */
  features?: Array<ExternalRef | FeatureAttributes | SubscriptionsUuid>
  plans?: Array<PlanAttributesAndSelectedMeta>
  pricing_options?: Array<PricingOptionAttributesAndSelectedMeta>
  configured_features?: OfferingBuildConfiguredFeatures
  pricing_option_associations?: OfferingBuildPricingOptionAssociations
  selected_plan?: ExternalRef
  selected_pricing_option?: ExternalRef
  order?: BuildSubscriptionOrder
  meta?: SubscriptionMeta
}

export type PricingOptionAttributesAndSelectedMeta = PricingOptionAttributes &
  SelectedMeta

export type PlanAttributesAndSelectedMeta = PlanAttributes & SelectedMeta

export type SelectedMeta = {
  meta?: SelectedMetaAttributes
}

export type SelectedMetaAttributes = {
  /**
   * One item must be selected for use in the subscription
   */
  selected?: boolean
}

export type Subscription = {
  id?: SubscriptionsUuid
  type: SubscriptionType
  attributes: SubscriptionAttributes
  relationships?: Relationships
  meta: SubscriptionMeta
}

export type ManageSubscriptionPlans = {
  type: "detach"
  plans: Array<SubscriptionsUuid>
}

export type SubscriptionUpdate = {
  id: SubscriptionsUuid
  type: SubscriptionType
  attributes: SubscriptionUpdateAttributes
}

export type SubscriptionUpdateAttributes = {
  pricing_option_id?: unknown
  plan_id?: unknown
  address_id?: string | null
  payment_authority?: PaymentAuthority
  /**
   * The date and time a `pending` subscription goes live and becomes active. See [Creating a pending subscription](/docs/api/subscriptions/subscriptions#creating-a-pending-subscription).
   */
  go_live_after?: string | null
}

export type SubscriptionIncludes = {
  plans?: Array<OfferingPlan>
  pricing_options?: Array<OfferingPricingOption>
}

export type SubscriptionMeta = {
  owner: OwnerMeta
  timestamps: SubscriptionTimestamps
  status: Status2
  state?: SubscriptionState
  manual_payments: ManualPayments
  /**
   * Indicates that the first billing period of this subscription was paid for outside of the subscriptions service.
   */
  first_invoice_prepaid: boolean
  /**
   * Whether a subscription is canceled or not.
   */
  canceled: boolean
  /**
   * Whether a subscription is paused or not.
   */
  paused: boolean
  /**
   * Whether a subscription is closed or not.
   */
  closed: boolean
  /**
   * Whether a subscription is suspended or not.
   */
  suspended: boolean
  /**
   * Whether a subscription is pending activation or not.
   */
  pending: boolean
  /**
   * The time when the subscription becomes eligible for a new invoice. The next invoice will be generated at the next billing run after this point.
   */
  invoice_after: string
}

export type SubscriptionTimestamps = SubscriptionsTimestamps & {
  /**
   * The date and time a subscription was cancelled.
   */
  canceled_at?: string
  /**
   * The date and time a subscription was paused.
   */
  paused_at?: string
  /**
   * The date and time a subscription was resumed.
   */
  resumed_at?: string
  /**
   * The date and time a subscription will end.
   */
  end_date?: string
  /**
   * The date and time a subscription will go live and become active.
   */
  go_live_after?: string
  /**
   * The date and time a subscription was released from the pending state and made active.
   */
  go_live?: string
}

export type SubscriptionAttributes = {
  external_ref?: ExternalRef
  account_id: SubscriptionsUuid
  address_id?: SubscriptionsUuid
  offering: Offering
  pricing_option_id: SubscriptionsUuid
  plan_id: SubscriptionsUuid
  currency: CurrencyIdentifier
  payment_authority?: PaymentAuthority
}

export type ChangeState = {
  type: SubscriptionStateType
  attributes: SubscriptionStateAttributes
}

export type SubscriptionStateAttributes = {
  action: SubscriptionStateAction
}

/**
 * This represents the type of resource object being returned. Always `subscription_state`.
 */
export type SubscriptionStateType = "subscription_state"

/**
 * The subscription lifecycle is the states that a subscription can go through when a customer subscribes to a service or a plan.
 *
 * A subscription can have the following states; `canceled`, `paused`, or `resumed`.
 *
 * See [**Managing the subscription lifecycle**](/docs/api/subscriptions/subscriptions#managing-the-subscription-lifecycle).
 *
 */
export type SubscriptionStateAction = "cancel" | "pause" | "resume" | "pending"

export type StateMeta = {
  /**
   * The date and time a resource was created.
   */
  created_at: string
}

export type SubscriptionState = {
  id?: SubscriptionsUuid
  type: SubscriptionStateType
  attributes: SubscriptionStateAttributes
  meta: StateMeta
}

/**
 * When configured to true, no payment gateway is used and a pending payment is created. See [External Payments](/docs/api/subscriptions/invoices#external-payments).
 */
export type ManualPayments = boolean

export type PaymentAuthority = (
  | ({
      type?: "elastic_path_payments_stripe"
    } & PaymentAuthorityStripe)
  | ({
      type?: "authorize_net"
    } & PaymentAuthorityAuthorizeNet)
) & {
  /**
   * The name of the payment gateway facilitating the secure transmission of payment data.
   */
  type: "authorize_net" | "elastic_path_payments_stripe"
}

export type NullablePaymentAuthority = (
  | ({
      type?: "elastic_path_payments_stripe"
    } & PaymentAuthorityStripe)
  | ({
      type?: "authorize_net"
    } & PaymentAuthorityAuthorizeNet)
  | null
) & {
  /**
   * The name of the payment gateway facilitating the secure transmission of payment data.
   */
  type: "authorize_net" | "elastic_path_payments_stripe"
}

export type PaymentAuthorityAuthorizeNet = {
  /**
   * The name of the payment gateway facilitating the secure transmission of payment data.
   */
  type: "authorize_net"
  /**
   * The customer's payment profile id, unique to Authorize.net, used to facilitate payment of the subscription.
   */
  payment_profile_id?: string
  /**
   * The customer's profile id, unique to Authorize.net, used to facilitate payment of the subscription.
   */
  customer_profile_id?: string
}

export type PaymentAuthorityStripe = {
  /**
   * The name of the payment gateway facilitating the secure transmission of payment data.
   */
  type: "elastic_path_payments_stripe"
  /**
   * The unique identifier for a customer.
   */
  customer_id?: string
  /**
   * The unique identifier of the card used to facilitate payment of the subscription. If a card payment fails, you can use the `card_id` and `customer_id` attributes to program your front-end implementation to allow your preferred payment service provider to update a subscription with new card details. See [Card declines](/docs/api/subscriptions/invoices#card-declines).
   */
  card_id?: string
}

export type Import = {
  id?: SubscriptionsUuid
  type: SubscriptionImportType
  attributes: ImportAttributes
  meta: ImportMeta
}

export type ImportAttributes = {
  external_ref?: ExternalRef
  /**
   * The status of job.
   * - **pending** - Commerce has received the request but is currently busy processing other requests.
   * - **started** - Commerce has started processing the job.
   * - **success** - The job has successfully completed.
   * - **failed** - The job has failed.
   *
   */
  status: "pending" | "started" | "success" | "failed"
}

export type ImportMeta = {
  owner: OwnerMeta
  timestamps: JobTimestamps
  records: ImportRecords
}

/**
 * You can track the number of records imported to ensure the completeness, accuracy and integrity of the import. Uploaded shows the number of records ready to be imported into Subscriptions. However, this does not mean they are valid subscription objects, only that they have the correct type and their JSON format is properly formatted. Imported shows the number of records that have been both validated and successfully added to Subscriptions.
 */
export type ImportRecords = {
  uploaded: {
    /**
     * The total number of features uploaded.
     */
    subscription_feature: number
    /**
     * The total number of subscribers uploaded.
     */
    subscription_subscriber: number
    /**
     * The total number of offerings uploaded.
     */
    subscription_offering: number
    /**
     * The total number of subscriptions uploaded.
     */
    subscription: number
  }
  imported: {
    /**
     * The total number of features uploaded.
     */
    subscription_feature: number
    /**
     * The total number of subscribers imported.
     */
    subscription_subscriber: number
    /**
     * The total number of offerings imported.
     */
    subscription_offering: number
    /**
     * The total number of subscriptions imported.
     */
    subscription: number
  }
}

export type Job = {
  id?: SubscriptionsUuid
  type: SubscriptionJobType
  attributes: JobResponseAttributes
  relationships?: Relationships
  meta: JobMeta
}

export type JobMeta = {
  owner: OwnerMeta
  timestamps: JobTimestamps
  report?: JobReport
}

/**
 * You can track your Subscriptions billing, tax, and payment operations using reports.
 */
export type JobReport = BillingRunReport | TaxRunReport | PaymentRunReport

export type BillingRunReport = {
  /**
   * The total number of invoices created that are ready for payment.
   */
  invoices_ready_for_payment: number
  /**
   * The total number of invoices created that need taxes to be applied before payment can be made.
   */
  invoices_tax_required: number
  /**
   * The total number of invoices that were scheduled but creation failed.
   */
  invoice_failures: number
  total_ready_for_payment: unknown & Price
  total_tax_required: unknown & Price
}

export type TaxRunReport = {
  /**
   * The total number of invoices to which tax was successfully added.
   */
  invoices_updated: number
  /**
   * The total number of invoices to which tax could not be added.
   */
  invoice_failures: number
}

export type PaymentRunReport = {
  /**
   * The total number of invoices for which payment was attempted.
   */
  total_payment_attempts: number
  /**
   * The number of failed payment attempts.
   */
  failed_payments: number
  total_collected: unknown & Price
}

export type JobTimestamps = SubscriptionsTimestamps & {
  /**
   * The date and time a job is started.
   */
  started_at?: string
  /**
   * The date and time a job finished.
   */
  finished_at?: string
}

export type JobCreate = {
  type: SubscriptionJobType
  attributes: JobCreateAttributes
}

export type JobResponseAttributes = JobCreateAttributes &
  JobAttributes &
  SubscriptionsTimestamps

/**
 * The type of job. One of the following:
 * - `billing_run` - a billing run job.
 * - `payment_run` - a payment run job.
 * - `tax_run` - a tax run job.
 *
 */
export type JobType = "billing-run" | "tax-run" | "payment-run" | "import"

export type JobCreateAttributes = {
  external_ref?: ExternalRef
  job_type: JobType
  taxes?: Array<InvoiceTaxItems>
}

export type JobAttributes = {
  external_ref?: ExternalRef
  /**
   * The status of job.
   */
  status: "pending" | "started" | "success" | "failed"
}

export type InvoiceTaxItems = {
  invoice_id: SubscriptionsUuid
  tax_items: Array<TaxItem>
}

export type TaxItem = {
  /**
   * This represents the type of resource object being returned. Always `tax_item`.
   */
  type: "tax_item"
  /**
   * The name that appears on your customer's invoice and usually describes the specific type of tax, for example, `Sales`, `VAT` or `GST`.
   */
  name?: string
  /**
   * The unique identifier assigned to goods and services for taxation purposes.
   */
  code?: string
  /**
   * The tax rate is the percentage of the subscription amount that is required to be paid as tax.
   */
  rate: number
  /**
   * The geographic area or political entity that has authority to levy and collect taxes.
   */
  jurisdiction?: string
}

export type SubscriptionInvoice = {
  id?: SubscriptionsUuid
  type: SubscriptionInvoiceType
  attributes: SubscriptionInvoiceAttributes
  relationships?: Relationships
  meta: SubscriptionInvoiceMeta
}

export type UpdateInvoicePayment = {
  id: SubscriptionsUuid
  type: SubscriptionInvoicePaymentType
  attributes: UpdateInvoicePaymentAttributes
}

export type UpdateInvoicePaymentAttributes = {
  /**
   * Whether the payment was successful.
   */
  success: boolean
  /**
   * An optional external ID that is specific to the gateway used.
   */
  external_payment_id?: string
  /**
   * A message generated by an external payment method that describes why a payment fails.
   */
  failure_detail?: string
  /**
   * The date and time the invoice payment was taken at.
   */
  payment_taken_at?: string
}

export type SubscriptionInvoicePayment = {
  id: SubscriptionsUuid
  type: SubscriptionInvoicePaymentType
  attributes: SubscriptionInvoicePaymentAttributes
  meta: SubscriptionInvoicePaymentMeta
}

export type SubscriptionInvoiceMeta = {
  owner: OwnerMeta
  subscription_id?: SubscriptionsUuid
  subscriber_id?: SubscriptionsUuid
  price?: SingleCurrencyPrice
  timestamps: InvoiceTimestamps
  proration_events: Array<ProrationEvent>
}

export type ProrationEvent = {
  proration_policy_id: SubscriptionsUuid
  /**
   * The value as a whole number of the currency's smallest subdivision
   */
  billing_cost_before_proration: BigInt
  /**
   * The value as a whole number of the currency's smallest subdivision.
   */
  refunded_amount_for_unused_pricing_option: BigInt
  /**
   * The value as a whole number of the currency's smallest subdivision.
   */
  new_pricing_option_cost: BigInt
  /**
   * The date and time the subscription was prorated.
   */
  prorated_at: string
}

export type InvoiceTimestamps = SubscriptionsTimestamps & {
  /**
   * The date and time taxes were added to an invoice.
   */
  taxes_added_at?: string
}

export type SubscriptionInvoicePaymentMeta = {
  owner: OwnerMeta
  subscription_id: SubscriptionsUuid
  invoice_id: SubscriptionsUuid
  job_id: SubscriptionsUuid
  timestamps: InvoicePaymentTimestamps
  /**
   * Whether manual payments are enabled or the payment will be handled by the configured gateway.
   */
  manual_payment: boolean
}

export type InvoicePaymentTimestamps = SubscriptionsTimestamps & {
  /**
   * The date and time a payment was taken.
   */
  payment_taken_at?: string
}

export type SubscriptionInvoiceAttributes = {
  billing_period: TimePeriod
  invoice_items: Array<SubscriptionInvoiceItem>
  tax_items?: Array<TaxItem>
  /**
   * The invoice still requires payment if `true`.
   */
  outstanding: boolean
  /**
   * A sequential number assigned by the billing run.
   */
  number?: number
  /**
   * Whether tax is required for this invoice.
   */
  tax_required: boolean
  /**
   * Whether the limit of payment retries has been reached.
   */
  payment_retries_limit_reached: boolean
  /**
   * The date and time an invoice was updated.
   */
  updated_at?: string
  /**
   * The date and time an invoice was created.
   */
  created_at?: string
  /**
   * Whether there is a manual pending payment pending on the invoice.
   */
  manual_payment_pending: boolean
}

export type SubscriptionInvoicePaymentAttributes = {
  /**
   * Whether the payment was successful.
   */
  success: boolean
  /**
   * Whether the payment is pending (only for manual payments).
   */
  pending?: boolean
  /**
   * Specifies the payment gateway.
   */
  gateway: string
  /**
   * An optional external ID that is specific to the gateway used.
   */
  external_payment_id?: string
  failure_detail?: PaymentFailureDetail
  amount: SingleCurrencyPrice
}

/**
 * The reason the payment failed.
 */
export type PaymentFailureDetail = {
  reason?: string
}

export type SubscriptionInvoiceItem = {
  /**
   * A description of the subscribed item.
   */
  description: string
  price: SingleCurrencyPrice
  plan_id?: SubscriptionsUuid
  /**
   * The start date and time of the billing period in this price
   */
  from_time_period?: string
  /**
   * The end date and time of the billing period in this price
   */
  until_time_period?: string
}

/**
 * The three-letter [**ISO currency code**](https://www.iso.org/iso-4217-currency-codes.html) in uppercase.
 */
export type CurrencyIdentifier = string

/**
 * The owner of a resource, either `store` or `organization`.
 */
export type OwnerMeta = string

/**
 * The offerings plan external_ref value
 */
export type OfferingPlanExternalRefMeta = string

export type Subscriber = {
  id?: SubscriptionsUuid
  type: SubscriptionSubscriberType
  attributes: SubscriberResponseAttributes
  meta: SubscriberMeta
}

export type SubscriberMeta = {
  /**
   * A list of entitlement tags currently active for the subscriber
   */
  feature_entitlements?: Array<FeatureTag>
  owner: OwnerMeta
  timestamps: SubscriptionsTimestamps
}

export type SubscriptionSubscriberType = "subscription_subscriber"

export type SubscriberResponseAttributes = SubscriberAttributes &
  SubscriptionsTimestamps

export type SubscriberAttributes = {
  account_id: SubscriptionsUuid
  /**
   * The name of the subscriber.
   */
  name: string
  /**
   * The email of the subscriber.
   */
  email: string
  payment_authority?: PaymentAuthority
}

export type SubscriberUpdateAttributes = {
  /**
   * The name of the subscriber.
   */
  name?: string
  /**
   * The email of the subscriber.
   */
  email?: string
  payment_authority?: NullablePaymentAuthority
}

export type SubscriberCreate = {
  type: SubscriptionSubscriberType
  attributes: SubscriberAttributes
}

export type SubscriberUpdate = {
  id: SubscriptionsUuid
  type: SubscriptionSubscriberType
  attributes: SubscriberUpdateAttributes
}

export type ScheduleCreate = {
  type: SubscriptionScheduleType
  attributes: ScheduleAttributes
}

export type Schedule2 = {
  id?: SubscriptionsUuid
  type: SubscriptionScheduleType
  attributes: ScheduleResponseAttributes
  meta: ScheduleMeta
}

export type ScheduleMeta = {
  scheduled_for?: Date
  owner: OwnerMeta
  timestamps: SubscriptionsTimestamps
}

export type SubscriptionScheduleType = "subscription_schedule"

export type ScheduleResponseAttributes = ScheduleAttributes &
  SubscriptionsTimestamps

export type ScheduleAttributes = {
  external_ref?: ExternalRef
  /**
   * The name of the schedule.
   */
  name?: string
  /**
   * A cron-style specification of when the jobs should be created. See [**Schedules**](/docs/api/subscriptions/schedules).
   */
  specification: string
  /**
   * The location of the time zone that the schedule operates in. Subscriptions runs on Coordinated Universal Time (UTC) time and conforms to [**RFC 3339**](https://www.rfc-editor.org/rfc/rfc3339).
   */
  location: string
  job: ScheduleJob
}

export type ScheduleUpdateAttributes = {
  external_ref?: ExternalRefUpdate
  /**
   * The name of the schedule.
   */
  name?: string | null
  /**
   * A cron-style specification of when the jobs should be created.
   */
  specification?: string
  /**
   * The location of the time zone that the schedule operates in.
   */
  location?: string
  job?: ScheduleJob
}

export type ScheduleJob = {
  job_type: JobType
}

export type ScheduleUpdate = {
  id: SubscriptionsUuid
  type: SubscriptionScheduleType
  attributes: ScheduleUpdateAttributes
}

export type SubscriptionsTimestamps = {
  /**
   * The date and time a resource was updated.
   */
  updated_at: string
  /**
   * The date and time a resource was created.
   */
  created_at: string
}

/**
 * The subscription resource that is related.
 */
export type SubscriptionsSingleRelationship = {
  data?: RelationshipData
  links?: RelationshipLinks
}

export type SubscriptionsErrorResponse = {
  errors: Array<SubscriptionsError>
}

export type SubscriptionsError = {
  /**
   * The HTTP response code of the error.
   */
  status: string
  /**
   * A brief summary of the error.
   */
  title: string
  /**
   * Optional additional detail about the error.
   */
  detail?: string
  /**
   * Additional supporting meta data for the error.
   */
  meta?: {
    [key: string]: unknown
  }
}

/**
 * The unique identifier.
 */
export type SubscriptionsUuid = string

export type StockType = "stock"

export type StockTransactionType = "stock-transaction"

export type MultipleProducts = {
  type?: "stock"
  /**
   * The unique identifier of the product.
   */
  id: string
}

export type TransactionResponseAttributes = {
  /**
   * The type of action performed by this transaction.
   *
   * - **increment** - use this when you want to make products available for purchase, for example, when you have received stock from a supplier.
   *
   * - **decrement** - Use this when you want to remove stock from product inventory.
   *
   * - **allocate** - Use this when you want to allocate stock, normally to a reseller who sells on the stock.
   *
   * - **deallocate** - Use this when you want to deallocate any previously allocated stock.
   *
   */
  action: "increment" | "decrement" | "allocate" | "deallocate"
  product_id: InventoriesUuid
  /**
   * The amount of stock affected by the stock transaction.
   */
  quantity: BigInt
  /**
   * The slug of the location that the transaction should act on.
   */
  location?: string
}

export type StockCreate = {
  id?: InventoriesUuid
  type: StockType
  attributes: StockCreateAttributes
}

export type StockUpdateRequest = {
  id: InventoriesUuid
  type: StockType
  attributes: StockUpdateAttributes
}

export type StockUpdateAttributes = {
  locations?: NullableLocations
}

export type NullableLocation = {
  available: BigInt
} | null

export type NullableLocations = {
  [key: string]: NullableLocation
}

export type StockCreateAttributes = {
  available?: BigInt
  locations?: {
    [key: string]: {
      available: BigInt
    }
  }
}

export type StockResponse = {
  id: InventoriesUuid
  type: StockType
  attributes: StockResponseAttributes
  meta: StockMeta
}

export type StockResponseAttributes = {
  available: BigInt
  allocated: BigInt
  total: BigInt
  locations?: StockLocations
}

export type StockLocations = {
  [key: string]: {
    available: BigInt
    allocated: BigInt
    total: BigInt
  }
}

export type TransactionCreate = {
  type: StockTransactionType
  attributes: TransactionCreateAttributes
}

export type TransactionCreateAttributes = {
  product_id?: InventoriesUuid
  /**
   * The type of action being performed by this transaction.
   *
   * - **increment** - use this when you want to make products available for purchase, for example, when you have received stock from a supplier.
   *
   * - **decrement** - Use this when you want to remove stock from product inventory.
   *
   * - **allocate** - Use this when you want to allocate stock, normally to a reseller who sells on the stock.
   *
   * - **deallocate** - Use this when you want to deallocate any previously allocated stock.
   *
   * - **set** - Use this when you want to set total stock to a specific value.
   *
   */
  action: "increment" | "decrement" | "allocate" | "deallocate" | "set"
  /**
   * The amount of stock affected by the stock transaction.
   */
  quantity: BigInt
  /**
   * The slug of the location that the transaction should act on.
   */
  location?: string
}

export type Location = {
  id: InventoriesUuid
  type: InventoryLocationType
  attributes: LocationAttributes
  meta?: Meta
}

export type LocationAttributes = {
  name: string
  external_ref?: string
  slug: string
  description?: string
  address?: Array<string>
  geolocation?: GeolocationDetails
}

export type LocationUpdateAttributes = {
  name?: string
  external_ref?: string | null
  slug?: string
  description?: string | null
  address?: Array<string | null> | null
  geolocation?: GeolocationDetails
}

/**
 * The longitude and latitude of a location.
 */
export type GeolocationDetails = {
  lat: number
  lon: number
} | null

export type LocationRequest = {
  type?: InventoryLocationType
  attributes: LocationAttributes
}

export type LocationUpdateRequest = {
  id: InventoriesUuid
  type: InventoryLocationType
  attributes: LocationUpdateAttributes
}

export type InventoryLocationType = "inventory_location"

export type StockMeta = {
  stock_id: InventoriesUuid
  timestamps: InventoriesTimestamps
}

export type Meta = {
  timestamps: InventoriesTimestamps
}

export type InventoriesTransactionResponse = {
  id: InventoriesUuid
  type: StockTransactionType
  attributes: TransactionResponseAttributes
  meta?: Meta
}

/**
 * The unique identifier.
 */
export type InventoriesUuid = string

export type InventoriesTimestamps = {
  /**
   * The date and time a resource was updated.
   */
  updated_at?: string
  /**
   * The date and time a resource was created.
   */
  created_at: string
}

export type InventoriesErrorResponse = {
  errors: Array<InventoriesError>
}

export type InventoriesError = {
  /**
   * The HTTP response code of the error.
   */
  status: string
  /**
   * A brief summary of the error.
   */
  title: string
  /**
   * Optional additional detail about the error.
   */
  detail?: string
  /**
   * Additional supporting meta data for the error.
   */
  meta?: {
    [key: string]: unknown
  }
}

export type AccessTokenRequest = {
  /**
   * The grant type, choices are `client_credentials` or `implicit`
   */
  grant_type: string
  /**
   * Your `client_id`
   */
  client_id: string
  /**
   * Your `client_secret`. Only required for client credentials.
   */
  client_secret?: string
}

export type AccessTokenResponse = {
  /**
   * The access token you use to authenticate requests to the API.
   */
  access_token?: string
  /**
   * Right now this is only `Bearer`.
   */
  token_type?: string
  /**
   * The type of token requested. This can be a `client_credentials` or `implicit`.
   */
  identifier?: string
  /**
   * The duration in seconds after which the token expires.
   */
  expires_in?: number
  /**
   * The epoch time that this token expires at.
   */
  expires?: number
}

export type ErrorResponse2 = {
  errors: Array<Error2>
}

export type Error2 = {
  /**
   * A brief summary of the error.
   */
  title: string
  /**
   * The HTTP response code of the error.
   */
  status: string
  /**
   * Optional additional detail about the error.
   */
  detail?: string
}

export type Address = {
  /**
   * Specifies the the type of object. Set this value to `address`.
   */
  type?: string
  /**
   * The first name of the recipient on this address.
   */
  first_name?: string
  /**
   * The last name of the recipient on this address.
   */
  last_name?: string
  /**
   * The name for the address saved, such as `home`, `work` or `wifes office`.
   */
  name?: string
  /**
   * A phone number for this address.
   */
  phone_number?: string
  /**
   * Any delivery instructions for this address.
   */
  instructions?: string
  /**
   * The company name at this address.
   */
  company_name?: string
  /**
   * The first portion of the address, usually the street address.
   */
  line_1?: string
  /**
   * The second portion of the address, usually an apartment or unit number.
   */
  line_2?: string
  /**
   * The city for this address.
   */
  city?: string
  /**
   * The county for this address.
   */
  county?: string
  /**
   * The state, province, territory, etc. for this address.
   */
  region?: string
  /**
   * The ZIP Code, Postcode, or other postal reference string for this delivery address.
   */
  postcode?: string
  /**
   * A two digit code for the country this address is in, expressed as per the ISO 3166-2 standard.
   */
  country?: string
}

export type AddressResponse = Address & {
  /**
   * The unique identifier for an Address.
   */
  id?: string
  meta?: AccountAddressesMetaTimestamps
  links?: {
    /**
     * A URL to the specific resource.
     */
    self?: string
  }
}

export type AccountAddressResponse = AddressResponse & {
  relationships?: {
    account?: {
      /**
       * The ID of the account.
       */
      id?: string
      /**
       * The type of object being returned.
       */
      type?: string
    }
  }
}

/**
 * Bad Request
 */
export type ErrorBadRequest = unknown

/**
 * Not Found
 */
export type ErrorNotFound = unknown

export type AccountAddressesMetaTimestamps = {
  timestamps?: {
    /**
     * The date the address is created.
     */
    created_at?: string
    /**
     * The date the address is updated.
     */
    updated_at?: string
  }
}

export type AccountAddressesError = {
  /**
   * The HTTP response code of the error.
   */
  status?: string
  /**
   * A brief summary of the error.
   */
  title?: string
  /**
   * Optional additional detail about the error.
   */
  detail?: string
}

export type AccountAddressesErrorResponse = {
  errors: Array<AccountAddressesError>
}

/**
 * The unique identifier.
 */
export type Uuid = string

export type MetaListPage = {
  /**
   * The maximum number of records per page for this response. You can set this value up to 100.
   */
  limit?: number
  /**
   * The current page.
   */
  current?: number
  /**
   * The current offset by number of records, not pages. Offset is zero-based.
   */
  offset?: number
  /**
   * The total page count.
   */
  total?: number
}

export type MetaListResults = {
  /**
   * The total number of results after applying filters, if any, or all results.
   */
  total?: number
}

/**
 * The unique identifier for the Account Member that authenticated. This is useful if `account_member_self_management` is enabled in [Account Authentication Settings](/docs/api/accounts/get-v-2-settings-account-authentication), so that the user can update details for their account.
 */
export type MetaAccountMemberId = string

export type MetaList = {
  page?: MetaListPage
  results?: MetaListResults
}

export type Account = {
  /**
   * Specifies the the type of object. Set this value to `account`.
   */
  type: string
  /**
   * Specifies the name of the account.
   */
  name: string
  /**
   * Specifies the legal name of the account.
   */
  legal_name?: string | null
  /**
   * Specifies the registration ID. If specified, this field is checked for uniqueness.
   */
  registration_id?: string | null
  /**
   * The unique attribute associated with the account. For example, this could be an external reference from a separate company system. The maximum length is 2048 characters. Default is `null`.
   */
  external_ref?: string
}

export type ReadOnlyParentId = {
  /**
   * Specifies the ID of the parent account.
   */
  readonly parent_id?: string | null
}

export type WritableParentId = {
  /**
   * Specifies the ID of the parent account, this field cannot be changed after creation.
   */
  parent_id?: string | null
}

export type AccountResponse = Account &
  ReadOnlyParentId & {
    /**
     * The unique identifier for an Account.
     */
    id?: Uuid
    /**
     * Additional information for this realm. For more information, see [The meta object](https://elasticpath.dev/docs/commerce-cloud/accounts/using-account-management-api/account-management-api-overview#the-meta-object) section.
     */
    meta?: AccountManagementMetaTimestamps
    links?: {
      /**
       * A URL to the specific resource.
       */
      self?: string
    }
  }

/**
 * Whether a user with an [Account Management Authentication Token](/docs/api/accounts/post-v-2-account-members-tokens) can update their own account member details. By default, this is `disabled`. Set to `update_only` if you want the user to be able to update their own account member details (e.g., name, email, and if applicable their username and password). The user can update their own account member details by updating their [User Authentication Info](/docs/authentication/single-sign-on/user-authentication-info-api/update-a-user-authentication-info) using the `account_member_id` retrieved from the `meta` in the response of [Generating an Account Management Authentication Token](/docs/api/accounts/post-v-2-account-members-tokens) as the `id` and find the authentication credentials to update by calling the [Get All User Authentication Password Profile Info](/docs/authentication/single-sign-on/user-authentication-password-profiles-api/get-all-user-authentication-password-profile-info) endpoint.
 */
export type AccountMemberSelfManagement = "disabled" | "update_only"

export type AccountAuthenticationSettings = {
  /**
   * Specifies the the type of object. Set this value to `account_authentication_settings`.
   */
  type?: string
  /**
   * Set to `true` to enable self signup.
   */
  enable_self_signup?: boolean
  /**
   * This will automatically create an account for each new account member, using the account members name as the account name.
   */
  auto_create_account_for_account_members?: boolean
  /**
   * Whether a user with an [Account Management Authentication Token](/docs/api/accounts/post-v-2-account-members-tokens) can update their own account member details. By default, this is `disabled`. Set to `update_only` if you want the user to be able to update their own account member details (e.g., name, email, and if applicable their username and password). The user can update their own account member details by updating their [User Authentication Info](/docs/authentication/single-sign-on/user-authentication-info-api/update-a-user-authentication-info) using the `account_member_id` retrieved from the `meta` in the response of [Generating an Account Management Authentication Token](/docs/api/accounts/post-v-2-account-members-tokens) as the `id` and find the authentication credentials to update by calling the [Get All User Authentication Password Profile Info](/docs/authentication/single-sign-on/user-authentication-password-profiles-api/get-all-user-authentication-password-profile-info) endpoint.
   */
  account_member_self_management?: "disabled" | "update_only"
  /**
   * The expiry time for Account Management Authentication Token in seconds. If you want to implement idle timout for you application, see [Implementing Idle Timeout](/guides/How-To/Accounts/implement-idle-timeout)
   */
  account_management_authentication_token_timeout_secs?: number
}

export type AccountAuthenticationSettingsResponse =
  AccountAuthenticationSettings & {
    id?: Uuid
    relationships?: {
      authentication_realm?: {
        data?: {
          /**
           * The ID of the authentication realm entity.
           */
          id?: string
          /**
           * The type of the authentication realm entity.
           */
          type?: string
          links?: {
            /**
             * A URL to the specific resource.
             */
            self?: string
          }
        }
      }
    }
    meta?: {
      /**
       * The client ID to be used in Single Sign On authentication flows for accounts.
       */
      client_id?: string
    }
    links?: {
      /**
       * A URL to the specific resource.
       */
      self?: string
    }
  }

export type AccountMembershipSettings = {
  data?: {
    /**
     * Specifies the the type of object. Set this value to `account_membership_setting`.
     */
    type?: "account_membership_setting"
    /**
     * The number of accounts an account member can be associated with. You can set this value to any number up to 10,000.
     */
    membership_limit?: number
  }
}

export type AccountMember = {
  /**
   * The unique identifier for the account member.
   */
  id?: string
  /**
   * The type of the object that is returned.
   */
  type?: string
  /**
   * The name of the account member.
   */
  name?: string
  /**
   * The email address of the account member.
   */
  email?: string
}

export type AccountMemberResponse = AccountMember & {
  meta?: AccountManagementMetaTimestamps
  links?: {
    /**
     * A URL to the specific resource.
     */
    self?: string
  }
}

export type AccountMembership = {
  /**
   * Specifies the unique identifier of the account member that the membership is associated with.
   */
  account_member_id?: string
  /**
   * Specifies the type of the object. Set this value to `account_membership`.
   */
  type?: string
}

export type AccountMembershipResponse = {
  /**
   * Represents the unique identifier for the account membership.
   */
  id?: string
  /**
   * Represents the type of the object returned.
   */
  type?: string
  meta?: AccountManagementMetaTimestamps
  relationships?: {
    account_member?: {
      data?: {
        /**
         * Specifies the ID of the account member.
         */
        id?: string
        /**
         * Specifies the type of the account member.
         */
        type?: string
      }
    }
  }
  links?: {
    /**
     * A URL to the specific resource.
     */
    self?: string
  }
}

export type AccountMembershipResponseUsingAccountMemberId = {
  /**
   * Represents the unique identifier for the account membership.
   */
  id?: string
  /**
   * Represents the type of the object returned.
   */
  type?: string
  meta?: AccountManagementMetaTimestamps
  relationships?: {
    account?: {
      data?: {
        /**
         * Specifies the ID of the account.
         */
        id?: string
        /**
         * Specifies the type of the Account.
         */
        type?: string
      }
    }
  }
  links?: {
    /**
     * A URL to the specific resource.
     */
    self?: string
  }
}

export type AccountManagementAuthenticationToken = {
  /**
   * Specifies the type of the object. You must use `account_management_authentication_token`.
   */
  type?: string
}

export type OpenIdConnectRequest = AccountManagementAuthenticationToken & {
  /**
   * Species the authentication mechanism. You must use `oidc`.
   */
  authentication_mechanism: string
  /**
   * Specifies the code returned from the OpenID Connect Provider authentication.
   */
  oauth_authorization_code: string
  /**
   * Specifies the URL of the front-end that handles the callback of the token.
   */
  oauth_redirect_uri: string
  /**
   * Specifies the Proof Key for Code Exchange (PKCE) code verifier corresponding to the code challenge supplied to the authorization endpoint. For more information about code verifier and challenge, see Generating a [Code Verifier and Challenge](https://elasticpath.dev/docs/commerce-cloud/authentication/single-sign-on/get-single-sign-on-customer-token#generate-proof-key-for-code-exchange-pkce-parameters).
   */
  oauth_code_verifier: string
}

export type PasswordRequest = AccountManagementAuthenticationToken & {
  /**
   * Species the authentication mechanism. You must use `password`.
   */
  authentication_mechanism: string
  /**
   * The password profile ID. For more information, see [password profiles page](https://elasticpath.dev/docs/commerce-cloud/authentication/single-sign-on/password-profiles-api/overview).
   */
  password_profile_id: string
  /**
   * The username.
   */
  username: string
  /**
   * The password.
   */
  password: string
}

export type SelfSignupRequest = AccountManagementAuthenticationToken & {
  /**
   * Species the authentication mechanism. You must use `self_signup`.
   */
  authentication_mechanism: string
  /**
   * The password profile ID. For more information, see [password profiles page](https://elasticpath.dev/docs/commerce-cloud/authentication/single-sign-on/password-profiles-api/overview).
   */
  password_profile_id: string
  /**
   * The username.
   */
  username: string
  /**
   * The password.
   */
  password: string
  /**
   * The name.
   */
  name: string
  /**
   * The email.
   */
  email: string
}

export type PasswordlessRequest = AccountManagementAuthenticationToken & {
  /**
   * Species the authentication mechanism. You must use `passwordless`.
   */
  authentication_mechanism: string
  /**
   * The password profile ID. For more information, see [password profiles page](https://elasticpath.dev/docs/commerce-cloud/authentication/single-sign-on/password-profiles-api/overview).
   */
  password_profile_id: string
  /**
   * The username.
   */
  username: string
  /**
   * The one-time password token.
   */
  one_time_password_token: string
}

export type SwitchingAccountRequest = AccountManagementAuthenticationToken & {
  /**
   * Species the authentication mechanism. You must use `account_management_authentication_token`.
   */
  authentication_mechanism: string
}

export type AccountManagementAuthenticationTokenResponse = {
  /**
   * Specifies the type of the object.
   */
  type?: string
  /**
   * The name of the account that this token grants access to.
   */
  account_name?: string
  /**
   * The ID of the account that this token grants access to.
   */
  account_id?: string
  /**
   * The JWT authentication token that the shopper uses as the `EP-Account-Management-Authentication-Token` header [in all other endpoints](https://elasticpath.dev/docs/commerce-cloud/authentication/tokens/account-management-authentication-token).
   */
  token?: string
  /**
   * The epoch time that this token expires at. The time is set to 24 hours after the token is generated.
   */
  expires?: Date
}

export type AccountManagementMetaTimestamps = {
  timestamps?: {
    /**
     * The date the account is created.
     */
    created_at?: string
    /**
     * The date the account is updated.
     */
    updated_at?: string
  }
}

export type AccountManagementError = {
  /**
   * A brief summary of the error.
   */
  title: string
  /**
   * The HTTP response code of the error.
   */
  status: string
  /**
   * Optional additional detail about the error.
   */
  detail?: string
}

export type AccountManagementErrorResponse = {
  errors: Array<AccountManagementError>
}

export type AuthenticationRealm = {
  id: string
  name: string
  type: "authentication_realm"
  meta: {
    created_at?: Date
    updated_at?: Date
  }
}

export type AuthenticationRealmResponse = {
  data: AuthenticationRealm
  links?: {
    self?: string
  }
}

export type AuthenticationRealmListResponse = {
  data: Array<AuthenticationRealm>
  links?: {
    self?: string
  }
}

export type AuthenticationRealmUpdateRequest = {
  data: {
    name: string
  }
}

export type OidcProfile = {
  id: string
  type: "openid_connect_profile"
  client_id: string
  client_secret?: string
  redirect_uris: Array<string>
  meta: {
    created_at?: Date
    updated_at?: Date
  }
}

export type OidcProfileResponse = {
  data: OidcProfile
  links?: {
    self?: string
  }
}

export type OidcProfileListResponse = {
  data: Array<OidcProfile>
  links?: {
    self?: string
  }
}

export type OidcProfileCreateRequestWrapper = {
  data: {
    type: "openid_connect_profile"
    client_id: string
    client_secret?: string
    redirect_uris: Array<string>
  }
}

export type OidcProfileUpdateRequestWrapper = {
  data: {
    id: string
    type: "openid_connect_profile"
    client_id: string
    client_secret?: string
    redirect_uris: Array<string>
  }
}

export type PasswordProfile = {
  id: string
  type: "password_profile"
  name: string
  description?: string
  meta: {
    created_at?: Date
    updated_at?: Date
  }
}

export type PasswordProfileResponse = {
  data: PasswordProfile
  links?: {
    self?: string
  }
}

export type PasswordProfileListResponse = {
  data: Array<PasswordProfile>
  links?: {
    self?: string
  }
}

export type PasswordProfileCreateRequestWrapper = {
  data: {
    type: "password_profile"
    name: string
    description?: string
  }
}

export type PasswordProfileUpdateRequestWrapper = {
  data: {
    id: string
    type: "password_profile"
    name: string
    description?: string
  }
}

export type Purpose = "reset_password" | "passwordless_authentication"

export type OneTimePasswordTokenRequest = {
  type: "one_time_password_token_request"
  username: string
  purpose: "reset_password" | "passwordless_authentication"
}

export type UserAuthenticationInfo = {
  id: string
  type: "user_authentication_info"
  username: string
  meta: {
    created_at?: Date
    updated_at?: Date
  }
}

export type UserAuthenticationInfoResponse = {
  data: UserAuthenticationInfo
  links?: {
    self?: string
  }
}

export type UserAuthenticationInfoListResponse = {
  data: Array<UserAuthenticationInfo>
  links?: {
    self?: string
  }
}

export type UserAuthenticationInfoCreateRequestWrapper = {
  data: {
    type: "user_authentication_info"
    username: string
  }
}

export type UserAuthenticationInfoUpdateRequestWrapper = {
  data: {
    id: string
    type: "user_authentication_info"
    username: string
  }
}

export type UserAuthenticationOidcProfileInfo = {
  id: string
  type: "user_authentication_oidc_profile_info"
  username: string
  meta: {
    created_at?: Date
    updated_at?: Date
  }
}

export type UserAuthenticationOidcProfileInfoResponse = {
  data: UserAuthenticationOidcProfileInfo
  links?: {
    self?: string
  }
}

export type UserAuthenticationOidcProfileInfoListResponse = {
  data: Array<UserAuthenticationOidcProfileInfo>
  links?: {
    self?: string
  }
}

export type UserAuthenticationOidcProfileInfoCreateRequestWrapper = {
  data: {
    type: "user_authentication_oidc_profile_info"
    username: string
  }
}

export type UserAuthenticationOidcProfileInfoUpdateRequestWrapper = {
  data: {
    id: string
    type: "user_authentication_oidc_profile_info"
    username: string
  }
}

export type PasswordProfileInfo = {
  /**
   * Unique identifier of the password profile info.
   */
  id: string
  username: string
  /**
   * Timestamps for creation and last update.
   */
  meta: {
    created_at?: Date
    updated_at?: Date
  }
  type: "user_authentication_password_profile_info"
  /**
   * Identifier for the associated password profile.
   */
  password_profile_id: string
}

export type PasswordProfileInfoResponse = {
  data: PasswordProfileInfo
  links?: {
    self?: string
  }
}

export type PasswordProfileInfoListResponse = {
  data: Array<PasswordProfileInfo>
  links?: {
    self?: string
  }
}

export type PasswordProfileInfoCreateRequestWrapper = {
  data: PasswordProfileInfoCreateRequest
}

export type PasswordProfileInfoCreateRequest = {
  type: "user_authentication_password_profile_info"
  username: string
  password: string
  password_profile_id: string
}

export type PasswordProfileInfoUpdateRequestWrapper = {
  data: PasswordProfileInfoUpdateRequest
}

export type PasswordProfileInfoUpdateRequest = {
  id: string
  type: "user_authentication_password_profile_info"
  username: string
  password: string
}

export type DataCreateCurrencies = {
  /**
   * Specifies the currency code. Example YEN.
   */
  code: string
  /**
   * Indicates how many decimal places the currency is formatted to.
   */
  decimal_places: number
  /**
   * Indicates the decimal point character.
   */
  decimal_point: string
  /**
   * Specifies whether this is the default currency or not. Either `true` or `false`.
   */
  default: boolean
  /**
   * Specifies if this currency is available for products. Either `true` or `false`.
   */
  enabled: boolean
  /**
   * Specifies the exchange rate from the default currency.
   */
  exchange_rate: number
  /**
   * Specifies how the price currency is displayed. For example, "{price}".
   */
  format: string
  /**
   * Indicates the thousand separator character.
   */
  thousand_separator: string
  /**
   * Represents the type represents the object being returned.
   */
  type: string
}

export type RequestCreateCurrencies = {
  data?: DataCreateCurrencies
}

export type DataUpdateCurrencies = {
  /**
   * Specifies whether this is the default currency or not. Either `true` or `false`.
   */
  default?: boolean
}

export type RequestUpdateCurrencies = {
  data?: DataUpdateCurrencies
}

export type ResponseCurrency = {
  /**
   * The unique identifier for this currency.
   */
  id?: string
  /**
   * Represents the type represents the object being returned.
   */
  type?: string
  /**
   * Specifies the currency code. For example, YEN.
   */
  code?: string
  /**
   * Specifies the exchange rate from the default currency.
   */
  exchange_rate?: number
  /**
   * Specifies how the price currency is displayed. For example, "{price}".
   */
  format?: string
  /**
   * Indicates the decimal point character.
   */
  decimal_point?: string
  /**
   * Indicates the thousand separator character.
   */
  thousand_separator?: string
  /**
   * Indicates how many decimal places the currency is formatted to.
   */
  decimal_places?: number
  /**
   * Specifies whether this is the default currency or not. Either `true` or `false`.
   */
  default?: boolean
  /**
   * Specifies if this currency is available for products. Either `true` or `false`.
   */
  enabled?: boolean
  links?: SelfLink2
  meta?: ResponseMetaCurrency
}

export type ResponseMetaCurrency = {
  timestamps?: Timestamps
  /**
   * Indicates whether the owner is store or org.
   */
  owner?: string
}

export type Timestamps = {
  /**
   * Indicates the creation date of this currency.
   */
  created_at?: string
  /**
   * Indicates the updated date of this currency.
   */
  updated_at?: unknown
}

export type SelfLink2 = {
  /**
   * Specifies the URL of this currency.
   */
  self?: string
}

export type ResponseError = Array<unknown>

export type File = {
  /**
   * The unique identifier for this file.
   */
  id?: FilesUuid
  /**
   * The type represents the object being returned.
   */
  type?: string
  /**
   * The name of the file.
   */
  file_name?: string
  /**
   * The mime type of the file.
   */
  mime_type?: string
  /**
   * The size of the file. Required when uploading files.
   */
  file_size?: number
  /**
   * DEPRECATED Whether the file public or not. Required when uploading files.
   */
  public?: boolean
  meta?: FileMeta
  links?: FilesLinks
  link?: FileLink
}

export type FileMeta = {
  /**
   * The date and time the file was created.
   */
  timestamps?: {
    /**
     * The date and time the file was created.
     */
    created_at?: string
  }
  /**
   * The file dimensions.
   */
  dimensions?: {
    /**
     * The width of the file.
     */
    width?: number
    /**
     * The height of the file.
     */
    height?: number
  }
}

export type ResultsMeta = {
  /**
   * Contains the results for the entire collection.
   */
  page?: {
    /**
     * The maximum number of records for all pages.
     */
    limit?: number
    /**
     * The current offset by number of pages.
     */
    offset?: number
    /**
     * The current number of pages.
     */
    current?: number
    /**
     * The total number of records for the entire collection.
     */
    total?: number
  }
  /**
   * Contains the results for the entire collection.
   */
  results?: {
    /**
     * The total number of records for the entire collection.
     */
    total?: number
  }
}

/**
 * Links are used to allow you to move between requests.
 */
export type ResultsLinks = {
  /**
   * Single entities use a self parameter with a link to that specific resource.
   */
  self?: string | null
  /**
   * Always the first page.
   */
  first?: string | null
  /**
   * This is `null` if there is only one page.
   */
  last?: string | null
}

/**
 * The publicly available URL for this file.
 */
export type FileLink = {
  /**
   * The publicly available URL for this file.
   */
  href?: string
}

export type FilesErrorResponse = {
  errors: Array<FilesError>
}

/**
 * Links are used to allow you to move between requests.
 */
export type FilesLinks = {
  /**
   * Single entities use a self parameter with a link to that specific resource.
   */
  self?: string
}

export type FilesUuid = string

export type FilesError = {
  /**
   * The HTTP response code of the error.
   */
  status: number
  /**
   * A brief summary of the error.
   */
  title: string
  /**
   * Optional additional detail about the error.
   */
  detail?: string
  /**
   * Internal request ID.
   */
  request_id?: string
  /**
   * Additional supporting meta data for the error.
   */
  meta?: {
    [key: string]: unknown
  }
}

/**
 * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
 */
export type AcceptLanguage = string

/**
 * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
 */
export type Channel = string

/**
 * This endpoint supports filtering, see [Filtering](#filtering).
 *
 */
export type FilterCatalog = string

/**
 * This endpoints supports filtering. See [Filtering](#filtering).
 *
 */
export type FilterHierarchy = string

/**
 * This endpoint supports filtering, see [Filtering](#filtering).
 *
 */
export type FilterNode = string

/**
 * This endpoints support filtering. See [Filtering](#filtering).
 *
 */
export type FilterProduct = string

/**
 * This endpoint supports filtering. See [Filtering](#filtering).
 *
 */
export type FilterRule = string

/**
 * Using the include parameter, you can retrieve top-level resources.
 *
 * - Files or main image. For example, `include=files,main_image`.
 * - Component product data. For example, `include=component_products`.
 * - Key attribute data, such as SKU or slug.
 *
 */
export type Include = Array<"files" | "main_image" | "component_products">

/**
 * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
 */
export type Limit = BigInt

/**
 * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
 */
export type Offset = BigInt

/**
 * Supply a comma delimited list of pricebook ids to be used to lookup product prices from when the catalog supports price segmentation. The first pricebook will be highest priority (if more than one is supplied) and the rest in descending priority order. Used only for admin endpoints that dont support shopper contetx lookup.
 */
export type PricebookIdsForPriceSegmentationPreview = Array<string>

/**
 * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
 */
export type Tag = string

export type CartInclude = Array<
  "items" | "tax_items" | "custom_discounts" | "promotions"
>

/**
 * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
 */
export type OfferingInclude = Array<"plans" | "pricing_options" | "features">

/**
 * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
 */
export type SubscriptionInclude = Array<"plans" | "pricing_options">

/**
 * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
 *
 */
export type SubscriptionsFilter = string

/**
 * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
 */
export type SubscriptionsPageLimit = BigInt

/**
 * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
 */
export type SubscriptionsPageOffset = BigInt

/**
 * Some Inventories API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
 *
 */
export type InventoriesFilter = string

/**
 * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the the [**page length**](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
 */
export type InventoriesPageLimit = number

/**
 * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [**page length**](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
 */
export type InventoriesPageOffset = number

/**
 * Specifies the filter attributes.
 */
export type Filter = string

/**
 * The number of records per page.
 */
export type PageLimit = BigInt

/**
 * The number of records to offset the results by.
 */
export type PageOffset = BigInt

/**
 * Parameter to retrieve more information about any related resources like account members.
 */
export type IncludeAccountMember = string

/**
 * Parameter to retrieve more information about any related resources like accounts.
 */
export type IncludeAccount = string

/**
 * Supported attributes are `created_at`, `email`, `id`, `name`, or `updated_at`. When specified, the results are sorted in ascending order based on the value of the field. To sort in descending order, prefix the attribute with `-`, for example, `-updated_at`. The default sort order is `created_at` in descending order. For more information, see [Sorting](/guides/Getting-Started/sorting).
 */
export type Sort = string

/**
 *
 * Filtering is available for this endpoint. See [Filtering](/docs/api/pxm/files/get-all-files#filtering).
 *
 */
export type Filesfilter = string

/**
 * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [**page length**](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
 */
export type FilespageOffset = string

/**
 * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the the [**page length**](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
 */
export type FilespageLimit = string

/**
 * The bundle configuration.
 */
export type BundleConfigurationData2 = BundleConfigurationData

/**
 * A list of product id or sku and bundle configuration for cart.
 */
export type ProductsForCartConfiguration2 = ProductsForCartConfiguration

export type GetByContextReleaseData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path?: never
  query?: never
  url: "/catalog"
}

export type GetByContextReleaseErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetByContextReleaseError =
  GetByContextReleaseErrors[keyof GetByContextReleaseErrors]

export type GetByContextReleaseResponses = {
  /**
   * The catalog.
   */
  200: ReleaseData
}

export type GetByContextReleaseResponse =
  GetByContextReleaseResponses[keyof GetByContextReleaseResponses]

export type GetByContextAllHierarchiesData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path?: never
  query?: {
    /**
     * This endpoints supports filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalog/hierarchies"
}

export type GetByContextAllHierarchiesErrors = {
  /**
   * An unexpected error.
   */
  default: ErrorResponse
}

export type GetByContextAllHierarchiesError =
  GetByContextAllHierarchiesErrors[keyof GetByContextAllHierarchiesErrors]

export type GetByContextAllHierarchiesResponses = {
  /**
   * The hierarchies of the catalog.
   */
  200: HierarchyListData
}

export type GetByContextAllHierarchiesResponse =
  GetByContextAllHierarchiesResponses[keyof GetByContextAllHierarchiesResponses]

export type GetByContextHierarchyData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
  }
  query?: never
  url: "/catalog/hierarchies/{hierarchy_id}"
}

export type GetByContextHierarchyErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetByContextHierarchyError =
  GetByContextHierarchyErrors[keyof GetByContextHierarchyErrors]

export type GetByContextHierarchyResponses = {
  /**
   * The catalog hierarchy.
   */
  200: HierarchyData
}

export type GetByContextHierarchyResponse =
  GetByContextHierarchyResponses[keyof GetByContextHierarchyResponses]

export type GetByContextHierarchyNodesData = {
  body?: never
  headers?: {
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
  }
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalog/hierarchies/{hierarchy_id}/nodes"
}

export type GetByContextHierarchyNodesErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetByContextHierarchyNodesError =
  GetByContextHierarchyNodesErrors[keyof GetByContextHierarchyNodesErrors]

export type GetByContextHierarchyNodesResponses = {
  /**
   * The child nodes of a catalog hierarchy.
   */
  200: NodeListData
}

export type GetByContextHierarchyNodesResponse =
  GetByContextHierarchyNodesResponses[keyof GetByContextHierarchyNodesResponses]

export type GetByContextHierarchyChildNodesData = {
  body?: never
  headers?: {
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
  }
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalog/hierarchies/{hierarchy_id}/children"
}

export type GetByContextHierarchyChildNodesErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetByContextHierarchyChildNodesError =
  GetByContextHierarchyChildNodesErrors[keyof GetByContextHierarchyChildNodesErrors]

export type GetByContextHierarchyChildNodesResponses = {
  /**
   * The child nodes of a catalog hierarchy.
   */
  200: NodeListData
}

export type GetByContextHierarchyChildNodesResponse =
  GetByContextHierarchyChildNodesResponses[keyof GetByContextHierarchyChildNodesResponses]

export type GetByContextAllNodesData = {
  body?: never
  headers?: {
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path?: never
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalog/nodes"
}

export type GetByContextAllNodesErrors = {
  /**
   * An unexpected error.
   */
  default: ErrorResponse
}

export type GetByContextAllNodesError =
  GetByContextAllNodesErrors[keyof GetByContextAllNodesErrors]

export type GetByContextAllNodesResponses = {
  /**
   * The nodes of the catalog.
   */
  200: NodeListData
}

export type GetByContextAllNodesResponse =
  GetByContextAllNodesResponses[keyof GetByContextAllNodesResponses]

export type GetByContextNodeData = {
  body?: never
  headers?: {
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog node ID.
     */
    node_id: string
  }
  query?: never
  url: "/catalog/nodes/{node_id}"
}

export type GetByContextNodeErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetByContextNodeError =
  GetByContextNodeErrors[keyof GetByContextNodeErrors]

export type GetByContextNodeResponses = {
  /**
   * The catalog node.
   */
  200: NodeData
}

export type GetByContextNodeResponse =
  GetByContextNodeResponses[keyof GetByContextNodeResponses]

export type GetByContextChildNodesData = {
  body?: never
  headers?: {
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog node ID.
     */
    node_id: string
  }
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalog/nodes/{node_id}/relationships/children"
}

export type GetByContextChildNodesErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetByContextChildNodesError =
  GetByContextChildNodesErrors[keyof GetByContextChildNodesErrors]

export type GetByContextChildNodesResponses = {
  /**
   * The child nodes of a catalog node.
   */
  200: NodeListData
}

export type GetByContextChildNodesResponse =
  GetByContextChildNodesResponses[keyof GetByContextChildNodesResponses]

export type GetByContextAllProductsData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path?: never
  query?: {
    /**
     * Using the include parameter, you can retrieve top-level resources.
     *
     * - Files or main image. For example, `include=files,main_image`.
     * - Component product data. For example, `include=component_products`.
     * - Key attribute data, such as SKU or slug.
     *
     */
    include?: Array<"files" | "main_image" | "component_products">
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalog/products"
}

export type GetByContextAllProductsErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetByContextAllProductsError =
  GetByContextAllProductsErrors[keyof GetByContextAllProductsErrors]

export type GetByContextAllProductsResponses = {
  /**
   * The products of a catalog.
   */
  200: ProductListData
}

export type GetByContextAllProductsResponse =
  GetByContextAllProductsResponses[keyof GetByContextAllProductsResponses]

export type GetByContextProductData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The product ID.
     */
    product_id: string
  }
  query?: {
    /**
     * Using the include parameter, you can retrieve top-level resources.
     *
     * - Files or main image. For example, `include=files,main_image`.
     * - Component product data. For example, `include=component_products`.
     * - Key attribute data, such as SKU or slug.
     *
     */
    include?: Array<"files" | "main_image" | "component_products">
  }
  url: "/catalog/products/{product_id}"
}

export type GetByContextProductErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetByContextProductError =
  GetByContextProductErrors[keyof GetByContextProductErrors]

export type GetByContextProductResponses = {
  /**
   * The product of a catalog.
   */
  200: ProductData
}

export type GetByContextProductResponse =
  GetByContextProductResponses[keyof GetByContextProductResponses]

export type GetByContextAllRelatedProductsData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The product ID.
     */
    product_id: string
    /**
     * The custom relationship slug.
     */
    custom_relationship_slug: string
  }
  query?: {
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalog/products/{product_id}/relationships/{custom_relationship_slug}/products"
}

export type GetByContextAllRelatedProductsErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetByContextAllRelatedProductsError =
  GetByContextAllRelatedProductsErrors[keyof GetByContextAllRelatedProductsErrors]

export type GetByContextAllRelatedProductsResponses = {
  /**
   * The related products of a catalog.
   */
  200: ProductListData
}

export type GetByContextAllRelatedProductsResponse =
  GetByContextAllRelatedProductsResponses[keyof GetByContextAllRelatedProductsResponses]

export type GetByContextComponentProductIdsData = {
  body?: never
  headers?: {
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The product ID.
     */
    product_id: string
  }
  query?: {
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalog/products/{product_id}/relationships/component_products"
}

export type GetByContextComponentProductIdsErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetByContextComponentProductIdsError =
  GetByContextComponentProductIdsErrors[keyof GetByContextComponentProductIdsErrors]

export type GetByContextComponentProductIdsResponses = {
  /**
   * The list of component product IDs of a bundle product from a catalog.
   */
  200: ProductReferenceListData
}

export type GetByContextComponentProductIdsResponse =
  GetByContextComponentProductIdsResponses[keyof GetByContextComponentProductIdsResponses]

export type GetByContextChildProductsData = {
  body?: never
  headers?: {
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The product ID.
     */
    product_id: string
  }
  query?: {
    /**
     * Using the include parameter, you can retrieve top-level resources.
     *
     * - Files or main image. For example, `include=files,main_image`.
     * - Component product data. For example, `include=component_products`.
     * - Key attribute data, such as SKU or slug.
     *
     */
    include?: Array<"files" | "main_image" | "component_products">
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalog/products/{product_id}/relationships/children"
}

export type GetByContextChildProductsErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetByContextChildProductsError =
  GetByContextChildProductsErrors[keyof GetByContextChildProductsErrors]

export type GetByContextChildProductsResponses = {
  /**
   * The list of child products of a parent product from a catalog.
   */
  200: ProductListData
}

export type GetByContextChildProductsResponse =
  GetByContextChildProductsResponses[keyof GetByContextChildProductsResponses]

export type GetByContextProductsForHierarchyData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
  }
  query?: {
    /**
     * Using the include parameter, you can retrieve top-level resources.
     *
     * - Files or main image. For example, `include=files,main_image`.
     * - Component product data. For example, `include=component_products`.
     * - Key attribute data, such as SKU or slug.
     *
     */
    include?: Array<"files" | "main_image" | "component_products">
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalog/hierarchies/{hierarchy_id}/products"
}

export type GetByContextProductsForHierarchyErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetByContextProductsForHierarchyError =
  GetByContextProductsForHierarchyErrors[keyof GetByContextProductsForHierarchyErrors]

export type GetByContextProductsForHierarchyResponses = {
  /**
   * The products of a catalog hierarchy.
   */
  200: ProductListData
}

export type GetByContextProductsForHierarchyResponse =
  GetByContextProductsForHierarchyResponses[keyof GetByContextProductsForHierarchyResponses]

export type GetByContextProductsForNodeData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The catalog node ID.
     */
    node_id: string
  }
  query?: {
    /**
     * Using the include parameter, you can retrieve top-level resources.
     *
     * - Files or main image. For example, `include=files,main_image`.
     * - Component product data. For example, `include=component_products`.
     * - Key attribute data, such as SKU or slug.
     *
     */
    include?: Array<"files" | "main_image" | "component_products">
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalog/nodes/{node_id}/relationships/products"
}

export type GetByContextProductsForNodeErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetByContextProductsForNodeError =
  GetByContextProductsForNodeErrors[keyof GetByContextProductsForNodeErrors]

export type GetByContextProductsForNodeResponses = {
  /**
   * The products of a catalog node.
   */
  200: ProductListData
}

export type GetByContextProductsForNodeResponse =
  GetByContextProductsForNodeResponses[keyof GetByContextProductsForNodeResponses]

export type ConfigureByContextProductData = {
  /**
   * The bundle configuration.
   */
  body: BundleConfigurationData2
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * The list of channels in which this catalog can be displayed. A channel is the shopping experience, such as a mobile app or web storefront. If empty, the catalog rule matches all channels. The channel will eventually be included in the bearer token that is used for authorization, but currently, you must set the `EP-Channel` header in your requests.
     */
    "EP-Channel"?: string
    /**
     * Tags are used to refine the eligibility criteria for a rule. Requests populate the catalog rule tag using the `EP-Context-Tag` header.
     */
    "EP-Context-Tag"?: string
  }
  path: {
    /**
     * The product ID.
     */
    product_id: string
  }
  query?: {
    /**
     * Using the include parameter, you can retrieve top-level resources.
     *
     * - Files or main image. For example, `include=files,main_image`.
     * - Component product data. For example, `include=component_products`.
     * - Key attribute data, such as SKU or slug.
     *
     */
    include?: Array<"files" | "main_image" | "component_products">
  }
  url: "/catalog/products/{product_id}/configure"
}

export type ConfigureByContextProductErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type ConfigureByContextProductError =
  ConfigureByContextProductErrors[keyof ConfigureByContextProductErrors]

export type ConfigureByContextProductResponses = {
  /**
   * The configured product of a catalog.
   */
  200: ProductData
}

export type ConfigureByContextProductResponse =
  ConfigureByContextProductResponses[keyof ConfigureByContextProductResponses]

export type GetCatalogsData = {
  body?: never
  path?: never
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalogs"
}

export type GetCatalogsErrors = {
  /**
   * An unexpected error.
   */
  default: ErrorResponse
}

export type GetCatalogsError = GetCatalogsErrors[keyof GetCatalogsErrors]

export type GetCatalogsResponses = {
  /**
   * The list of catalogs.
   */
  200: CatalogListData
}

export type GetCatalogsResponse =
  GetCatalogsResponses[keyof GetCatalogsResponses]

export type CreateCatalogData = {
  /**
   * Creates a catalog with the following attributes.
   */
  body: CatalogCreateData
  path?: never
  query?: never
  url: "/catalogs"
}

export type CreateCatalogErrors = {
  /**
   * Unexpected error.
   */
  default: ErrorResponse
}

export type CreateCatalogError = CreateCatalogErrors[keyof CreateCatalogErrors]

export type CreateCatalogResponses = {
  /**
   * The created catalog
   */
  201: CatalogData
}

export type CreateCatalogResponse =
  CreateCatalogResponses[keyof CreateCatalogResponses]

export type DeleteCatalogByIdData = {
  body?: never
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
  }
  query?: never
  url: "/catalogs/{catalog_id}"
}

export type DeleteCatalogByIdErrors = {
  /**
   * Unexpected error.
   */
  default: ErrorResponse
}

export type DeleteCatalogByIdError =
  DeleteCatalogByIdErrors[keyof DeleteCatalogByIdErrors]

export type DeleteCatalogByIdResponses = {
  /**
   * A 204 response indicates that the catalog has been deleted.
   */
  204: void
}

export type DeleteCatalogByIdResponse =
  DeleteCatalogByIdResponses[keyof DeleteCatalogByIdResponses]

export type GetCatalogByIdData = {
  body?: never
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
  }
  query?: never
  url: "/catalogs/{catalog_id}"
}

export type GetCatalogByIdErrors = {
  /**
   * An unexpected error.
   */
  default: ErrorResponse
}

export type GetCatalogByIdError =
  GetCatalogByIdErrors[keyof GetCatalogByIdErrors]

export type GetCatalogByIdResponses = {
  /**
   * The catalog.
   */
  200: CatalogData
}

export type GetCatalogByIdResponse =
  GetCatalogByIdResponses[keyof GetCatalogByIdResponses]

export type UpdateCatalogData = {
  /**
   * Updated catalog.
   */
  body: CatalogUpdateData
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
  }
  query?: never
  url: "/catalogs/{catalog_id}"
}

export type UpdateCatalogErrors = {
  /**
   * Unexpected error.
   */
  default: ErrorResponse
}

export type UpdateCatalogError = UpdateCatalogErrors[keyof UpdateCatalogErrors]

export type UpdateCatalogResponses = {
  /**
   * An updated catalog with the following attributes.
   */
  200: CatalogData
}

export type UpdateCatalogResponse =
  UpdateCatalogResponses[keyof UpdateCatalogResponses]

export type DeleteReleasesData = {
  body?: never
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
  }
  query?: never
  url: "/catalogs/{catalog_id}/releases"
}

export type DeleteReleasesErrors = {
  /**
   * Unexpected error.
   */
  default: ErrorResponse
}

export type DeleteReleasesError =
  DeleteReleasesErrors[keyof DeleteReleasesErrors]

export type DeleteReleasesResponses = {
  /**
   * A 204 response indicates that the releases have been deleted.
   */
  204: void
}

export type DeleteReleasesResponse =
  DeleteReleasesResponses[keyof DeleteReleasesResponses]

export type GetReleasesData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
  }
  query?: never
  url: "/catalogs/{catalog_id}/releases"
}

export type GetReleasesErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetReleasesError = GetReleasesErrors[keyof GetReleasesErrors]

export type GetReleasesResponses = {
  /**
   * The list of catalogs.
   */
  200: ReleaseListData
}

export type GetReleasesResponse =
  GetReleasesResponses[keyof GetReleasesResponses]

export type PublishReleaseData = {
  /**
   * Options for catalog release publishing
   */
  body?: CatalogReleaseCreateData
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
  }
  query?: never
  url: "/catalogs/{catalog_id}/releases"
}

export type PublishReleaseErrors = {
  /**
   * Unexpected error.
   */
  default: ErrorResponse
}

export type PublishReleaseError =
  PublishReleaseErrors[keyof PublishReleaseErrors]

export type PublishReleaseResponses = {
  /**
   * Publishes a catalog release with the following attributes.
   */
  201: ReleaseData
}

export type PublishReleaseResponse =
  PublishReleaseResponses[keyof PublishReleaseResponses]

export type DeleteReleaseByIdData = {
  body?: never
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
  }
  query?: never
  url: "/catalogs/{catalog_id}/releases/{release_id}"
}

export type DeleteReleaseByIdErrors = {
  /**
   * Unexpected error.
   */
  default: ErrorResponse
}

export type DeleteReleaseByIdError =
  DeleteReleaseByIdErrors[keyof DeleteReleaseByIdErrors]

export type DeleteReleaseByIdResponses = {
  /**
   * A 204 response indicates that the release has been deleted.
   */
  204: void
}

export type DeleteReleaseByIdResponse =
  DeleteReleaseByIdResponses[keyof DeleteReleaseByIdResponses]

export type GetReleaseByIdData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
  }
  query?: never
  url: "/catalogs/{catalog_id}/releases/{release_id}"
}

export type GetReleaseByIdErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetReleaseByIdError =
  GetReleaseByIdErrors[keyof GetReleaseByIdErrors]

export type GetReleaseByIdResponses = {
  /**
   * The catalog.
   */
  200: ReleaseData
}

export type GetReleaseByIdResponse =
  GetReleaseByIdResponses[keyof GetReleaseByIdResponses]

export type GetRulesData = {
  body?: never
  path?: never
  query?: {
    /**
     * This endpoint supports filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalogs/rules"
}

export type GetRulesErrors = {
  /**
   * An unexpected error.
   */
  default: ErrorResponse
}

export type GetRulesError = GetRulesErrors[keyof GetRulesErrors]

export type GetRulesResponses = {
  /**
   * The list of catalog rules.
   */
  200: RuleListData
}

export type GetRulesResponse = GetRulesResponses[keyof GetRulesResponses]

export type CreateRuleData = {
  /**
   * Creates a catalog rule with the following attributes.
   */
  body: RuleCreateData
  path?: never
  query?: never
  url: "/catalogs/rules"
}

export type CreateRuleErrors = {
  /**
   * Unexpected error.
   */
  default: ErrorResponse
}

export type CreateRuleError = CreateRuleErrors[keyof CreateRuleErrors]

export type CreateRuleResponses = {
  /**
   * The created catalog rule
   */
  201: RuleData
}

export type CreateRuleResponse = CreateRuleResponses[keyof CreateRuleResponses]

export type DeleteRuleByIdData = {
  body?: never
  path: {
    /**
     * The catalog rule ID.
     */
    catalog_rule_id: string
  }
  query?: never
  url: "/catalogs/rules/{catalog_rule_id}"
}

export type DeleteRuleByIdErrors = {
  /**
   * Unexpected error.
   */
  default: ErrorResponse
}

export type DeleteRuleByIdError =
  DeleteRuleByIdErrors[keyof DeleteRuleByIdErrors]

export type DeleteRuleByIdResponses = {
  /**
   * A 204 response indicates that the catalog rule has been deleted.
   */
  204: void
}

export type DeleteRuleByIdResponse =
  DeleteRuleByIdResponses[keyof DeleteRuleByIdResponses]

export type GetRuleByIdData = {
  body?: never
  path: {
    /**
     * The catalog rule ID.
     */
    catalog_rule_id: string
  }
  query?: never
  url: "/catalogs/rules/{catalog_rule_id}"
}

export type GetRuleByIdErrors = {
  /**
   * An unexpected error.
   */
  default: ErrorResponse
}

export type GetRuleByIdError = GetRuleByIdErrors[keyof GetRuleByIdErrors]

export type GetRuleByIdResponses = {
  /**
   * The catalog rile.
   */
  200: RuleData
}

export type GetRuleByIdResponse =
  GetRuleByIdResponses[keyof GetRuleByIdResponses]

export type UpdateRuleData = {
  /**
   * An updated catalog rule with the following attributes.
   */
  body: RuleUpdateData
  path: {
    /**
     * The catalog rule ID.
     */
    catalog_rule_id: string
  }
  query?: never
  url: "/catalogs/rules/{catalog_rule_id}"
}

export type UpdateRuleErrors = {
  /**
   * Unexpected error.
   */
  default: ErrorResponse
}

export type UpdateRuleError = UpdateRuleErrors[keyof UpdateRuleErrors]

export type UpdateRuleResponses = {
  /**
   * An Updated catalog rule with the following attributes.
   */
  200: RuleData
}

export type UpdateRuleResponse = UpdateRuleResponses[keyof UpdateRuleResponses]

export type GetAllHierarchiesData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
  }
  query?: {
    /**
     * This endpoints supports filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalogs/{catalog_id}/releases/{release_id}/hierarchies"
}

export type GetAllHierarchiesErrors = {
  /**
   * An unexpected error.
   */
  default: ErrorResponse
}

export type GetAllHierarchiesError =
  GetAllHierarchiesErrors[keyof GetAllHierarchiesErrors]

export type GetAllHierarchiesResponses = {
  /**
   * The hierarchies of a catalog.
   */
  200: HierarchyListData
}

export type GetAllHierarchiesResponse =
  GetAllHierarchiesResponses[keyof GetAllHierarchiesResponses]

export type GetHierarchyData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
  }
  query?: never
  url: "/catalogs/{catalog_id}/releases/{release_id}/hierarchies/{hierarchy_id}"
}

export type GetHierarchyErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetHierarchyError = GetHierarchyErrors[keyof GetHierarchyErrors]

export type GetHierarchyResponses = {
  /**
   * The catalog hierarchy.
   */
  200: HierarchyData
}

export type GetHierarchyResponse =
  GetHierarchyResponses[keyof GetHierarchyResponses]

export type GetHierarchyNodesData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
  }
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalogs/{catalog_id}/releases/{release_id}/hierarchies/{hierarchy_id}/nodes"
}

export type GetHierarchyNodesErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetHierarchyNodesError =
  GetHierarchyNodesErrors[keyof GetHierarchyNodesErrors]

export type GetHierarchyNodesResponses = {
  /**
   * The child nodes of a catalog hierarchy.
   */
  200: NodeListData
}

export type GetHierarchyNodesResponse =
  GetHierarchyNodesResponses[keyof GetHierarchyNodesResponses]

export type GetHierarchyChildNodesData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
  }
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalogs/{catalog_id}/releases/{release_id}/hierarchies/{hierarchy_id}/children"
}

export type GetHierarchyChildNodesErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetHierarchyChildNodesError =
  GetHierarchyChildNodesErrors[keyof GetHierarchyChildNodesErrors]

export type GetHierarchyChildNodesResponses = {
  /**
   * The child nodes of a catalog hierarchy.
   */
  200: NodeListData
}

export type GetHierarchyChildNodesResponse =
  GetHierarchyChildNodesResponses[keyof GetHierarchyChildNodesResponses]

export type GetAllNodesData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
  }
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalogs/{catalog_id}/releases/{release_id}/nodes"
}

export type GetAllNodesErrors = {
  /**
   * An unexpected error.
   */
  default: ErrorResponse
}

export type GetAllNodesError = GetAllNodesErrors[keyof GetAllNodesErrors]

export type GetAllNodesResponses = {
  /**
   * The nodes of a catalog.
   */
  200: NodeListData
}

export type GetAllNodesResponse =
  GetAllNodesResponses[keyof GetAllNodesResponses]

export type GetNodeData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
    /**
     * The catalog node ID.
     */
    node_id: string
  }
  query?: never
  url: "/catalogs/{catalog_id}/releases/{release_id}/nodes/{node_id}"
}

export type GetNodeErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetNodeError = GetNodeErrors[keyof GetNodeErrors]

export type GetNodeResponses = {
  /**
   * The catalog node.
   */
  200: NodeData
}

export type GetNodeResponse = GetNodeResponses[keyof GetNodeResponses]

export type GetChildNodesData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
    /**
     * The catalog node ID.
     */
    node_id: string
  }
  query?: {
    /**
     * This endpoint supports filtering, see [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalogs/{catalog_id}/releases/{release_id}/nodes/{node_id}/relationships/children"
}

export type GetChildNodesErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetChildNodesError = GetChildNodesErrors[keyof GetChildNodesErrors]

export type GetChildNodesResponses = {
  /**
   * The child nodes of a catalog node.
   */
  200: NodeListData
}

export type GetChildNodesResponse =
  GetChildNodesResponses[keyof GetChildNodesResponses]

export type GetAllProductsData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * Supply a comma delimited list of pricebook ids to be used to lookup product prices from when the catalog supports price segmentation. The first pricebook will be highest priority (if more than one is supplied) and the rest in descending priority order. Used only for admin endpoints that dont support shopper contetx lookup.
     */
    "EP-Pricebook-IDs-For-Price-Segmentation-Preview"?: Array<string>
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
  }
  query?: {
    /**
     * Using the include parameter, you can retrieve top-level resources.
     *
     * - Files or main image. For example, `include=files,main_image`.
     * - Component product data. For example, `include=component_products`.
     * - Key attribute data, such as SKU or slug.
     *
     */
    include?: Array<"files" | "main_image" | "component_products">
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalogs/{catalog_id}/releases/{release_id}/products"
}

export type GetAllProductsErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetAllProductsError =
  GetAllProductsErrors[keyof GetAllProductsErrors]

export type GetAllProductsResponses = {
  /**
   * The products of a catalog.
   */
  200: ProductListData
}

export type GetAllProductsResponse =
  GetAllProductsResponses[keyof GetAllProductsResponses]

export type GetProductData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * Supply a comma delimited list of pricebook ids to be used to lookup product prices from when the catalog supports price segmentation. The first pricebook will be highest priority (if more than one is supplied) and the rest in descending priority order. Used only for admin endpoints that dont support shopper contetx lookup.
     */
    "EP-Pricebook-IDs-For-Price-Segmentation-Preview"?: Array<string>
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
    /**
     * The product ID.
     */
    product_id: string
  }
  query?: {
    /**
     * Using the include parameter, you can retrieve top-level resources.
     *
     * - Files or main image. For example, `include=files,main_image`.
     * - Component product data. For example, `include=component_products`.
     * - Key attribute data, such as SKU or slug.
     *
     */
    include?: Array<"files" | "main_image" | "component_products">
  }
  url: "/catalogs/{catalog_id}/releases/{release_id}/products/{product_id}"
}

export type GetProductErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetProductError = GetProductErrors[keyof GetProductErrors]

export type GetProductResponses = {
  /**
   * The product of a catalog.
   */
  200: ProductData
}

export type GetProductResponse = GetProductResponses[keyof GetProductResponses]

export type GetAllRelatedProductsData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * Supply a comma delimited list of pricebook ids to be used to lookup product prices from when the catalog supports price segmentation. The first pricebook will be highest priority (if more than one is supplied) and the rest in descending priority order. Used only for admin endpoints that dont support shopper contetx lookup.
     */
    "EP-Pricebook-IDs-For-Price-Segmentation-Preview"?: Array<string>
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
    /**
     * The product ID.
     */
    product_id: string
    /**
     * The custom relationship slug.
     */
    custom_relationship_slug: string
  }
  query?: {
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalogs/{catalog_id}/releases/{release_id}/products/{product_id}/relationships/{custom_relationship_slug}/products"
}

export type GetAllRelatedProductsErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetAllRelatedProductsError =
  GetAllRelatedProductsErrors[keyof GetAllRelatedProductsErrors]

export type GetAllRelatedProductsResponses = {
  /**
   * The related products of a catalog.
   */
  200: ProductListData
}

export type GetAllRelatedProductsResponse =
  GetAllRelatedProductsResponses[keyof GetAllRelatedProductsResponses]

export type GetComponentProductIdsData = {
  body?: never
  headers?: {
    /**
     * Supply a comma delimited list of pricebook ids to be used to lookup product prices from when the catalog supports price segmentation. The first pricebook will be highest priority (if more than one is supplied) and the rest in descending priority order. Used only for admin endpoints that dont support shopper contetx lookup.
     */
    "EP-Pricebook-IDs-For-Price-Segmentation-Preview"?: Array<string>
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
    /**
     * The product ID.
     */
    product_id: string
  }
  query?: {
    /**
     * Using the include parameter, you can retrieve top-level resources.
     *
     * - Files or main image. For example, `include=files,main_image`.
     * - Component product data. For example, `include=component_products`.
     * - Key attribute data, such as SKU or slug.
     *
     */
    include?: Array<"files" | "main_image" | "component_products">
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalogs/{catalog_id}/releases/{release_id}/products/{product_id}/relationships/component_products"
}

export type GetComponentProductIdsErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetComponentProductIdsError =
  GetComponentProductIdsErrors[keyof GetComponentProductIdsErrors]

export type GetComponentProductIdsResponses = {
  /**
   * The list of component product IDs of a specific bundle product from a catalog.
   */
  200: ProductReferenceListData
}

export type GetComponentProductIdsResponse =
  GetComponentProductIdsResponses[keyof GetComponentProductIdsResponses]

export type GetChildProductsData = {
  body?: never
  headers?: {
    /**
     * Supply a comma delimited list of pricebook ids to be used to lookup product prices from when the catalog supports price segmentation. The first pricebook will be highest priority (if more than one is supplied) and the rest in descending priority order. Used only for admin endpoints that dont support shopper contetx lookup.
     */
    "EP-Pricebook-IDs-For-Price-Segmentation-Preview"?: Array<string>
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
    /**
     * The product ID.
     */
    product_id: string
  }
  query?: {
    /**
     * Using the include parameter, you can retrieve top-level resources.
     *
     * - Files or main image. For example, `include=files,main_image`.
     * - Component product data. For example, `include=component_products`.
     * - Key attribute data, such as SKU or slug.
     *
     */
    include?: Array<"files" | "main_image" | "component_products">
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalogs/{catalog_id}/releases/{release_id}/products/{product_id}/relationships/children"
}

export type GetChildProductsErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetChildProductsError =
  GetChildProductsErrors[keyof GetChildProductsErrors]

export type GetChildProductsResponses = {
  /**
   * The list of child products of a specific base product from a catalog.
   */
  200: ProductListData
}

export type GetChildProductsResponse =
  GetChildProductsResponses[keyof GetChildProductsResponses]

export type GetProductsForHierarchyData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * Supply a comma delimited list of pricebook ids to be used to lookup product prices from when the catalog supports price segmentation. The first pricebook will be highest priority (if more than one is supplied) and the rest in descending priority order. Used only for admin endpoints that dont support shopper contetx lookup.
     */
    "EP-Pricebook-IDs-For-Price-Segmentation-Preview"?: Array<string>
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
    /**
     * The catalog hierarchy ID.
     */
    hierarchy_id: string
  }
  query?: {
    /**
     * Using the include parameter, you can retrieve top-level resources.
     *
     * - Files or main image. For example, `include=files,main_image`.
     * - Component product data. For example, `include=component_products`.
     * - Key attribute data, such as SKU or slug.
     *
     */
    include?: Array<"files" | "main_image" | "component_products">
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalogs/{catalog_id}/releases/{release_id}/hierarchies/{hierarchy_id}/products"
}

export type GetProductsForHierarchyErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetProductsForHierarchyError =
  GetProductsForHierarchyErrors[keyof GetProductsForHierarchyErrors]

export type GetProductsForHierarchyResponses = {
  /**
   * The products of a catalog hierarchy.
   */
  200: ProductListData
}

export type GetProductsForHierarchyResponse =
  GetProductsForHierarchyResponses[keyof GetProductsForHierarchyResponses]

export type GetProductsForNodeData = {
  body?: never
  headers?: {
    /**
     * The language and locale your storefront prefers. See [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
     */
    "accept-language"?: string
    /**
     * Supply a comma delimited list of pricebook ids to be used to lookup product prices from when the catalog supports price segmentation. The first pricebook will be highest priority (if more than one is supplied) and the rest in descending priority order. Used only for admin endpoints that dont support shopper contetx lookup.
     */
    "EP-Pricebook-IDs-For-Price-Segmentation-Preview"?: Array<string>
  }
  path: {
    /**
     * The catalog ID.
     */
    catalog_id: string
    /**
     * The unique identifier of a published release of the catalog or `latestPublished` for the most recently published version.
     */
    release_id: string
    /**
     * The catalog node ID.
     */
    node_id: string
  }
  query?: {
    /**
     * This endpoints support filtering. See [Filtering](#filtering).
     *
     */
    filter?: string
    /**
     * Using the include parameter, you can retrieve top-level resources.
     *
     * - Files or main image. For example, `include=files,main_image`.
     * - Component product data. For example, `include=component_products`.
     * - Key attribute data, such as SKU or slug.
     *
     */
    include?: Array<"files" | "main_image" | "component_products">
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/api/settings/settings-introduction#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
  }
  url: "/catalogs/{catalog_id}/releases/{release_id}/nodes/{node_id}/relationships/products"
}

export type GetProductsForNodeErrors = {
  /**
   * The unexpected error.
   */
  default: ErrorResponse
}

export type GetProductsForNodeError =
  GetProductsForNodeErrors[keyof GetProductsForNodeErrors]

export type GetProductsForNodeResponses = {
  /**
   * The products of a catalog node.
   */
  200: ProductListData
}

export type GetProductsForNodeResponse =
  GetProductsForNodeResponses[keyof GetProductsForNodeResponses]

export type GetCartsData = {
  body?: never
  headers?: {
    /**
     * An Account Management Authentication token to access a specific account's carts.
     */
    "EP-Account-Management-Authentication-Token"?: string
    /**
     * A customer token to access a specific customer's carts.
     */
    "x-moltin-customer-token"?: string
  }
  path?: never
  query?: never
  url: "/v2/carts"
}

export type GetCartsErrors = {
  /**
   * Bad Request
   */
  400: {
    errors?: Array<{
      detail?: string
      title?: string
    }>
  }
  /**
   * Unauthorized call
   */
  403: ResponseErrorResponse
}

export type GetCartsError = GetCartsErrors[keyof GetCartsErrors]

export type GetCartsResponses = {
  200: CartCollectionResponse
}

export type GetCartsResponse = GetCartsResponses[keyof GetCartsResponses]

export type CreateACartData = {
  body?: CartsRequest
  headers?: {
    /**
     * A customer token to be associated with the cart.
     */
    "x-moltin-customer-token"?: string
  }
  path?: never
  query?: never
  url: "/v2/carts"
}

export type CreateACartErrors = {
  /**
   * Bad Request
   */
  400: {
    errors?: Array<{
      detail?: string
      status?: number
      title?: string
    }>
  }
  /**
   * Unauthorized call
   */
  403: ResponseErrorResponse
}

export type CreateACartError = CreateACartErrors[keyof CreateACartErrors]

export type CreateACartResponses = {
  201: CartEntityResponse
}

export type CreateACartResponse =
  CreateACartResponses[keyof CreateACartResponses]

export type DeleteACartData = {
  body?: never
  path: {
    /**
     * The unique identifier of the cart that you want to delete.
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}"
}

export type DeleteACartErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
}

export type DeleteACartError = DeleteACartErrors[keyof DeleteACartErrors]

export type DeleteACartResponses = {
  /**
   * No Content
   */
  204: void
}

export type DeleteACartResponse =
  DeleteACartResponses[keyof DeleteACartResponses]

export type GetACartData = {
  body?: never
  path: {
    /**
     * The unique identifier for this cart that you created.
     */
    cartID: string
  }
  query?: {
    include?: Array<"items" | "tax_items" | "custom_discounts" | "promotions">
  }
  url: "/v2/carts/{cartID}"
}

export type GetACartErrors = {
  /**
   * Bad Request
   */
  400: {
    errors?: Array<{
      detail?: string
      status?: number
      title?: string
    }>
  }
}

export type GetACartError = GetACartErrors[keyof GetACartErrors]

export type GetACartResponses = {
  /**
   * OK
   */
  200: CartEntityResponse
}

export type GetACartResponse = GetACartResponses[keyof GetACartResponses]

export type UpdateACartData = {
  body?: CartsRequest
  path: {
    /**
     * The unique identifier of a cart created by you.
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}"
}

export type UpdateACartErrors = {
  /**
   * Unauthorized call
   */
  403: ResponseErrorResponse
  /**
   * Unprocessable Content
   */
  422: {
    errors?: Array<{
      detail?: string
      status?: number
      title?: string
    }>
  }
}

export type UpdateACartError = UpdateACartErrors[keyof UpdateACartErrors]

export type UpdateACartResponses = {
  200: CartEntityResponse
}

export type UpdateACartResponse =
  UpdateACartResponses[keyof UpdateACartResponses]

export type DeleteAllCartItemsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the cart created by you.
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/items"
}

export type DeleteAllCartItemsErrors = {
  /**
   * Unprocessable Entity
   */
  422: ResponseErrorResponse
}

export type DeleteAllCartItemsError =
  DeleteAllCartItemsErrors[keyof DeleteAllCartItemsErrors]

export type DeleteAllCartItemsResponses = {
  /**
   * No Content
   */
  204: void
}

export type DeleteAllCartItemsResponse =
  DeleteAllCartItemsResponses[keyof DeleteAllCartItemsResponses]

export type GetCartItemsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the cart that you created.
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/items"
}

export type GetCartItemsResponses = {
  200: CartItemsResponse
}

export type GetCartItemsResponse =
  GetCartItemsResponses[keyof GetCartItemsResponses]

export type ManageCartsData = {
  body?:
    | CartItemObjectRequest
    | SubscriptionItemObject
    | CartMergeObjectRequest
    | CustomItemObject
    | ReOrderObjectRequest
    | PromotionItemObject
    | BulkAddItemsRequest
  path: {
    /**
     * The unique identifier of the cart that you created.
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/items"
}

export type ManageCartsErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
  /**
   * Not Found
   */
  404: ResponseErrorResponse
  /**
   * Unprocessable Entity
   */
  422: ResponseErrorResponse
  /**
   * Internal Server Error
   */
  500: ResponseErrorResponse
}

export type ManageCartsError = ManageCartsErrors[keyof ManageCartsErrors]

export type ManageCartsResponses = {
  201: CartsResponse
}

export type ManageCartsResponse =
  ManageCartsResponses[keyof ManageCartsResponses]

export type BulkUpdateItemsInCartData = {
  body?: BulkUpdateCartsItems
  path: {
    /**
     * The unique identifier of the cart that you created.
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/items"
}

export type BulkUpdateItemsInCartErrors = {
  /**
   * Insufficient Stock
   */
  400: ResponseErrorResponse
  /**
   * Not Found
   */
  404: ResponseErrorResponse
  /**
   * Unprocessable Entity
   */
  422: ResponseErrorResponse
}

export type BulkUpdateItemsInCartError =
  BulkUpdateItemsInCartErrors[keyof BulkUpdateItemsInCartErrors]

export type BulkUpdateItemsInCartResponses = {
  200: unknown
}

export type DeleteACartItemData = {
  body?: never
  path: {
    /**
     * The unique identifier of the cart created by you.
     */
    cartID: string
    /**
     * The unique identifier of the cart that you want to delete.
     */
    cartitemID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/items/{cartitemID}"
}

export type DeleteACartItemResponses = {
  200: CartsResponse
}

export type DeleteACartItemResponse =
  DeleteACartItemResponses[keyof DeleteACartItemResponses]

export type UpdateACartItemData = {
  body?: UpdateCartsItems
  path: {
    /**
     * A unique identifier of the cart that you created.
     */
    cartID: string
    /**
     * A unique identifier of the cart item.
     */
    cartitemID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/items/{cartitemID}"
}

export type UpdateACartItemErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
  /**
   * Not Found
   */
  404: ResponseErrorResponse
}

export type UpdateACartItemError =
  UpdateACartItemErrors[keyof UpdateACartItemErrors]

export type UpdateACartItemResponses = {
  200: CartsResponse
}

export type UpdateACartItemResponse =
  UpdateACartItemResponses[keyof UpdateACartItemResponses]

export type DeleteAccountCartAssociationData = {
  body?: CartsRelationshipsAccountsData
  headers?: {
    /**
     * An Account Management Authentication token to access a specific account's carts.
     */
    "EP-Account-Management-Authentication-Token"?: string
  }
  path: {
    /**
     * The ID for the cart created by the account.
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/relationships/accounts"
}

export type DeleteAccountCartAssociationErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
  /**
   * Forbidden
   */
  403: ResponseErrorResponse
}

export type DeleteAccountCartAssociationError =
  DeleteAccountCartAssociationErrors[keyof DeleteAccountCartAssociationErrors]

export type DeleteAccountCartAssociationResponses = {
  /**
   * No Content
   */
  204: void
}

export type DeleteAccountCartAssociationResponse =
  DeleteAccountCartAssociationResponses[keyof DeleteAccountCartAssociationResponses]

export type CreateAccountCartAssociationData = {
  body?: CartsRelationshipsAccountsData
  headers?: {
    /**
     * An Account Management Authentication token to access a specific account's carts.
     */
    "EP-Account-Management-Authentication-Token"?: string
  }
  path: {
    /**
     * The ID for the cart created by the account. Ensure that you follow the guidelines for [Safe Characters](/guides/Getting-Started/safe-characters).
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/relationships/accounts"
}

export type CreateAccountCartAssociationErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
  /**
   * Forbidden
   */
  403: ResponseErrorResponse
  /**
   * Unprocessable Entity
   */
  422: ResponseErrorResponse
}

export type CreateAccountCartAssociationError =
  CreateAccountCartAssociationErrors[keyof CreateAccountCartAssociationErrors]

export type CreateAccountCartAssociationResponses = {
  /**
   * OK
   */
  200: CartsRelationshipsAccountsData
  /**
   * No Content is sent back in case the account has already been associated to the cart.
   */
  204: void
}

export type CreateAccountCartAssociationResponse =
  CreateAccountCartAssociationResponses[keyof CreateAccountCartAssociationResponses]

export type DeleteCustomerCartAssociationData = {
  body?: CartsRelationshipsCustomersData
  headers?: {
    /**
     * A customer token to access a specific customer's carts.
     */
    "x-moltin-customer-token"?: string
  }
  path: {
    /**
     * The ID for the cart created by the customer.
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/relationships/customers"
}

export type DeleteCustomerCartAssociationErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
  /**
   * Forbidden
   */
  403: ResponseErrorResponse
}

export type DeleteCustomerCartAssociationError =
  DeleteCustomerCartAssociationErrors[keyof DeleteCustomerCartAssociationErrors]

export type DeleteCustomerCartAssociationResponses = {
  /**
   * No Content
   */
  204: void
}

export type DeleteCustomerCartAssociationResponse =
  DeleteCustomerCartAssociationResponses[keyof DeleteCustomerCartAssociationResponses]

export type CreateCustomerCartAssociationData = {
  body?: CartsRelationshipsCustomersData
  headers?: {
    /**
     * A customer token to access a specific customer's carts.
     */
    "x-moltin-customer-token"?: string
  }
  path: {
    /**
     * The ID for the cart created by the customer. Ensure that you follow the guidelines for [Safe Characters](/guides/Getting-Started/safe-characters).
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/relationships/customers"
}

export type CreateCustomerCartAssociationErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
  /**
   * Forbidden
   */
  403: ResponseErrorResponse
  /**
   * Unauthorized
   */
  422: ResponseErrorResponse
}

export type CreateCustomerCartAssociationError =
  CreateCustomerCartAssociationErrors[keyof CreateCustomerCartAssociationErrors]

export type CreateCustomerCartAssociationResponses = {
  /**
   * OK
   */
  200: CartsRelationshipsCustomersData
  /**
   * No Content
   */
  204: void
}

export type CreateCustomerCartAssociationResponse =
  CreateCustomerCartAssociationResponses[keyof CreateCustomerCartAssociationResponses]

export type DeleteAPromotionViaPromotionCodeData = {
  body?: never
  path: {
    /**
     * Specifies the unique identifier of a cart created by you.
     */
    cartID: string
    /**
     * Specifies the promotion code to be deleted.
     */
    promoCode: string
  }
  query?: never
  url: "/v2/carts/{cartID}/discounts/{promoCode}"
}

export type DeleteAPromotionViaPromotionCodeResponses = {
  /**
   * No Content
   */
  204: void
}

export type DeleteAPromotionViaPromotionCodeResponse =
  DeleteAPromotionViaPromotionCodeResponses[keyof DeleteAPromotionViaPromotionCodeResponses]

export type AddTaxItemToCartData = {
  body?: CartItemTaxesEntityResponse
  path: {
    /**
     * The unique identifier of the cart.
     */
    cartID: string
    /**
     * The unique identifier of the cart item.
     */
    cartitemID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/items/{cartitemID}/taxes"
}

export type AddTaxItemToCartErrors = {
  /**
   * Unauthorized
   */
  422: ResponseErrorResponse
}

export type AddTaxItemToCartError =
  AddTaxItemToCartErrors[keyof AddTaxItemToCartErrors]

export type AddTaxItemToCartResponses = {
  200: CartItemTaxesEntityResponse
  /**
   * Created
   */
  201: CartItemTaxesEntityResponse
}

export type AddTaxItemToCartResponse =
  AddTaxItemToCartResponses[keyof AddTaxItemToCartResponses]

export type BulkDeleteTaxItemsFromCartData = {
  body?: never
  path: {
    /**
     * The unique identifier of the cart.
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/taxes"
}

export type BulkDeleteTaxItemsFromCartResponses = {
  /**
   * No Content
   */
  204: void
}

export type BulkDeleteTaxItemsFromCartResponse =
  BulkDeleteTaxItemsFromCartResponses[keyof BulkDeleteTaxItemsFromCartResponses]

export type BulkAddTaxItemsToCartData = {
  body?: CartsBulkTaxes
  path: {
    /**
     * The unique identifier of the cart.
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/taxes"
}

export type BulkAddTaxItemsToCartErrors = {
  /**
   * Unprocessable Entity
   */
  422: ResponseErrorResponse
}

export type BulkAddTaxItemsToCartError =
  BulkAddTaxItemsToCartErrors[keyof BulkAddTaxItemsToCartErrors]

export type BulkAddTaxItemsToCartResponses = {
  200: CartsBulkTaxes
  /**
   * Created
   */
  201: CartsBulkTaxes
}

export type BulkAddTaxItemsToCartResponse =
  BulkAddTaxItemsToCartResponses[keyof BulkAddTaxItemsToCartResponses]

export type DeleteATaxItemData = {
  body?: never
  path: {
    /**
     * The unique identifier of the cart.
     */
    cartID: string
    /**
     * The unique identifier of the cart item.
     */
    cartitemID: string
    /**
     * The unique identifier of the tax item.
     */
    taxitemID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/items/{cartitemID}/taxes/{taxitemID}"
}

export type DeleteATaxItemResponses = {
  /**
   * No Content
   */
  204: void
}

export type DeleteATaxItemResponse =
  DeleteATaxItemResponses[keyof DeleteATaxItemResponses]

export type UpdateATaxItemData = {
  body?: CartItemTaxesEntityResponse
  path: {
    /**
     * The unique identifier of the cart.
     */
    cartID: string
    /**
     * The unique identifier of the cart item.
     */
    cartitemID: string
    /**
     * The unique identifier of the tax item.
     */
    taxitemID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/items/{cartitemID}/taxes/{taxitemID}"
}

export type UpdateATaxItemResponses = {
  200: CartItemTaxesEntityResponse
}

export type UpdateATaxItemResponse =
  UpdateATaxItemResponses[keyof UpdateATaxItemResponses]

export type BulkDeleteCustomDiscountsFromCartData = {
  body?: never
  path: {
    /**
     * Specifies the unique ID for the cart.
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/custom-discounts"
}

export type BulkDeleteCustomDiscountsFromCartResponses = {
  /**
   * No Content
   */
  204: void
}

export type BulkDeleteCustomDiscountsFromCartResponse =
  BulkDeleteCustomDiscountsFromCartResponses[keyof BulkDeleteCustomDiscountsFromCartResponses]

export type BulkAddCustomDiscountsToCartData = {
  body?: CartsBulkCustomDiscounts
  path: {
    /**
     * Specifies the system generated ID for the cart that the shopper created.
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/custom-discounts"
}

export type BulkAddCustomDiscountsToCartErrors = {
  /**
   * Could not apply custom discount
   */
  400: ResponseErrorResponse
  /**
   * Could not apply custom discount
   */
  422: ResponseErrorResponse
}

export type BulkAddCustomDiscountsToCartError =
  BulkAddCustomDiscountsToCartErrors[keyof BulkAddCustomDiscountsToCartErrors]

export type BulkAddCustomDiscountsToCartResponses = {
  201:
    | CartsBulkCustomDiscountsResponse
    | CartsBulkCustomDiscountsCollectionResponse
}

export type BulkAddCustomDiscountsToCartResponse =
  BulkAddCustomDiscountsToCartResponses[keyof BulkAddCustomDiscountsToCartResponses]

export type DeleteCustomDiscountFromCartData = {
  body?: never
  path: {
    /**
     * Specifies the unique ID for the cart.
     */
    cartID: string
    /**
     * Specifies the ID for the custom discount to be deleted.
     */
    customdiscountID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/custom-discounts/{customdiscountID}"
}

export type DeleteCustomDiscountFromCartResponses = {
  /**
   * No Content
   */
  204: void
}

export type DeleteCustomDiscountFromCartResponse =
  DeleteCustomDiscountFromCartResponses[keyof DeleteCustomDiscountFromCartResponses]

export type UpdateCustomDiscountForCartData = {
  body?: CartsCustomDiscountsEntityRequest
  path: {
    /**
     * Specifies the unique ID for the cart.
     */
    cartID: string
    /**
     * Specifies the ID for the custom discount to be updated.
     */
    customdiscountID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/custom-discounts/{customdiscountID}"
}

export type UpdateCustomDiscountForCartResponses = {
  200: CartsCustomDiscountsEntityResponse
}

export type UpdateCustomDiscountForCartResponse =
  UpdateCustomDiscountForCartResponses[keyof UpdateCustomDiscountForCartResponses]

export type AddCustomDiscountToCartItemData = {
  body?: CartsCustomDiscountsObject
  path: {
    /**
     * Specifies the ID for the cart.
     */
    cartID: string
    /**
     * Specifies the unique identifier for the cart item.
     */
    cartitemID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/items/{cartitemID}/custom-discounts"
}

export type AddCustomDiscountToCartItemErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
  /**
   * Bad Request
   */
  422: ResponseErrorResponse
}

export type AddCustomDiscountToCartItemError =
  AddCustomDiscountToCartItemErrors[keyof AddCustomDiscountToCartItemErrors]

export type AddCustomDiscountToCartItemResponses = {
  /**
   * Successful request
   */
  201:
    | CartsCustomDiscountsCollectionResponse
    | CartsCustomDiscountsEntityResponse
}

export type AddCustomDiscountToCartItemResponse =
  AddCustomDiscountToCartItemResponses[keyof AddCustomDiscountToCartItemResponses]

export type DeleteCustomDiscountFromCartItemData = {
  body?: never
  path: {
    /**
     * Specifies the ID for the cart.
     */
    cartID: string
    /**
     * Specifies the ID for the cart item.
     */
    cartitemID: string
    /**
     * Specifies the ID for the custom discount to be deleted.
     */
    customdiscountID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/items/{cartitemID}/custom-discounts/{customdiscountID}"
}

export type DeleteCustomDiscountFromCartItemResponses = {
  /**
   * No Content
   */
  204: void
}

export type DeleteCustomDiscountFromCartItemResponse =
  DeleteCustomDiscountFromCartItemResponses[keyof DeleteCustomDiscountFromCartItemResponses]

export type UpdateCustomDiscountForCartItemData = {
  body?: CartsCustomDiscountsEntityRequest
  path: {
    /**
     * Specifies the ID for the cart.
     */
    cartID: string
    /**
     * Specifies the ID for the cart item.
     */
    cartitemID: string
    /**
     * Specifies the ID for the custom discount to be updated.
     */
    customdiscountID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/items/{cartitemID}/custom-discounts/{customdiscountID}"
}

export type UpdateCustomDiscountForCartItemResponses = {
  200: CartsCustomDiscountsEntityResponse
}

export type UpdateCustomDiscountForCartItemResponse =
  UpdateCustomDiscountForCartItemResponses[keyof UpdateCustomDiscountForCartItemResponses]

export type GetShippingGroupsData = {
  body?: never
  path: {
    /**
     * The ID of the cart
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/shipping-groups"
}

export type GetShippingGroupsErrors = {
  /**
   * Cart not found
   */
  404: ResponseErrorResponse
}

export type GetShippingGroupsError =
  GetShippingGroupsErrors[keyof GetShippingGroupsErrors]

export type GetShippingGroupsResponses = {
  /**
   * A list of shipping groups
   */
  200: {
    data?: Array<ShippingGroupResponse>
  }
}

export type GetShippingGroupsResponse =
  GetShippingGroupsResponses[keyof GetShippingGroupsResponses]

export type CreateShippingGroupData = {
  body: CreateShippingGroupRequest
  path: {
    /**
     * The ID of the cart
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/shipping-groups"
}

export type CreateShippingGroupErrors = {
  /**
   * Invalid request
   */
  400: ResponseErrorResponse
  /**
   * Cart not found
   */
  404: ResponseErrorResponse
}

export type CreateShippingGroupError =
  CreateShippingGroupErrors[keyof CreateShippingGroupErrors]

export type CreateShippingGroupResponses = {
  /**
   * Shipping group created successfully
   */
  201: ShippingGroupResponse
}

export type CreateShippingGroupResponse =
  CreateShippingGroupResponses[keyof CreateShippingGroupResponses]

export type DeleteCartShippingGroupData = {
  body?: never
  path: {
    /**
     * The ID of the cart
     */
    cartId: string
    /**
     * The ID of the shipping group to delete
     */
    shippingGroupId: string
  }
  query?: never
  url: "/v2/carts/{cartId}/shipping-groups/{shippingGroupId}"
}

export type DeleteCartShippingGroupErrors = {
  /**
   * Cannot delete shipping group that is attached to cart items
   */
  400: ResponseErrorResponse
  /**
   * Cart or shipping group not found
   */
  404: ResponseErrorResponse
}

export type DeleteCartShippingGroupError =
  DeleteCartShippingGroupErrors[keyof DeleteCartShippingGroupErrors]

export type DeleteCartShippingGroupResponses = {
  /**
   * Successfully deleted the shipping group
   */
  204: void
}

export type DeleteCartShippingGroupResponse =
  DeleteCartShippingGroupResponses[keyof DeleteCartShippingGroupResponses]

export type GetShippingGroupByIdData = {
  body?: never
  path: {
    /**
     * The ID of the cart
     */
    cartId: string
    /**
     * The ID of the shipping group
     */
    shippingGroupId: string
  }
  query?: never
  url: "/v2/carts/{cartId}/shipping-groups/{shippingGroupId}"
}

export type GetShippingGroupByIdErrors = {
  /**
   * Shipping group or cart not found
   */
  404: ResponseErrorResponse
}

export type GetShippingGroupByIdError =
  GetShippingGroupByIdErrors[keyof GetShippingGroupByIdErrors]

export type GetShippingGroupByIdResponses = {
  /**
   * Shipping group details
   */
  200: {
    data?: ShippingGroupResponse
  }
}

export type GetShippingGroupByIdResponse =
  GetShippingGroupByIdResponses[keyof GetShippingGroupByIdResponses]

export type UpdateShippingGroupData = {
  body: UpdateCartShippingGroupRequest
  path: {
    /**
     * The ID of the cart
     */
    cartId: string
    /**
     * The ID of the shipping group
     */
    shippingGroupId: string
  }
  query?: never
  url: "/v2/carts/{cartId}/shipping-groups/{shippingGroupId}"
}

export type UpdateShippingGroupErrors = {
  /**
   * Invalid request
   */
  400: ResponseErrorResponse
  /**
   * Shipping group or cart not found
   */
  404: ResponseErrorResponse
}

export type UpdateShippingGroupError =
  UpdateShippingGroupErrors[keyof UpdateShippingGroupErrors]

export type UpdateShippingGroupResponses = {
  /**
   * Shipping group updated successfully
   */
  200: ShippingGroupResponse
}

export type UpdateShippingGroupResponse =
  UpdateShippingGroupResponses[keyof UpdateShippingGroupResponses]

export type CreateCartPaymentIntentData = {
  body?: ElasticPathPaymentsPoweredByStripePayment
  path: {
    /**
     * The universally unique identifier of the cart for which you want to create a payment intent.
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/payments"
}

export type CreateCartPaymentIntentResponses = {
  /**
   * Payment Intent created successfully.
   */
  201: CartResponse
}

export type CreateCartPaymentIntentResponse =
  CreateCartPaymentIntentResponses[keyof CreateCartPaymentIntentResponses]

export type UpdateCartPaymentIntentData = {
  body: CartPaymentUpdate
  path: {
    /**
     * The unique identifier of the cart.
     */
    cartID: string
    /**
     * The unique identifier of the payment intent.
     */
    paymentIntentID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/payments/{paymentIntentID}"
}

export type UpdateCartPaymentIntentResponses = {
  /**
   * Payment updated successfully
   */
  200: CartResponse
}

export type UpdateCartPaymentIntentResponse =
  UpdateCartPaymentIntentResponses[keyof UpdateCartPaymentIntentResponses]

export type CheckoutApiData = {
  body?: CustomerCheckout | AccountCheckout
  headers?: {
    /**
     * An account management authentication token that identifies the authenticated account member.
     */
    "EP-Account-Management-Authentication-Token"?: string
  }
  path: {
    /**
     * The ID of the cart that you want to checkout.
     */
    cartID: string
  }
  query?: never
  url: "/v2/carts/{cartID}/checkout"
}

export type CheckoutApiErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
  /**
   * Internal Server Error
   */
  500: ResponseErrorResponse
}

export type CheckoutApiError = CheckoutApiErrors[keyof CheckoutApiErrors]

export type CheckoutApiResponses = {
  /**
   * OK
   */
  201: OrderEntityResponse
}

export type CheckoutApiResponse =
  CheckoutApiResponses[keyof CheckoutApiResponses]

export type GetCustomerOrdersData = {
  body?: never
  headers?: {
    /**
     * A customer token to access a specific customer's orders.
     */
    "x-moltin-customer-token"?: string
  }
  path?: never
  query?: never
  url: "/v2/orders"
}

export type GetCustomerOrdersResponses = {
  200: OrderCollectionResponse
}

export type GetCustomerOrdersResponse =
  GetCustomerOrdersResponses[keyof GetCustomerOrdersResponses]

export type GetAnOrderData = {
  body?: never
  path: {
    /**
     * The ID of the order.
     */
    orderID: string
  }
  query?: never
  url: "/v2/orders/{orderID}"
}

export type GetAnOrderErrors = {
  /**
   * Not Found
   */
  404: ResponseErrorResponse
}

export type GetAnOrderError = GetAnOrderErrors[keyof GetAnOrderErrors]

export type GetAnOrderResponses = {
  /**
   * OK
   */
  200: OrderEntityResponse
}

export type GetAnOrderResponse = GetAnOrderResponses[keyof GetAnOrderResponses]

export type UpdateAnOrderData = {
  body?: OrdersUpdateRequest
  path: {
    /**
     * The unique identifier of the order.
     */
    orderID: string
  }
  query?: never
  url: "/v2/orders/{orderID}"
}

export type UpdateAnOrderErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
  /**
   * Unprocessable Entity
   */
  422: ResponseErrorResponse
}

export type UpdateAnOrderError = UpdateAnOrderErrors[keyof UpdateAnOrderErrors]

export type UpdateAnOrderResponses = {
  /**
   * OK
   */
  200: OrderEntityResponse
}

export type UpdateAnOrderResponse =
  UpdateAnOrderResponses[keyof UpdateAnOrderResponses]

export type GetOrderItemsData = {
  body?: never
  path: {
    /**
     * The ID of the order.
     */
    orderID: string
  }
  query?: never
  url: "/v2/orders/{orderID}/items"
}

export type GetOrderItemsResponses = {
  200: OrderItemCollectionResponse
}

export type GetOrderItemsResponse =
  GetOrderItemsResponses[keyof GetOrderItemsResponses]

export type AnonymizeOrdersData = {
  body?: OrdersAnonymizeRequest & unknown
  path?: never
  query?: never
  url: "/v2/orders/anonymize"
}

export type AnonymizeOrdersErrors = {
  /**
   * Unprocessable Entity
   */
  422: ResponseErrorResponse
}

export type AnonymizeOrdersError =
  AnonymizeOrdersErrors[keyof AnonymizeOrdersErrors]

export type AnonymizeOrdersResponses = {
  /**
   * OK
   */
  200: OrdersListResponse
}

export type AnonymizeOrdersResponse =
  AnonymizeOrdersResponses[keyof AnonymizeOrdersResponses]

export type ConfirmOrderData = {
  body?: never
  path: {
    /**
     * The unique identifier of the order to confirm.
     */
    orderID: string
  }
  query?: never
  url: "/v2/orders/{orderID}/confirm"
}

export type ConfirmOrderErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
  /**
   * Not Found
   */
  404: ResponseErrorResponse
  /**
   * Unprocessable Entity
   */
  422: ResponseErrorResponse
}

export type ConfirmOrderError = ConfirmOrderErrors[keyof ConfirmOrderErrors]

export type ConfirmOrderResponses = {
  /**
   * Order confirmed successfully
   */
  200: OrderResponse
}

export type ConfirmOrderResponse =
  ConfirmOrderResponses[keyof ConfirmOrderResponses]

export type PaymentSetupData = {
  body?: PaymentsRequest
  path: {
    /**
     * The Universally Unique Identifier (UUID) of the order you want to pay for.
     */
    orderID: string
  }
  query?: never
  url: "/v2/orders/{orderID}/payments"
}

export type PaymentSetupErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
  /**
   * Conflict
   */
  409: ResponseErrorResponse
  /**
   * Unprocessable Entity
   */
  422: ResponseErrorResponse
}

export type PaymentSetupError = PaymentSetupErrors[keyof PaymentSetupErrors]

export type PaymentSetupResponses = {
  /**
   * OK
   */
  200: TransactionEntityResponse
}

export type PaymentSetupResponse =
  PaymentSetupResponses[keyof PaymentSetupResponses]

export type ConfirmPaymentData = {
  body?: OrdersTransactionsConfirmRequest
  path: {
    /**
     * The unique identifier of the order.
     */
    orderID: string
    /**
     * The unique identifier of the transaction.
     */
    transactionID: string
  }
  query?: never
  url: "/v2/orders/{orderID}/transactions/{transactionID}/confirm"
}

export type ConfirmPaymentErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
}

export type ConfirmPaymentError =
  ConfirmPaymentErrors[keyof ConfirmPaymentErrors]

export type ConfirmPaymentResponses = {
  200: TransactionEntityResponse
}

export type ConfirmPaymentResponse =
  ConfirmPaymentResponses[keyof ConfirmPaymentResponses]

export type CaptureATransactionData = {
  body?: OrdersTransactionsCaptureRequest
  path: {
    /**
     * The UUID of the order.
     */
    orderID: string
    /**
     * The UUID of the transaction to capture.
     */
    transactionID: string
  }
  query?: never
  url: "/v2/orders/{orderID}/transactions/{transactionID}/capture"
}

export type CaptureATransactionErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
}

export type CaptureATransactionError =
  CaptureATransactionErrors[keyof CaptureATransactionErrors]

export type CaptureATransactionResponses = {
  200: TransactionEntityResponse
}

export type CaptureATransactionResponse =
  CaptureATransactionResponses[keyof CaptureATransactionResponses]

export type RefundATransactionData = {
  body?: OrdersTransactionsRefundRequest
  path: {
    /**
     * The UUID of the order.
     */
    orderID: string
    /**
     * The UUID of the transaction you want to refund.
     */
    transactionID: string
  }
  query?: never
  url: "/v2/orders/{orderID}/transactions/{transactionID}/refund"
}

export type RefundATransactionErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
  /**
   * Unprocessable Entity
   */
  422: ResponseErrorResponse
}

export type RefundATransactionError =
  RefundATransactionErrors[keyof RefundATransactionErrors]

export type RefundATransactionResponses = {
  200: TransactionEntityResponse
}

export type RefundATransactionResponse =
  RefundATransactionResponses[keyof RefundATransactionResponses]

export type GetOrderTransactionsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the order.
     */
    orderID: string
  }
  query?: never
  url: "/v2/orders/{orderID}/transactions"
}

export type GetOrderTransactionsErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
}

export type GetOrderTransactionsError =
  GetOrderTransactionsErrors[keyof GetOrderTransactionsErrors]

export type GetOrderTransactionsResponses = {
  200: TransactionListResponse
}

export type GetOrderTransactionsResponse =
  GetOrderTransactionsResponses[keyof GetOrderTransactionsResponses]

export type GetATransactionData = {
  body?: never
  path: {
    /**
     * The unique identifier of the order that you require transactions for.
     */
    orderID: string
    /**
     * The unique identifier of the transaction.
     */
    transactionID: string
  }
  query?: never
  url: "/v2/orders/{orderID}/transactions/{transactionID}"
}

export type GetATransactionResponses = {
  200: ResponseData & {
    data?: TransactionResponse
  }
}

export type GetATransactionResponse =
  GetATransactionResponses[keyof GetATransactionResponses]

export type CancelATransactionData = {
  body?: OrdersTransactionsCancelRequest
  path: {
    /**
     * The unique identifier of the order.
     */
    orderID: string
    /**
     * The unique identifier of the transaction to be canceled or voided.
     */
    transactionID: string
  }
  query?: never
  url: "/v2/orders/{orderID}/transactions/{transactionID}/cancel"
}

export type CancelATransactionErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
}

export type CancelATransactionError =
  CancelATransactionErrors[keyof CancelATransactionErrors]

export type CancelATransactionResponses = {
  200: TransactionEntityResponse
}

export type CancelATransactionResponse =
  CancelATransactionResponses[keyof CancelATransactionResponses]

export type GetOrderShippingGroupsData = {
  body?: never
  path: {
    /**
     * The ID of the order
     */
    orderID: string
  }
  query?: never
  url: "/v2/orders/{orderID}/shipping-groups"
}

export type GetOrderShippingGroupsErrors = {
  /**
   * Order not found
   */
  404: ResponseErrorResponse
}

export type GetOrderShippingGroupsError =
  GetOrderShippingGroupsErrors[keyof GetOrderShippingGroupsErrors]

export type GetOrderShippingGroupsResponses = {
  /**
   * A list of shipping groups
   */
  200: {
    data?: Array<ShippingGroupResponse>
  }
}

export type GetOrderShippingGroupsResponse =
  GetOrderShippingGroupsResponses[keyof GetOrderShippingGroupsResponses]

export type CreateOrderShippingGroupData = {
  /**
   * Shipping group details
   */
  body?: {
    data?: {
      type: "shipping_group"
      /**
       * The shipping type for this group
       */
      shipping_type?: string
      /**
       * Tracking reference for the shipment
       */
      tracking_reference?: string
      address?: {
        first_name?: string
        last_name?: string
        phone_number?: string
        company_name?: string
        line_1?: string
        line_2?: string
        city?: string
        postcode?: string
        county?: string
        country?: string
        region?: string
        instructions?: string
      }
      delivery_estimate?: {
        start?: Date
        end?: Date
      }
    }
  }
  path: {
    /**
     * The ID of the order
     */
    orderID: string
  }
  query?: never
  url: "/v2/orders/{orderID}/shipping-groups"
}

export type CreateOrderShippingGroupErrors = {
  /**
   * Bad Request
   */
  400: ResponseErrorResponse
  /**
   * Order not found
   */
  404: ResponseErrorResponse
  /**
   * Unprocessable Entity
   */
  422: ResponseErrorResponse
}

export type CreateOrderShippingGroupError =
  CreateOrderShippingGroupErrors[keyof CreateOrderShippingGroupErrors]

export type CreateOrderShippingGroupResponses = {
  /**
   * Shipping group created
   */
  201: {
    data?: ShippingGroupResponse
  }
}

export type CreateOrderShippingGroupResponse =
  CreateOrderShippingGroupResponses[keyof CreateOrderShippingGroupResponses]

export type GetShippingGroupsByIdData = {
  body?: never
  path: {
    /**
     * The ID of the order
     */
    orderID: string
    /**
     * The ID of the shipping group
     */
    shippingGroupID: string
  }
  query?: never
  url: "/v2/orders/{orderID}/shipping-groups/{shippingGroupID}"
}

export type GetShippingGroupsByIdErrors = {
  /**
   * Shipping group or order not found
   */
  404: ResponseErrorResponse
}

export type GetShippingGroupsByIdError =
  GetShippingGroupsByIdErrors[keyof GetShippingGroupsByIdErrors]

export type GetShippingGroupsByIdResponses = {
  /**
   * Shipping group details
   */
  200: {
    data?: ShippingGroupResponse
  }
}

export type GetShippingGroupsByIdResponse =
  GetShippingGroupsByIdResponses[keyof GetShippingGroupsByIdResponses]

export type PutShippingGroupByIdData = {
  body: UpdateOrderShippingGroupRequest
  path: {
    /**
     * The ID of the order
     */
    orderID: string
    /**
     * The ID of the shipping group
     */
    shippingGroupID: string
  }
  query?: never
  url: "/v2/orders/{orderID}/shipping-groups/{shippingGroupID}"
}

export type PutShippingGroupByIdErrors = {
  /**
   * Invalid request
   */
  400: ResponseErrorResponse
  /**
   * Shipping group or order not found
   */
  404: ResponseErrorResponse
}

export type PutShippingGroupByIdError =
  PutShippingGroupByIdErrors[keyof PutShippingGroupByIdErrors]

export type PutShippingGroupByIdResponses = {
  /**
   * Shipping group updated successfully
   */
  200: ShippingGroupResponse
}

export type PutShippingGroupByIdResponse =
  PutShippingGroupByIdResponses[keyof PutShippingGroupByIdResponses]

export type ListOfferingsData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
     */
    include?: Array<"plans" | "pricing_options" | "features">
  }
  url: "/v2/subscriptions/offerings"
}

export type ListOfferingsErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type ListOfferingsError = ListOfferingsErrors[keyof ListOfferingsErrors]

export type ListOfferingsResponses = {
  /**
   * Success. A list of offerings is returned.
   */
  200: {
    data?: Array<Offering>
    included?: OfferingIncludes
    links?: Links2
  }
}

export type ListOfferingsResponse =
  ListOfferingsResponses[keyof ListOfferingsResponses]

export type GetOfferingData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: SubscriptionsUuid
  }
  query?: {
    /**
     * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
     */
    include?: Array<"plans" | "pricing_options" | "features">
  }
  url: "/v2/subscriptions/offerings/{offering_uuid}"
}

export type GetOfferingErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: SubscriptionsErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type GetOfferingError = GetOfferingErrors[keyof GetOfferingErrors]

export type GetOfferingResponses = {
  /**
   * Success. The details of the subscription offering are returned.
   */
  200: {
    data?: Offering
    included?: OfferingIncludes
  }
}

export type GetOfferingResponse =
  GetOfferingResponses[keyof GetOfferingResponses]

export type ListOfferingPricingOptionsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: SubscriptionsUuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/v2/subscriptions/offerings/{offering_uuid}/pricing-options"
}

export type ListOfferingPricingOptionsErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type ListOfferingPricingOptionsError =
  ListOfferingPricingOptionsErrors[keyof ListOfferingPricingOptionsErrors]

export type ListOfferingPricingOptionsResponses = {
  /**
   * Success. A list of pricing options attached with the offering is returned.
   */
  200: {
    data?: Array<OfferingPricingOption>
    links?: Links2
  }
}

export type ListOfferingPricingOptionsResponse =
  ListOfferingPricingOptionsResponses[keyof ListOfferingPricingOptionsResponses]

export type ListOfferingFeaturesData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: SubscriptionsUuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/v2/subscriptions/offerings/{offering_uuid}/features"
}

export type ListOfferingFeaturesErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type ListOfferingFeaturesError =
  ListOfferingFeaturesErrors[keyof ListOfferingFeaturesErrors]

export type ListOfferingFeaturesResponses = {
  /**
   * Success. A list of subscription features attached to the offering is returned.
   */
  200: {
    data?: Array<OfferingFeature>
    links?: Links2
  }
}

export type ListOfferingFeaturesResponse =
  ListOfferingFeaturesResponses[keyof ListOfferingFeaturesResponses]

export type ListOfferingPlansData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: SubscriptionsUuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/v2/subscriptions/offerings/{offering_uuid}/plans"
}

export type ListOfferingPlansErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type ListOfferingPlansError =
  ListOfferingPlansErrors[keyof ListOfferingPlansErrors]

export type ListOfferingPlansResponses = {
  /**
   * Success. A list of subscription plans attached to the offering is returned.
   */
  200: {
    data?: Array<OfferingPlan>
    links?: Links2
  }
}

export type ListOfferingPlansResponse =
  ListOfferingPlansResponses[keyof ListOfferingPlansResponses]

export type ListOfferingPlanPricingOptionsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the offering.
     */
    offering_uuid: SubscriptionsUuid
    /**
     * The unique identifier of the plan.
     */
    plan_uuid: SubscriptionsUuid
  }
  query?: never
  url: "/v2/subscriptions/offerings/{offering_uuid}/plans/{plan_uuid}/relationships/pricing_options"
}

export type ListOfferingPlanPricingOptionsErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type ListOfferingPlanPricingOptionsError =
  ListOfferingPlanPricingOptionsErrors[keyof ListOfferingPlanPricingOptionsErrors]

export type ListOfferingPlanPricingOptionsResponses = {
  /**
   * Success. The pricing option relationships are returned
   */
  200: {
    data?: Array<RelationshipData>
  }
}

export type ListOfferingPlanPricingOptionsResponse =
  ListOfferingPlanPricingOptionsResponses[keyof ListOfferingPlanPricingOptionsResponses]

export type ListSubscriptionsData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
    /**
     * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
     */
    include?: Array<"plans" | "pricing_options">
  }
  url: "/v2/subscriptions/subscriptions"
}

export type ListSubscriptionsErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type ListSubscriptionsError =
  ListSubscriptionsErrors[keyof ListSubscriptionsErrors]

export type ListSubscriptionsResponses = {
  /**
   * Success. A list of subscriptions is returned.
   */
  200: {
    data?: Array<Subscription>
    included?: SubscriptionIncludes
    links?: Links2
  }
}

export type ListSubscriptionsResponse =
  ListSubscriptionsResponses[keyof ListSubscriptionsResponses]

export type GetSubscriptionData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: SubscriptionsUuid
  }
  query?: {
    /**
     * A comma-separated list of resources to include. See [Characteristics of Include Parameter](/guides/Getting-Started/includes#characteristics-of-include-parameter).
     */
    include?: Array<"plans" | "pricing_options">
  }
  url: "/v2/subscriptions/subscriptions/{subscription_uuid}"
}

export type GetSubscriptionErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: SubscriptionsErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type GetSubscriptionError =
  GetSubscriptionErrors[keyof GetSubscriptionErrors]

export type GetSubscriptionResponses = {
  /**
   * Success. The details of a subscription are returned.
   */
  200: {
    data?: Subscription
    included?: SubscriptionIncludes
  }
}

export type GetSubscriptionResponse =
  GetSubscriptionResponses[keyof GetSubscriptionResponses]

export type ListSubscriptionPlansData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: SubscriptionsUuid
  }
  query?: never
  url: "/v2/subscriptions/subscriptions/{subscription_uuid}/plans"
}

export type ListSubscriptionPlansErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: SubscriptionsErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type ListSubscriptionPlansError =
  ListSubscriptionPlansErrors[keyof ListSubscriptionPlansErrors]

export type ListSubscriptionPlansResponses = {
  /**
   * Success. A list of subscription plans is returned.
   */
  200: {
    data?: Array<OfferingPlan>
  }
}

export type ListSubscriptionPlansResponse =
  ListSubscriptionPlansResponses[keyof ListSubscriptionPlansResponses]

export type ListSubscriptionPricingOptionsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: SubscriptionsUuid
  }
  query?: never
  url: "/v2/subscriptions/subscriptions/{subscription_uuid}/pricing-options"
}

export type ListSubscriptionPricingOptionsErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: SubscriptionsErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type ListSubscriptionPricingOptionsError =
  ListSubscriptionPricingOptionsErrors[keyof ListSubscriptionPricingOptionsErrors]

export type ListSubscriptionPricingOptionsResponses = {
  /**
   * Success. A list of subscription pricing options is returned.
   */
  200: {
    data?: Array<OfferingPricingOption>
  }
}

export type ListSubscriptionPricingOptionsResponse =
  ListSubscriptionPricingOptionsResponses[keyof ListSubscriptionPricingOptionsResponses]

export type ListSubscriptionStatesData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: SubscriptionsUuid
  }
  query?: never
  url: "/v2/subscriptions/subscriptions/{subscription_uuid}/states"
}

export type ListSubscriptionStatesErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: SubscriptionsErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type ListSubscriptionStatesError =
  ListSubscriptionStatesErrors[keyof ListSubscriptionStatesErrors]

export type ListSubscriptionStatesResponses = {
  /**
   * Success. A list of subscription states is returned.
   */
  200: {
    data?: Array<SubscriptionState>
  }
}

export type ListSubscriptionStatesResponse =
  ListSubscriptionStatesResponses[keyof ListSubscriptionStatesResponses]

export type CreateSubscriptionStateData = {
  body?: {
    data: ChangeState
  }
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: SubscriptionsUuid
  }
  query?: never
  url: "/v2/subscriptions/subscriptions/{subscription_uuid}/states"
}

export type CreateSubscriptionStateErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: SubscriptionsErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type CreateSubscriptionStateError =
  CreateSubscriptionStateErrors[keyof CreateSubscriptionStateErrors]

export type CreateSubscriptionStateResponses = {
  /**
   * Success. The subscription's state has changed.
   */
  204: void
}

export type CreateSubscriptionStateResponse =
  CreateSubscriptionStateResponses[keyof CreateSubscriptionStateResponses]

export type GetSubscriptionStateData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: SubscriptionsUuid
    /**
     * The unique identifier of the subscription state.
     */
    state_uuid: SubscriptionsUuid
  }
  query?: never
  url: "/v2/subscriptions/subscriptions/{subscription_uuid}/states/{state_uuid}"
}

export type GetSubscriptionStateErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: SubscriptionsErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type GetSubscriptionStateError =
  GetSubscriptionStateErrors[keyof GetSubscriptionStateErrors]

export type GetSubscriptionStateResponses = {
  /**
   * Success. A subscription state is returned.
   */
  200: {
    data?: SubscriptionState
  }
}

export type GetSubscriptionStateResponse =
  GetSubscriptionStateResponses[keyof GetSubscriptionStateResponses]

export type ListSubscriptionInvoicesData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: SubscriptionsUuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/v2/subscriptions/subscriptions/{subscription_uuid}/invoices"
}

export type ListSubscriptionInvoicesErrors = {
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type ListSubscriptionInvoicesError =
  ListSubscriptionInvoicesErrors[keyof ListSubscriptionInvoicesErrors]

export type ListSubscriptionInvoicesResponses = {
  /**
   * Success. A list of invoices is returned.
   */
  200: {
    data?: Array<SubscriptionInvoice>
    links?: Links2
  }
}

export type ListSubscriptionInvoicesResponse =
  ListSubscriptionInvoicesResponses[keyof ListSubscriptionInvoicesResponses]

export type ListSubscriptionInvoicePaymentsData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: SubscriptionsUuid
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: SubscriptionsUuid
  }
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/v2/subscriptions/subscriptions/{subscription_uuid}/invoices/{invoice_uuid}/payments"
}

export type ListSubscriptionInvoicePaymentsResponses = {
  /**
   * Success. Payments for the invoice are returned.
   */
  200: {
    data?: Array<SubscriptionInvoicePayment>
    links?: Links2
  }
}

export type ListSubscriptionInvoicePaymentsResponse =
  ListSubscriptionInvoicePaymentsResponses[keyof ListSubscriptionInvoicePaymentsResponses]

export type GetSubscriptionInvoicePaymentData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: SubscriptionsUuid
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: SubscriptionsUuid
    /**
     * The unique identifier of the payment.
     */
    payment_uuid: SubscriptionsUuid
  }
  query?: never
  url: "/v2/subscriptions/subscriptions/{subscription_uuid}/invoices/{invoice_uuid}/payments/{payment_uuid}"
}

export type GetSubscriptionInvoicePaymentErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: SubscriptionsErrorResponse
}

export type GetSubscriptionInvoicePaymentError =
  GetSubscriptionInvoicePaymentErrors[keyof GetSubscriptionInvoicePaymentErrors]

export type GetSubscriptionInvoicePaymentResponses = {
  /**
   * Success. Specific payment for the invoice is returned.
   */
  200: {
    data?: SubscriptionInvoicePayment
  }
}

export type GetSubscriptionInvoicePaymentResponse =
  GetSubscriptionInvoicePaymentResponses[keyof GetSubscriptionInvoicePaymentResponses]

export type GetSubscriptionInvoiceData = {
  body?: never
  path: {
    /**
     * The unique identifier of the subscription.
     */
    subscription_uuid: SubscriptionsUuid
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: SubscriptionsUuid
  }
  query?: never
  url: "/v2/subscriptions/subscriptions/{subscription_uuid}/invoices/{invoice_uuid}"
}

export type GetSubscriptionInvoiceErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type GetSubscriptionInvoiceError =
  GetSubscriptionInvoiceErrors[keyof GetSubscriptionInvoiceErrors]

export type GetSubscriptionInvoiceResponses = {
  /**
   * Success. An invoice is returned.
   */
  200: {
    data?: SubscriptionInvoice
  }
}

export type GetSubscriptionInvoiceResponse =
  GetSubscriptionInvoiceResponses[keyof GetSubscriptionInvoiceResponses]

export type ListInvoicesData = {
  body?: never
  path?: never
  query?: {
    /**
     * Some Subscriptions API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: BigInt
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the [page length](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: BigInt
  }
  url: "/v2/subscriptions/invoices"
}

export type ListInvoicesErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type ListInvoicesError = ListInvoicesErrors[keyof ListInvoicesErrors]

export type ListInvoicesResponses = {
  /**
   * Success. A list of invoices is returned.
   */
  200: {
    data?: Array<SubscriptionInvoice>
    links?: Links2
  }
}

export type ListInvoicesResponse =
  ListInvoicesResponses[keyof ListInvoicesResponses]

export type GetInvoiceData = {
  body?: never
  path: {
    /**
     * The unique identifier of the invoice.
     */
    invoice_uuid: SubscriptionsUuid
  }
  query?: never
  url: "/v2/subscriptions/invoices/{invoice_uuid}"
}

export type GetInvoiceErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: SubscriptionsErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type GetInvoiceError = GetInvoiceErrors[keyof GetInvoiceErrors]

export type GetInvoiceResponses = {
  /**
   * Success. The details of the invoice are returned.
   */
  200: {
    data?: SubscriptionInvoice
  }
}

export type GetInvoiceResponse = GetInvoiceResponses[keyof GetInvoiceResponses]

export type GetFeatureData = {
  body?: never
  path: {
    /**
     * The unique identifier of a feature.
     */
    feature_uuid: SubscriptionsUuid
  }
  query?: never
  url: "/v2/subscriptions/features/{feature_uuid}"
}

export type GetFeatureErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: SubscriptionsErrorResponse
  /**
   * Not found. The requested entity does not exist.
   */
  404: SubscriptionsErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: SubscriptionsErrorResponse
}

export type GetFeatureError = GetFeatureErrors[keyof GetFeatureErrors]

export type GetFeatureResponses = {
  /**
   * Success. The feature details are returned.
   */
  200: {
    data?: Feature
  }
}

export type GetFeatureResponse = GetFeatureResponses[keyof GetFeatureResponses]

export type GetStockData = {
  body?: never
  path: {
    /**
     * The unique identifier of the product.
     */
    product_uuid: InventoriesUuid
  }
  query?: never
  url: "/v2/inventories/{product_uuid}"
}

export type GetStockErrors = {
  /**
   * Not found. The requested entity does not exist.
   */
  404: InventoriesErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: InventoriesErrorResponse
}

export type GetStockError = GetStockErrors[keyof GetStockErrors]

export type GetStockResponses = {
  /**
   * Success. Returns the stock for the given product UUID
   */
  200: {
    data: StockResponse
  }
}

export type GetStockResponse = GetStockResponses[keyof GetStockResponses]

export type ListLocationsData = {
  body?: never
  path?: never
  query?: {
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [**page length**](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: number
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the the [**page length**](https://elasticpath.dev/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: number
    /**
     * Some Inventories API endpoints support filtering. For the general syntax, see [**Filtering**](/guides/Getting-Started/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
     *
     */
    filter?: string
  }
  url: "/v2/inventories/locations"
}

export type ListLocationsErrors = {
  /**
   * Bad request. The request failed validation.
   */
  400: InventoriesErrorResponse
}

export type ListLocationsError = ListLocationsErrors[keyof ListLocationsErrors]

export type ListLocationsResponses = {
  /**
   * Success. A list of locations is returned
   */
  200: {
    data?: Array<Location>
    links?: Links2
  }
}

export type ListLocationsResponse =
  ListLocationsResponses[keyof ListLocationsResponses]

export type CreateAnAccessTokenData = {
  body?: AccessTokenRequest
  path?: never
  query?: never
  url: "/oauth/access_token"
}

export type CreateAnAccessTokenErrors = {
  /**
   * Bad Request
   */
  400: ErrorResponse2
  /**
   * Unauthorized
   */
  401: ErrorResponse2
  /**
   * Internal server error. There was a system failure in the platform.
   */
  default: ErrorResponse2
}

export type CreateAnAccessTokenError =
  CreateAnAccessTokenErrors[keyof CreateAnAccessTokenErrors]

export type CreateAnAccessTokenResponses = {
  /**
   * OK
   */
  200: AccessTokenResponse
}

export type CreateAnAccessTokenResponse =
  CreateAnAccessTokenResponses[keyof CreateAnAccessTokenResponses]

export type GetV2AccountAddressesData = {
  body?: never
  path: {
    /**
     * The ID of the account you want to retrieve.
     */
    accountID: string
  }
  query?: never
  url: "/v2/accounts/{accountID}/addresses"
}

export type GetV2AccountAddressesErrors = {
  /**
   * Not Found
   */
  404: AccountAddressesErrorResponse
}

export type GetV2AccountAddressesError =
  GetV2AccountAddressesErrors[keyof GetV2AccountAddressesErrors]

export type GetV2AccountAddressesResponses = {
  /**
   * OK
   */
  200: {
    data?: Array<AccountAddressResponse>
  }
}

export type GetV2AccountAddressesResponse =
  GetV2AccountAddressesResponses[keyof GetV2AccountAddressesResponses]

export type PostV2AccountAddressData = {
  body?: {
    data: Address
  }
  path: {
    /**
     * The ID of the account you want to create an address for.
     */
    accountID: string
  }
  query?: never
  url: "/v2/accounts/{accountID}/addresses"
}

export type PostV2AccountAddressErrors = {
  /**
   * Bad Request
   */
  400: AccountAddressesErrorResponse
  /**
   * Not Found
   */
  404: AccountAddressesErrorResponse
}

export type PostV2AccountAddressError =
  PostV2AccountAddressErrors[keyof PostV2AccountAddressErrors]

export type PostV2AccountAddressResponses = {
  /**
   * OK
   */
  200: {
    data?: AccountAddressResponse
  }
}

export type PostV2AccountAddressResponse =
  PostV2AccountAddressResponses[keyof PostV2AccountAddressResponses]

export type DeleteV2AccountAddressData = {
  body?: never
  path: {
    /**
     * The ID of the account that contains the address to delete.
     */
    accountID: string
    /**
     * The ID of the address to delete.
     */
    addressID: string
  }
  query?: never
  url: "/v2/accounts/{accountID}/addresses/{addressID}"
}

export type DeleteV2AccountAddressErrors = {
  /**
   * Not Found
   */
  404: AccountAddressesErrorResponse
}

export type DeleteV2AccountAddressError =
  DeleteV2AccountAddressErrors[keyof DeleteV2AccountAddressErrors]

export type DeleteV2AccountAddressResponses = {
  /**
   * No Content
   */
  204: void
}

export type DeleteV2AccountAddressResponse =
  DeleteV2AccountAddressResponses[keyof DeleteV2AccountAddressResponses]

export type GetV2AccountAddressData = {
  body?: never
  path: {
    /**
     * The ID of the account you want to retrieve.
     */
    accountID: string
    /**
     * The ID of the address you want to retrieve.
     */
    addressID: string
  }
  query?: never
  url: "/v2/accounts/{accountID}/addresses/{addressID}"
}

export type GetV2AccountAddressErrors = {
  /**
   * Not Found
   */
  404: AccountAddressesErrorResponse
}

export type GetV2AccountAddressError =
  GetV2AccountAddressErrors[keyof GetV2AccountAddressErrors]

export type GetV2AccountAddressResponses = {
  /**
   * OK
   */
  200: {
    data?: AccountAddressResponse
  }
}

export type GetV2AccountAddressResponse =
  GetV2AccountAddressResponses[keyof GetV2AccountAddressResponses]

export type PutV2AccountAddressData = {
  body?: {
    data: Address
  }
  path: {
    /**
     * The ID of the account you want to create an address for.
     */
    accountID: string
    /**
     * The ID of the address you want to update.
     */
    addressID: string
  }
  query?: never
  url: "/v2/accounts/{accountID}/addresses/{addressID}"
}

export type PutV2AccountAddressErrors = {
  /**
   * Bad Request
   */
  400: AccountAddressesErrorResponse
  /**
   * Not Found
   */
  404: AccountAddressesErrorResponse
}

export type PutV2AccountAddressError =
  PutV2AccountAddressErrors[keyof PutV2AccountAddressErrors]

export type PutV2AccountAddressResponses = {
  /**
   * OK
   */
  200: {
    data?: AccountAddressResponse
  }
}

export type PutV2AccountAddressResponse =
  PutV2AccountAddressResponses[keyof PutV2AccountAddressResponses]

export type GetV2AccountsData = {
  body?: never
  path?: never
  query?: {
    /**
     * Specifies the filter attributes.
     */
    filter?: string
    /**
     * The number of records per page.
     */
    "page[limit]"?: BigInt
    /**
     * The number of records to offset the results by.
     */
    "page[offset]"?: BigInt
    /**
     * Supported attributes are `created_at`, `email`, `id`, `name`, or `updated_at`. When specified, the results are sorted in ascending order based on the value of the field. To sort in descending order, prefix the attribute with `-`, for example, `-updated_at`. The default sort order is `created_at` in descending order. For more information, see [Sorting](/guides/Getting-Started/sorting).
     */
    sort?: string
  }
  url: "/v2/accounts"
}

export type GetV2AccountsErrors = {
  /**
   * Unauthorized
   */
  401: AccountManagementErrorResponse
  /**
   * Internal server error.
   */
  default: AccountManagementErrorResponse
}

export type GetV2AccountsError = GetV2AccountsErrors[keyof GetV2AccountsErrors]

export type GetV2AccountsResponses = {
  /**
   * OK
   */
  200: {
    data?: Array<AccountResponse>
    meta?: MetaList
    links?: {
      /**
       * Always the current page.
       */
      current?: string
      /**
       * Always the first page.
       */
      first?: string
      /**
       * Always `null` if there is only one page.
       */
      last?: string
      /**
       * Always `null` if there is only one page.
       */
      next?: string
      /**
       * Always `null` if the user is on the first page.
       */
      prev?: string
    }
  }
}

export type GetV2AccountsResponse =
  GetV2AccountsResponses[keyof GetV2AccountsResponses]

export type PostV2AccountsData = {
  body?: {
    data: Account & WritableParentId
  }
  path?: never
  query?: never
  url: "/v2/accounts"
}

export type PostV2AccountsErrors = {
  /**
   * Bad Request
   */
  400: AccountManagementErrorResponse
  /**
   * Internal server error.
   */
  default: AccountManagementErrorResponse
}

export type PostV2AccountsError =
  PostV2AccountsErrors[keyof PostV2AccountsErrors]

export type PostV2AccountsResponses = {
  /**
   * Created
   */
  201: {
    data?: AccountResponse
  }
}

export type PostV2AccountsResponse =
  PostV2AccountsResponses[keyof PostV2AccountsResponses]

export type GetV2AccountsAccountIdData = {
  body?: never
  path: {
    /**
     * The ID of the account you want to retrieve.
     */
    accountID: string
  }
  query?: never
  url: "/v2/accounts/{accountID}"
}

export type GetV2AccountsAccountIdErrors = {
  /**
   * Not Found
   */
  404: AccountManagementErrorResponse
  /**
   * Internal server error.
   */
  default: AccountManagementErrorResponse
}

export type GetV2AccountsAccountIdError =
  GetV2AccountsAccountIdErrors[keyof GetV2AccountsAccountIdErrors]

export type GetV2AccountsAccountIdResponses = {
  /**
   * OK
   */
  200: {
    data?: AccountResponse
  }
}

export type GetV2AccountsAccountIdResponse =
  GetV2AccountsAccountIdResponses[keyof GetV2AccountsAccountIdResponses]

export type PutV2AccountsAccountIdData = {
  body?: {
    data: Account & ReadOnlyParentId
  }
  path: {
    /**
     * The ID of the account you want to retrieve.
     */
    accountID: string
  }
  query?: never
  url: "/v2/accounts/{accountID}"
}

export type PutV2AccountsAccountIdErrors = {
  /**
   * Bad Request
   */
  400: {
    errors?: Array<{
      detail?: string
      status?: string
      title?: string
    }>
  }
  /**
   * Not Found
   */
  404: {
    errors?: Array<{
      detail?: string
      status?: string
      title?: string
    }>
  }
  /**
   * Internal server error.
   */
  default: AccountManagementErrorResponse
}

export type PutV2AccountsAccountIdError =
  PutV2AccountsAccountIdErrors[keyof PutV2AccountsAccountIdErrors]

export type PutV2AccountsAccountIdResponses = {
  /**
   * OK
   */
  200: {
    data?: {
      /**
       * The unique identifier for an Account.
       */
      id?: string
      /**
       * The type of the object returned. Always use account.
       */
      type?: string
      /**
       * The name of the account.
       */
      name?: string
      /**
       * The legal name of the account.
       */
      legal_name?: string
      /**
       * The registration ID of the account. The maximum character limit for this field is 63.
       */
      registration_id?: string
      /**
       * The optional external ID reference. For example, this could be an external reference from a separate company system. The maximum length is 2048 characters. Default is null.
       */
      external_ref?: string
      meta?: {
        timestamps?: {
          /**
           * The date the account is created.
           */
          created_at?: Date
          /**
           * The date the account is last updated.
           */
          updated_at?: Date
        }
      }
      links?: {
        /**
         * A URL to the specific resource.
         */
        self?: string
      }
    }
  }
}

export type PutV2AccountsAccountIdResponse =
  PutV2AccountsAccountIdResponses[keyof PutV2AccountsAccountIdResponses]

export type GetV2AccountMembersData = {
  body?: never
  path?: never
  query?: {
    /**
     * The number of records per page.
     */
    "page[limit]"?: BigInt
    /**
     * The number of records to offset the results by.
     */
    "page[offset]"?: BigInt
    /**
     * Supported attributes are `created_at`, `email`, `id`, `name`, or `updated_at`. When specified, the results are sorted in ascending order based on the value of the field. To sort in descending order, prefix the attribute with `-`, for example, `-updated_at`. The default sort order is `created_at` in descending order. For more information, see [Sorting](/guides/Getting-Started/sorting).
     */
    sort?: string
    /**
     * Specifies the filter attributes.
     */
    filter?: string
  }
  url: "/v2/account-members"
}

export type GetV2AccountMembersErrors = {
  /**
   * Unauthorized
   */
  401: AccountManagementErrorResponse
  /**
   * Internal server error.
   */
  default: AccountManagementErrorResponse
}

export type GetV2AccountMembersError =
  GetV2AccountMembersErrors[keyof GetV2AccountMembersErrors]

export type GetV2AccountMembersResponses = {
  /**
   * OK
   */
  200: {
    data?: Array<AccountMemberResponse>
    meta?: MetaList
    links?: {
      /**
       * Always the current page.
       */
      current?: string
      /**
       * Always the first page.
       */
      first?: string
      /**
       * Always `null` if there is only one page.
       */
      last?: string
      /**
       * Always `null` if there is only one page.
       */
      next?: string
      /**
       * Always `null` if the user is on the first page.
       */
      prev?: string
    }
  }
}

export type GetV2AccountMembersResponse =
  GetV2AccountMembersResponses[keyof GetV2AccountMembersResponses]

export type GetV2AccountMembersAccountMemberIdData = {
  body?: never
  path: {
    /**
     * The unique identifier of the account member that you want to retrieve.
     */
    accountMemberID: string
  }
  query?: never
  url: "/v2/account-members/{accountMemberID}"
}

export type GetV2AccountMembersAccountMemberIdErrors = {
  /**
   * Not Found
   */
  404: AccountManagementErrorResponse
  /**
   * Internal server error.
   */
  default: AccountManagementErrorResponse
}

export type GetV2AccountMembersAccountMemberIdError =
  GetV2AccountMembersAccountMemberIdErrors[keyof GetV2AccountMembersAccountMemberIdErrors]

export type GetV2AccountMembersAccountMemberIdResponses = {
  /**
   * OK
   */
  200: {
    data?: AccountMemberResponse
  }
}

export type GetV2AccountMembersAccountMemberIdResponse =
  GetV2AccountMembersAccountMemberIdResponses[keyof GetV2AccountMembersAccountMemberIdResponses]

export type GetV2AccountsAccountIdAccountMembershipsData = {
  body?: never
  path: {
    /**
     * The ID of the account for which you want to get the list of unassigned account members.
     */
    accountID: string
  }
  query?: {
    /**
     * Specifies the filter attributes.
     */
    filter?: string
    /**
     * Supported attributes are `created_at`, `email`, `id`, `name`, or `updated_at`. When specified, the results are sorted in ascending order based on the value of the field. To sort in descending order, prefix the attribute with `-`, for example, `-updated_at`. The default sort order is `created_at` in descending order. For more information, see [Sorting](/guides/Getting-Started/sorting).
     */
    sort?: string
    /**
     * The number of records per page.
     */
    "page[limit]"?: BigInt
    /**
     * The number of records to offset the results by.
     */
    "page[offset]"?: BigInt
    /**
     * Parameter to retrieve more information about any related resources like account members.
     */
    include?: string
  }
  url: "/v2/accounts/{accountID}/account-memberships"
}

export type GetV2AccountsAccountIdAccountMembershipsErrors = {
  /**
   * Not Found
   */
  404: AccountManagementErrorResponse
  /**
   * Internal server error.
   */
  default: AccountManagementErrorResponse
}

export type GetV2AccountsAccountIdAccountMembershipsError =
  GetV2AccountsAccountIdAccountMembershipsErrors[keyof GetV2AccountsAccountIdAccountMembershipsErrors]

export type GetV2AccountsAccountIdAccountMembershipsResponses = {
  /**
   * OK
   */
  200: {
    data?: Array<AccountMembershipResponse>
    meta?: MetaList
    links?: {
      /**
       * Always the current page.
       */
      current?: string
      /**
       * Always the first page.
       */
      first?: string
      /**
       * Always `null` if there is only one page.
       */
      last?: string
      /**
       * Always `null` if there is only one page.
       */
      next?: string
      /**
       * Always `null` if the user is on the first page.
       */
      prev?: string
    }
  }
}

export type GetV2AccountsAccountIdAccountMembershipsResponse =
  GetV2AccountsAccountIdAccountMembershipsResponses[keyof GetV2AccountsAccountIdAccountMembershipsResponses]

export type PostV2AccountMembersTokensData = {
  body?: {
    data:
      | ({
          authentication_mechanism?: "oidc"
        } & OpenIdConnectRequest)
      | ({
          authentication_mechanism?: "password"
        } & PasswordRequest)
      | ({
          authentication_mechanism?: "passwordless"
        } & PasswordlessRequest)
      | ({
          authentication_mechanism?: "self_signup"
        } & SelfSignupRequest)
      | ({
          authentication_mechanism?: "account_management_authentication_token"
        } & SwitchingAccountRequest)
  }
  path?: never
  query?: never
  url: "/v2/account-members/tokens"
}

export type PostV2AccountMembersTokensErrors = {
  /**
   * Unauthorized
   */
  401: AccountManagementErrorResponse
  /**
   * Internal server error.
   */
  default: AccountManagementErrorResponse
}

export type PostV2AccountMembersTokensError =
  PostV2AccountMembersTokensErrors[keyof PostV2AccountMembersTokensErrors]

export type PostV2AccountMembersTokensResponses = {
  /**
   * Created
   */
  201: {
    data?: Array<AccountManagementAuthenticationTokenResponse>
    meta?: MetaList & {
      account_member_id?: MetaAccountMemberId
    }
    links?: {
      /**
       * Always the current page.
       */
      current?: string
      /**
       * Always the first page.
       */
      first?: string
      /**
       * Always `null` if there is only one page.
       */
      last?: string
      /**
       * Always `null` if there is only one page.
       */
      next?: string
      /**
       * Always `null` if the user is on the first page.
       */
      prev?: string
    }
  }
}

export type PostV2AccountMembersTokensResponse =
  PostV2AccountMembersTokensResponses[keyof PostV2AccountMembersTokensResponses]

export type CreateOneTimePasswordTokenRequestData = {
  /**
   * Request body for one-time password token.
   */
  body: OneTimePasswordTokenRequest
  path: {
    realmId: string
    passwordProfileId: string
  }
  query?: never
  url: "/v2/authentication-realms/{realmId}/password-profiles/{passwordProfileId}/one-time-password-token-request"
}

export type CreateOneTimePasswordTokenRequestResponses = {
  /**
   * One-time password token response.
   */
  202: unknown
}

export type UpdatePasswordProfileInfoData = {
  /**
   * The updated password profile info.
   */
  body: PasswordProfileInfoUpdateRequestWrapper
  path: {
    realmId: string
    userAuthenticationInfoId: string
    userAuthenticationPasswordProfileInfoId: string
  }
  query?: never
  url: "/v2/authentication-realms/{realmId}/user-authentication-info/{userAuthenticationInfoId}/user-authentication-password-profile-info/{userAuthenticationPasswordProfileInfoId}"
}

export type UpdatePasswordProfileInfoErrors = {
  /**
   * Password profile info not found.
   */
  404: unknown
}

export type UpdatePasswordProfileInfoResponses = {
  /**
   * Updated password profile info.
   */
  200: PasswordProfileInfoResponse
}

export type UpdatePasswordProfileInfoResponse =
  UpdatePasswordProfileInfoResponses[keyof UpdatePasswordProfileInfoResponses]

export type GetAllCurrenciesData = {
  body?: never
  path?: never
  query?: {
    /**
     * The number of records to offset the results by.
     */
    "page[offset]"?: string
    /**
     * The number of records per page.
     */
    "page[limit]"?: string
  }
  url: "/v2/currencies"
}

export type GetAllCurrenciesErrors = {
  /**
   * Unauthorized
   */
  401: ResponseError
}

export type GetAllCurrenciesError =
  GetAllCurrenciesErrors[keyof GetAllCurrenciesErrors]

export type GetAllCurrenciesResponses = {
  /**
   * OK
   */
  200: ResponseData & {
    data?: Array<ResponseCurrency>
  }
}

export type GetAllCurrenciesResponse =
  GetAllCurrenciesResponses[keyof GetAllCurrenciesResponses]

export type GetACurrencyData = {
  body?: never
  path: {
    /**
     * The ID for the requested currency.
     */
    currencyID: string
  }
  query?: never
  url: "/v2/currencies/{currencyID}"
}

export type GetACurrencyErrors = {
  /**
   * Unauthorized
   */
  401: ResponseError
}

export type GetACurrencyError = GetACurrencyErrors[keyof GetACurrencyErrors]

export type GetACurrencyResponses = {
  /**
   * OK
   */
  200: ResponseData & {
    data?: Array<ResponseCurrency>
  }
}

export type GetACurrencyResponse =
  GetACurrencyResponses[keyof GetACurrencyResponses]

export type GetAllFilesData = {
  body?: never
  path?: never
  query?: {
    /**
     *
     * Filtering is available for this endpoint. See [Filtering](/docs/api/pxm/files/get-all-files#filtering).
     *
     */
    filter?: string
    /**
     * The maximum number of records per page for this response. You can set this value up to 100. If no page size is set, the the [**page length**](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[limit]"?: string
    /**
     * The current offset by number of records, not pages. Offset is zero-based. The maximum records you can offset is 10,000. If no page size is set, the [**page length**](/docs/commerce-cloud/global-project-settings/settings-overview#page-length) store setting is used.
     */
    "page[offset]"?: string
  }
  url: "/v2/files"
}

export type GetAllFilesErrors = {
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: FilesErrorResponse
}

export type GetAllFilesError = GetAllFilesErrors[keyof GetAllFilesErrors]

export type GetAllFilesResponses = {
  /**
   * OK
   */
  200: {
    data?: Array<File>
    meta?: ResultsMeta
    links?: ResultsLinks
  }
}

export type GetAllFilesResponse =
  GetAllFilesResponses[keyof GetAllFilesResponses]

export type GetAFileData = {
  body?: never
  path: {
    /**
     * The unique identifier for a file.
     */
    fileID: string
  }
  query?: never
  url: "/v2/files/{fileID}"
}

export type GetAFileErrors = {
  /**
   * Forbidden. The operation is forbidden on this entity.
   */
  404: FilesErrorResponse
  /**
   * Internal server error. There was a system failure in the platform.
   */
  500: FilesErrorResponse
}

export type GetAFileError = GetAFileErrors[keyof GetAFileErrors]

export type GetAFileResponses = {
  200: {
    data?: File
  }
}

export type GetAFileResponse = GetAFileResponses[keyof GetAFileResponses]
