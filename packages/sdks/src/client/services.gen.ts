// This file is auto-generated by @hey-api/openapi-ts

import type { CancelablePromise } from './core/CancelablePromise';
import { OpenAPI } from './core/OpenAPI';
import { request as __request } from './core/request';
import type { GetAllJobsResponse, GetJobData, GetJobResponse, CancelJobData, CancelJobResponse, GetJobErrorsData, GetJobErrorsResponse, CreateProductData, CreateProductResponse, GetAllProductsData, GetAllProductsResponse, ImportProductsData, ImportProductsResponse, ExportProductsData, ExportProductsResponse, GetProductData, GetProductResponse, UpdateProductData, UpdateProductResponse, DeleteProductData, DeleteProductResponse, AttachNodesData, AttachNodesResponse, DetachNodesData, DetachNodesResponse, GetProductsNodesData, GetProductsNodesResponse, BuildChildProductsData, BuildChildProductsResponse, GetChildProductsData, GetChildProductsResponse, CreateProductTemplateRelationshipData, CreateProductTemplateRelationshipResponse, GetProductTemplateRelationshipsData, GetProductTemplateRelationshipsResponse, DeleteProductTemplateRelationshipData, DeleteProductTemplateRelationshipResponse, GetProductComponentProductsRelationshipsData, GetProductComponentProductsRelationshipsResponse, GetProductFileRelationshipsData, GetProductFileRelationshipsResponse, CreateProductFileRelationshipsData, CreateProductFileRelationshipsResponse, UpdateProductFileRelationshipsData, UpdateProductFileRelationshipsResponse, DeleteProductFileRelationshipsData, DeleteProductFileRelationshipsResponse, CreateProductVariationRelationshipsData, CreateProductVariationRelationshipsResponse, GetProductVariationRelationshipsData, GetProductVariationRelationshipsResponse, UpdateProductVariationRelationshipsData, UpdateProductVariationRelationshipsResponse, DeleteProductVariationRelationshipsData, DeleteProductVariationRelationshipsResponse, CreateProductMainImageRelationshipsData, CreateProductMainImageRelationshipsResponse, GetProductMainImageRelationshipsData, GetProductMainImageRelationshipsResponse, UpdateProductMainImageRelationshipsData, UpdateProductMainImageRelationshipsResponse, DeleteProductMainImageRelationshipsData, DeleteProductMainImageRelationshipsResponse, CreateVariationData, CreateVariationResponse, GetAllVariationsData, GetAllVariationsResponse, GetVariationData, GetVariationResponse, UpdateVariationData, UpdateVariationResponse, DeleteVariationData, DeleteVariationResponse, CreateVariationOptionData, CreateVariationOptionResponse, GetAllVariationOptionsData, GetAllVariationOptionsResponse, GetVariationOptionData, GetVariationOptionResponse, UpdateVariationOptionData, UpdateVariationOptionResponse, DeleteVariationOptionData, DeleteVariationOptionResponse, CreateModifierData, CreateModifierResponse, GetAllModifiersData, GetAllModifiersResponse, GetModifierData, GetModifierResponse, UpdateModifierData, UpdateModifierResponse, DeleteModifierData, DeleteModifierResponse, CreateHierarchyData, CreateHierarchyResponse, GetHierarchyData, GetHierarchyResponse, GetHierarchyChildData, GetHierarchyChildResponse, UpdateHierarchyData, UpdateHierarchyResponse, DeleteHierarchyData, DeleteHierarchyResponse, CreateNodeData, CreateNodeResponse, GetAllNodesInHierarchyData, GetAllNodesInHierarchyResponse, GetHierarchyNodeData, GetHierarchyNodeResponse, UpdateNodeData, UpdateNodeResponse, DeleteNodeData, DeleteNodeResponse, GetAllChildrenData, GetAllChildrenResponse, CreateNodeChildRelationshipsData, CreateNodeChildRelationshipsResponse, GetAllNodeChildrenData, GetAllNodeChildrenResponse, UpdateNodeParentData, UpdateNodeParentResponse, DeleteNodeParentData, DeleteNodeParentResponse, CreateNodeProductRelationshipData, CreateNodeProductRelationshipResponse, DeleteNodeProductRelationshipsData, DeleteNodeProductRelationshipsResponse, GetNodeProductsData, GetNodeProductsResponse, DuplicateHierarchyData, DuplicateHierarchyResponse, GetAllProductTagsResponse, GetProductTagData, GetProductTagResponse, CreateCustomRelationshipData, CreateCustomRelationshipResponse, UpdateCustomRelationshipData, UpdateCustomRelationshipResponse } from './types.gen';

/**
 * Get All Jobs
 * The jobs endpoints displays the status of a number of endpoints that function as jobs, for example, product import and export, price book import, building child products, and duplicating hierarchies.
 * @returns multi Returns all the jobs.
 * @throws ApiError
 */
export const getAllJobs = (): CancelablePromise<GetAllJobsResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/jobs',
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get a Job
 * @param data The data for the request.
 * @param data.jobId A unique identifier for the job.
 * @returns single Returns a job with the following attributes.
 * @throws ApiError
 */
export const getJob = (data: GetJobData): CancelablePromise<GetJobResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/jobs/{jobID}',
    path: {
        jobID: data.jobId
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Cancel a Job
 * The jobs endpoints display the status of a number of endpoints that function as jobs, for example, product import and export, and duplicating hierarchies.
 *
 * Jobs are processed one at a time. You can continue to send job requests, but those jobs are queued. In other words, Commerce looks for any jobs that have a status of PENDING and starts the job with the earliest created date. If you decide that a specific job needs to be prioritized over another, you can cancel the less critical job using the `Cancel a job` endpoint. You can only cancel jobs whose status is PENDING.
 *
 * @param data The data for the request.
 * @param data.jobId A unique identifier for the job.
 * @param data.requestBody
 * @returns single Successfully cancelled job
 * @throws ApiError
 */
export const cancelJob = (data: CancelJobData): CancelablePromise<CancelJobResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/jobs/{jobID}/cancel',
    path: {
        jobID: data.jobId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get Job Errors
 * @param data The data for the request.
 * @param data.jobId A unique identifier for the job.
 * @returns errors Successful
 * @throws ApiError
 */
export const getJobErrors = (data: GetJobErrorsData): CancelablePromise<GetJobErrorsResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/jobs/{jobID}/errors',
    path: {
        jobID: data.jobId
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Create a product or bundle
 * Creates a product or bundle with the attributes that are defined in the body.
 *
 * #### Product Types
 *
 * Commerce automatically assigns types to the products you create. In Commerce Manager, you can see at a glance the product types in a list of a products. In addition, you can filter on product types in both the API and Commerce Manager.
 *
 * Product types can also be used in catalogs. For example, in your catalog, you can filter on `parent` so that only your parent products are displayed in your storefront.
 *
 * See [**Product Types**](/docs/api/pxm/products/products#product-types).
 *
 * #### Product Tags
 *
 * You can use product tags to store or assign a key word against a product or service that you sell in your store. The product tag can then be used to describe or label that product. Product tags represent similarities between products who do not share the same attributes. Using product tags means that you can group your products together, for example, by brand, category, subcategory, colors, types, industries, and so on.
 *
 * See [**Product Tags**](/docs/api/pxm/products/product-tags).
 *
 * #### Personalizing products
 *
 * You can allow your shoppers to add custom text to a product when adding product items to their carts. This is useful, for example, if you have a product like a T-shirt that can be personalized or you sell greetings cards that can be printed with your shoppers personalized messages. You can do this by configuring the the `custom_inputs` attribute.
 *
 * When configuring the `custom_inputs` attribute:
 *
 * - You can rename `input` to something more representative of the input that shoppers are adding, for example, `message` or `front`.
 * - `name` is the name that is displayed in your storefront.
 * - You can add validation rules. For example, the input field must be a `string` and/or up to 255 characters in length. The limit is 255 characters.
 * - You can specify if the input field is required.
 *
 * #### Curating Products
 *
 * You can curate the products in a node. Product curation allows you to promote specific products within each node of your hierarchies, enabling you to create unique product collections in your storefront. For example, you may find you have an abundance of cotton T-Shirts and you want to promote these products to the top of the product list. When a shopper navigates to T-shirts, the cotton T-Shirts are displayed first. See [**Update a node**](/docs/api/pxm/products/update-node).
 *
 * #### Bundles
 *
 * With Product Experience Manager, you can use the products API to create and manage bundles. A bundle is a purchasable product, comprising of one or more products that you want to sell together.
 *
 * See [**Bundles**](/docs/api/pxm/products/products#bundles).
 *
 * @param data The data for the request.
 * @param data.requestBody
 * @returns single_product_response Creates a product with the following attributes.
 * @throws ApiError
 */
export const createProduct = (data: CreateProductData): CancelablePromise<CreateProductResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/products',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get all products
 * Retrieves a list of all your products in the Product Experience Manager system.
 *
 * You can also use `include` to retrieve top-level resources, such as files or images, and key attribute data, such as SKU or slug for component products in a product bundle. With this option, you can get more information about the products in a product bundle in your store front, improving the buying experience for your shoppers.
 *
 * #### Filtering
 *
 * Many Commerce API endpoints support filtering. The general syntax is described in [**Filtering**](/docs/commerce-cloud/api-overview/filtering).
 *
 * The following attributes and operators are supported.
 *
 * | Operator | Attribute                                                                                       | Description                                                                                                                                                                                                           | Example                         |
 * | :--- |:------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------|
 * | `eq` | `sku`, `slug`,`upc_ean`, `mpn`, `name`, `templates`, `commodity_type`, `owner`, `product_types`, `tags` | Equals. Checks if the values of two operands are equal. If they are, the condition is true. For `product_types`, you can only specify one product type. For example, `filter=eq(product_types,child)`                 | `filter=eq(name,some-name)`     |
 * | `like` | `sku`, `slug`,`upc_ean`, `mpn`, `name`, `tags`                                                          | Like. Checks if the operand contains the specified string. Wildcards are supported.                                                                                                                                   | `filter=like(name,*some-name*)` |
 * | `In` | `id`, `name`, `SKU`, `slug`, `upc_ean`, `mpn`, `product_types`, `tags`                                | Checks if the values are included in the specified string. If they are, the condition is true. For `product_types`, you can specify more than one product type. For example, `filter=in(product_types,child,bundle)`. | `filter=in(id,some-id)`         |
 *
 * @param data The data for the request.
 * @param data.pageOffset The number of records to offset the results by.
 * @param data.pageLimit The number of records per page. The maximum limit is 100.
 * @param data.filter Many Commerce API endpoints support filtering. The general syntax is described [**here**](/docs/commerce-cloud/api-overview/filtering).
 *
 * For more information about the attributes and operators that are supported, see [Get all products](/docs/api/pxm/products/get-all-products).
 *
 * @param data.include Using the include parameter, you can retrieve top-level resources.
 *
 * - Files or main image. For example, `include=files,main_image`.
 * - Component product data. For example, `include=component_products`.
 * - Key attribute data, such as SKU or slug.
 *
 * @returns multi_product_response Returns a list of all products.
 * @throws ApiError
 */
export const getAllProducts = (data: GetAllProductsData = {}): CancelablePromise<GetAllProductsResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/products',
    query: {
        'page[offset]': data.pageOffset,
        'page[limit]': data.pageLimit,
        filter: data.filter,
        include: data.include
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Import Products
 *
 * You can use the Product Import API to:
 *
 * - Add new products, including:
 *
 * - main image files. See [Importing Main Image Files](/docs/api/pxm/products/product-import-bulk-update#using-imported-main-image-files).
 * - custom data. See [Importing custom data](/docs/api/pxm/products/product-import-bulk-update#importing-custom-data-flows).
 * - Make bulk updates to existing products.
 *
 * You cannot use product import to:
 *
 * - Delete existing products.
 * - Import product bundles.
 *
 * The Product Import API uses a Comma Separated Values (CSV) file to import products, main image files and custom extension data. Each row in a .csv file represents a product you want to create/update.
 *
 * Each file can have 50,000 rows, including the header. If a CSV file exceeds 50,000 rows, an error is displayed, and the products are not imported. A CSV file must not be larger than 50 megabytes. If a CSV file is larger than 50 megabytes, a `503 client read` error is displayed.
 *
 * If you want to create/update more than 50,000 products or your CSV file is larger than 50 megabytes, you must have a separate CSV file and import each CSV file one at a time.
 *
 * See [**Characteristics of CSV Files**](/docs/api/pxm/products/product-import-bulk-update#characteristics-of-csv-import-files).
 *
 * @param data The data for the request.
 * @param data.formData
 * @returns single Import started
 * @throws ApiError
 */
export const importProducts = (data: ImportProductsData = {}): CancelablePromise<ImportProductsResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/products/import',
    formData: data.formData,
    mediaType: 'multipart/form-data',
    errors: {
        400: 'Bad request. The request failed validation.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Export Products
 *
 * The Export API is available to make bulk updates to products in Product Experience Manager. You might also export products for your personal requirements.
 *
 * The Export API builds a CSV file containing the product entries. A CSV file can contain up to 50,000 product entries. If you have more than 50,000 product entries, then another CSV file is created and so on, until all your products are exported.
 *
 * The Job endpoint response specifies the location where the CSV file is stored. See [Characteristics of CSV Files](/docs/api/pxm/products/product-export#characteristics-of-exporting-products).
 *
 * ### Filtering
 *
 * The following attributes and operators are supported.
 *
 * | Operator | Attribute                                              | Description                                                                                                                                                    | Example |
 * | :--- |:-------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------| :--- |
 * | `eq` | `sku`, `slug`, `upc_ean`, `mpn`, `name`, `description`, `tags`  | Equals. Checks if the values of two operands are equal. If they are, the condition is true. When filtering on tags, you can only specify one product tag.      | `filter=eq(name,some-name)` |
 * | `In` | `sku`, `tags`                                                | Checks if the values are included in the specified string. If they are, the condition is true. When filtering on tags, you can specify a list of product tags. | `filter=in(id,some-id)` |
 * | `like` | `sku`, `slug`, `upc_ean`, `mpn`, `name`, `description` | Like. Checks if the operand contains the specified string. Wildcards are supported.  | `filter=like(name,some-name)` |
 *
 * @param data The data for the request.
 * @param data.useTemplateSlugs Set to `true` if you want to use a template slug instead of a template ID when exporting products that have custom data.
 * @param data.filter
 * Many Commerce API endpoints support filtering. The general syntax is described [**here**](/docs/commerce-cloud/api-overview/filtering), but you must go to a specific endpoint to understand the attributes and operators an endpoint supports.
 *
 * For more information about the attributes and operators that this endpoint supports, see [Export Products](/docs/api/pxm/products/export-products).
 *
 * @param data.requestBody
 * @returns single Export started
 * @throws ApiError
 */
export const exportProducts = (data: ExportProductsData = {}): CancelablePromise<ExportProductsResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/products/export',
    query: {
        useTemplateSlugs: data.useTemplateSlugs,
        filter: data.filter
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        400: 'Bad request. The request failed validation.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get a product
 * Returns a product by its identifier.
 *
 * You can also use `include=component_products` to retrieve top-level resources, such as files or images, and key attribute data, such as SKU or slug for component products in a product bundle. With this option, you can get more information about the products in a product bundle in your store front, improving the buying experience for your shoppers.
 *
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @param data.include Using the include parameter, you can retrieve top-level resources.
 *
 * - Files or main image. For example, `include=files,main_image`.
 * - Component product data. For example, `include=component_products`.
 * - Key attribute data, such as SKU or slug.
 *
 * @returns single_product_response Returns a product by its identifier.
 * @throws ApiError
 */
export const getProduct = (data: GetProductData): CancelablePromise<GetProductResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/products/{productID}',
    path: {
        productID: data.productId
    },
    query: {
        include: data.include
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Update a product or bundle
 * Specify whichever attributes you want to change. The values of the other attributes remain the same. If the attributes section is empty, the product or bundle is not updated.
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @param data.requestBody
 * @returns single_product_response Updates a product with the following attributes.
 * @throws ApiError
 */
export const updateProduct = (data: UpdateProductData): CancelablePromise<UpdateProductResponse> => { return __request(OpenAPI, {
    method: 'PUT',
    url: '/pcm/products/{productID}',
    path: {
        productID: data.productId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Delete a product
 * Deletes the specified product.
 *
 * You cannot delete a product if it is part of a bundle. You must first delete the bundle before you delete the product.
 *
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @returns void Deletes the specified product.
 * @throws ApiError
 */
export const deleteProduct = (data: DeleteProductData): CancelablePromise<DeleteProductResponse> => { return __request(OpenAPI, {
    method: 'DELETE',
    url: '/pcm/products/{productID}',
    path: {
        productID: data.productId
    },
    errors: {
        403: 'Forbidden',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Attach multiple nodes
 * Assigns products to multiple hierarchies and their children nodes. You can apply a filter to search for the appropriate products to attach to a node. For general filtering syntax, see [**Filtering**](/docs/commerce-cloud/api-overview/filtering).
 *
 * The following attributes and operators are supported.
 *
 * | Operator | Attribute                                                                                       | Description                                                                                                                                                                                                           | Example                         |
 * | :--- |:------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------|
 * | `eq` | `sku`, `slug`,`upc_ean`, `mpn`, `name`, `templates`, `commodity_type`, `owner`, `product_types` | Equals. Checks if the values of two operands are equal. If they are, the condition is true. For `product_types`, you can only specify one product type. For example, `filter=eq(product_types,child)`                 | `filter=eq(name,some-name)`     |
 * | `like` | `sku`, `slug`,`upc_ean`, `mpn`, `name`                                                          | Like. Checks if the operand contains the specified string. Wildcards are supported.                                                                                                                                   | `filter=like(name,*some-name*)` |
 * | `In` | `id`, `name`, `SKU`, `slug`, `upc_ean`, `mpn`, `product_types`                                  | Checks if the values are included in the specified string. If they are, the condition is true. For `product_types`, you can specify more than one product type. For example, `filter=in(product_types,child,bundle)`. | `filter=in(id,some-id)`         |
 *
 *
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown This request assigns the products that you have selected to multiple hierarchies and their children nodes and returns the following.
 * @throws ApiError
 */
export const attachNodes = (data: AttachNodesData): CancelablePromise<AttachNodesResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/products/attach_nodes',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        400: 'Bad request. The request failed validation.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Detach multiple nodes
 * Dissociates products from multiple hierarchies and their children nodes. You can apply filters to search for the appropriate products to detach. For general filtering syntax, see [**Filtering**](/docs/commerce-cloud/api-overview/filtering).
 *
 * The following attributes and operators are supported.
 *
 * | Operator | Attribute                                                                                       | Description                                                                                                                                                                                                           | Example                         |
 * | :--- |:------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------|
 * | `eq` | `sku`, `slug`,`upc_ean`, `mpn`, `name`, `templates`, `commodity_type`, `owner`, `product_types` | Equals. Checks if the values of two operands are equal. If they are, the condition is true. For `product_types`, you can only specify one product type. For example, `filter=eq(product_types,child)`                 | `filter=eq(name,some-name)`     |
 * | `like` | `sku`, `slug`,`upc_ean`, `mpn`, `name`                                                          | Like. Checks if the operand contains the specified string. Wildcards are supported.                                                                                                                                   | `filter=like(name,*some-name*)` |
 * | `In` | `id`, `name`, `SKU`, `slug`, `upc_ean`, `mpn`, `product_types`                                  | Checks if the values are included in the specified string. If they are, the condition is true. For `product_types`, you can specify more than one product type. For example, `filter=in(product_types,child,bundle)`. | `filter=in(id,some-id)`         |
 *
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown The request dissociates the products that you have selected from multiple hierarchies and their children and returns the following.
 * @throws ApiError
 */
export const detachNodes = (data: DetachNodesData): CancelablePromise<DetachNodesResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/products/detach_nodes',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        400: 'Bad request. The request failed validation.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get a product's nodes
 * Returns the nodes associated with the product. Products must be in a `live` status.
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @param data.pageOffset The number of records to offset the results by.
 * @param data.pageLimit The number of records per page. The maximum limit is 100.
 * @returns multi_nodes Successfully returns the product's nodes.
 * @throws ApiError
 */
export const getProductsNodes = (data: GetProductsNodesData): CancelablePromise<GetProductsNodesResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/products/{productID}/nodes',
    path: {
        productID: data.productId
    },
    query: {
        'page[offset]': data.pageOffset,
        'page[limit]': data.pageLimit
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Build child products
 * With product variations in Product Experience Manager, you can create product variations and different options for each variation and use both to create child products for a product. Each child product is a unique combination of options associated with the product.
 *
 * Child products inherit attributes from their parent products. When you make changes to the attributes of the parent products, you can rebuild your child products, ensuring that changes to the parent products are propagated to the child products.
 *
 * Alternatively, you can modify a child product independently, without impacting its parent product. For example, you may prefer the status of your child product to be `live`, while keeping the parent product's status as `draft`. When you directly update a child product, it becomes independent of its parent product. In other words, any subsequent changes made to the parent product are not automatically reflected in the child product when you rebuild the parent product and its child products. Once a child product is independent of its parent, you cannot recreate the association between the child product and its parent. You must delete the child product and rebuild the parent to recreate the child product.
 *
 * Following on from that, if you add the same flow to both a parent and child product, the child flow values are not affected by changes to the parent flow values in a rebuild.
 *
 * ### Using Build Rules
 *
 * When building your child products, you can build all products related to a product.
 *
 * Alternatively, you can build a combination of child products associated with a product, based on build rules that you specify. This is useful, for example, if you have a variation option that you do not sell. This makes managing and building your child products quick and easy. You can do this using `build_rules`. `build_rules` are combinations of variation option IDs that you wish to include or exclude when building your child products.
 *
 * :::note
 *
 * You do not need to configure any `build_rules` in the following scenarios:
 *
 * - Child products must be built with all variation options. Simply, use the `Create a product` or `Update a product` endpoints with no `build_rules` specified.
 * - Child products must be built apart from all options for a specific variation. In this case, you must remove the variation and use the `Create a product` or `Update a product` endpoints with no `build_rules` specified. In other words, using our example, if none of the `size` options should be included, then remove the `size` variation.
 *
 * :::
 *
 * The `build_rules` contain:
 *
 * - (Required) `default`: specifies the default behavior.
 * - (Optional) `include`: specifies the option IDs to include when the child products are built. Each combination consists of a nested array of option IDs from one or more variations. Combinations of option IDs in the nested arrays must come from different variations. See [**Invalid Build Rules**](#invalid-build-rules).
 * - (Optional) `exclude`: specifies the option IDs to exclude when the child products are built. Each combination consists of a nested array of option IDs from one or more variations. Combinations of option IDs in the nested arrays must come from different variations. See [**Invalid build rules**](#invalid-build-rules).
 *
 * When building child products, Commerce compares each combination of option IDs to these rules to determine how your child products should be built, depending on how you have configured the `build_rules`. It depends on your requirements how you configure your `build_rules`.
 *
 * #### Invalid Build Rules
 *
 * The `build_rules` are invalid if both the option IDs come from the same variation. Combinations of option IDs in the nested arrays must come from different variations.
 *
 * If Commerce cannot resolve the `build_rules` a `could not determine whether to include or exclude a child product due to ambiguous rules` error is returned. This error can occur, for example, if you have the same number of variation option IDs in both the `include` and `exclude` arrays and the variation option IDs match.
 *
 * ### Building Child Products
 *
 * Building child products is an asynchronous operation. When you build child products, a job is created. The jobId of the job is displayed in the response. When the job is complete, the build child products operation is also complete. You can use the jobId to see the status of your job using the `Get a Job` endpoint.
 *
 * Jobs are processed one at a time. You can continue to send build child product requests, but those jobs are queued. In other words, Commerce looks for any jobs that have a status of PENDING and starts the job with the earliest created date. This process is repeated until all jobs are processed. See Jobs.
 *
 * Re-building child products after adding or removing a new variation changes the total number of child products that you can generate from a parent product. When you rebuild the child products after updating variations associated with the parent product, all existing child products that belong to a parent product are deleted. New child products are created with new product IDs.
 *
 * If you have any bundles that reference child products directly, then you must update the bundles with the new child product IDs.
 *
 * However, re-building child products after adding or removing an option does not change the existing product IDs.
 *
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @param data.requestBody
 * @returns unknown Successfully started building child products
 * @throws ApiError
 */
export const buildChildProducts = (data: BuildChildProductsData): CancelablePromise<BuildChildProductsResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/products/{productID}/build',
    path: {
        productID: data.productId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get child products
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @returns multi_product_response Returns a list of child products for the specified parent product ID.
 * @throws ApiError
 */
export const getChildProducts = (data: GetChildProductsData): CancelablePromise<GetChildProductsResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/products/{productID}/children',
    path: {
        productID: data.productId
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Create a product template relationship
 * Retrieves all the templates that are associated with the specified product.
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @param data.requestBody
 * @returns template_response Returns a created product template relationship.
 * @throws ApiError
 */
export const createProductTemplateRelationship = (data: CreateProductTemplateRelationshipData): CancelablePromise<CreateProductTemplateRelationshipResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/products/{productID}/relationships/templates',
    path: {
        productID: data.productId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get all product template relationships
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @returns template_response Returns all product template relationships
 * @throws ApiError
 */
export const getProductTemplateRelationships = (data: GetProductTemplateRelationshipsData): CancelablePromise<GetProductTemplateRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/products/{productID}/relationships/templates',
    path: {
        productID: data.productId
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Delete a product template relationship
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @param data.requestBody
 * @returns void No Content
 * @throws ApiError
 */
export const deleteProductTemplateRelationship = (data: DeleteProductTemplateRelationshipData): CancelablePromise<DeleteProductTemplateRelationshipResponse> => { return __request(OpenAPI, {
    method: 'DELETE',
    url: '/pcm/products/{productID}/relationships/templates',
    path: {
        productID: data.productId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get Bundle Component Product Relationships
 * Retrieves all the products included in the specified bundle product.
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @returns component_products_response Returns all Component Products relationships
 * @throws ApiError
 */
export const getProductComponentProductsRelationships = (data: GetProductComponentProductsRelationshipsData): CancelablePromise<GetProductComponentProductsRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/products/{productID}/relationships/component_products',
    path: {
        productID: data.productId
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get all product file relationships
 * Retrieves all files that are associated with the specified product.
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @returns file_response Returns all product file relationships.
 * @throws ApiError
 */
export const getProductFileRelationships = (data: GetProductFileRelationshipsData): CancelablePromise<GetProductFileRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/products/{productID}/relationships/files',
    path: {
        productID: data.productId
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Create a product file relationship
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @param data.requestBody
 * @returns void No Content
 * @throws ApiError
 */
export const createProductFileRelationships = (data: CreateProductFileRelationshipsData): CancelablePromise<CreateProductFileRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/products/{productID}/relationships/files',
    path: {
        productID: data.productId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Replace a product file relationship
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @param data.requestBody
 * @returns void No Content
 * @throws ApiError
 */
export const updateProductFileRelationships = (data: UpdateProductFileRelationshipsData): CancelablePromise<UpdateProductFileRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'PUT',
    url: '/pcm/products/{productID}/relationships/files',
    path: {
        productID: data.productId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Delete a product file relationships
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @param data.requestBody
 * @returns void No Content
 * @throws ApiError
 */
export const deleteProductFileRelationships = (data: DeleteProductFileRelationshipsData): CancelablePromise<DeleteProductFileRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'DELETE',
    url: '/pcm/products/{productID}/relationships/files',
    path: {
        productID: data.productId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Create a product variation relationship
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @param data.requestBody
 * @returns void No Content
 * @throws ApiError
 */
export const createProductVariationRelationships = (data: CreateProductVariationRelationshipsData): CancelablePromise<CreateProductVariationRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/products/{productID}/relationships/variations',
    path: {
        productID: data.productId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get all product variation relationships
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @returns variations_response Returns all product variation relationships
 * @throws ApiError
 */
export const getProductVariationRelationships = (data: GetProductVariationRelationshipsData): CancelablePromise<GetProductVariationRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/products/{productID}/relationships/variations',
    path: {
        productID: data.productId
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Replace a product variation relationship
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @param data.requestBody
 * @returns void No Content
 * @throws ApiError
 */
export const updateProductVariationRelationships = (data: UpdateProductVariationRelationshipsData): CancelablePromise<UpdateProductVariationRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'PUT',
    url: '/pcm/products/{productID}/relationships/variations',
    path: {
        productID: data.productId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Delete a product variation relationships
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @param data.requestBody
 * @returns void No Content
 * @throws ApiError
 */
export const deleteProductVariationRelationships = (data: DeleteProductVariationRelationshipsData): CancelablePromise<DeleteProductVariationRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'DELETE',
    url: '/pcm/products/{productID}/relationships/variations',
    path: {
        productID: data.productId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Create main image relationships
 * Associates a main image with the specified product.
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @param data.requestBody
 * @returns void No Content
 * @throws ApiError
 */
export const createProductMainImageRelationships = (data: CreateProductMainImageRelationshipsData): CancelablePromise<CreateProductMainImageRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/products/{productID}/relationships/main_image',
    path: {
        productID: data.productId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get Main Image Relationships
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @returns main_image_response Returns all product variation relationships
 * @throws ApiError
 */
export const getProductMainImageRelationships = (data: GetProductMainImageRelationshipsData): CancelablePromise<GetProductMainImageRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/products/{productID}/relationships/main_image',
    path: {
        productID: data.productId
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Replace Main Image Relationships
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @param data.requestBody
 * @returns void No Content
 * @throws ApiError
 */
export const updateProductMainImageRelationships = (data: UpdateProductMainImageRelationshipsData): CancelablePromise<UpdateProductMainImageRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'PUT',
    url: '/pcm/products/{productID}/relationships/main_image',
    path: {
        productID: data.productId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Delete Main Image Relationships
 * @param data The data for the request.
 * @param data.productId A unique identifier for the product.
 * @returns void No Content
 * @throws ApiError
 */
export const deleteProductMainImageRelationships = (data: DeleteProductMainImageRelationshipsData): CancelablePromise<DeleteProductMainImageRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'DELETE',
    url: '/pcm/products/{productID}/relationships/main_image',
    path: {
        productID: data.productId
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Create a variation
 * @param data The data for the request.
 * @param data.requestBody
 * @returns created_variation Returns a created variation with the following attributes.
 * @throws ApiError
 */
export const createVariation = (data: CreateVariationData): CancelablePromise<CreateVariationResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/variations',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get all variations
 * @param data The data for the request.
 * @param data.pageOffset The number of records to offset the results by.
 * @param data.pageLimit The number of records per page. The maximum limit is 100.
 * @returns multi_variations Returns all variations.
 * @throws ApiError
 */
export const getAllVariations = (data: GetAllVariationsData = {}): CancelablePromise<GetAllVariationsResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/variations',
    query: {
        'page[offset]': data.pageOffset,
        'page[limit]': data.pageLimit
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get a variation
 * @param data The data for the request.
 * @param data.variationId A unique identifier for the variation.
 * @returns single_variation Returns the specified variation.
 * @throws ApiError
 */
export const getVariation = (data: GetVariationData): CancelablePromise<GetVariationResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/variations/{variationID}',
    path: {
        variationID: data.variationId
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Update a variation
 * Specify whichever attributes you want to change. The values of the other attributes remain the same. If the attributes section is empty, the variation is not updated.
 * @param data The data for the request.
 * @param data.variationId A unique identifier for the variation.
 * @param data.requestBody
 * @returns single_variation Returns an updated variation with the following attributes.
 * @throws ApiError
 */
export const updateVariation = (data: UpdateVariationData): CancelablePromise<UpdateVariationResponse> => { return __request(OpenAPI, {
    method: 'PUT',
    url: '/pcm/variations/{variationID}',
    path: {
        variationID: data.variationId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Delete a variation and all it's associated options
 * @param data The data for the request.
 * @param data.variationId A unique identifier for the variation.
 * @returns void No Content
 * @throws ApiError
 */
export const deleteVariation = (data: DeleteVariationData): CancelablePromise<DeleteVariationResponse> => { return __request(OpenAPI, {
    method: 'DELETE',
    url: '/pcm/variations/{variationID}',
    path: {
        variationID: data.variationId
    },
    errors: {
        403: 'Forbidden',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Create a variation option
 * @param data The data for the request.
 * @param data.variationId A unique identifier for the variation.
 * @param data.requestBody
 * @returns created_option Successfully returns the created variation option
 * @throws ApiError
 */
export const createVariationOption = (data: CreateVariationOptionData): CancelablePromise<CreateVariationOptionResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/variations/{variationID}/options',
    path: {
        variationID: data.variationId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get all variation options
 * @param data The data for the request.
 * @param data.variationId A unique identifier for the variation.
 * @param data.pageOffset The number of records to offset the results by.
 * @param data.pageLimit The number of records per page. The maximum limit is 100.
 * @returns multi_options Successfully returns all variation options
 * @throws ApiError
 */
export const getAllVariationOptions = (data: GetAllVariationOptionsData): CancelablePromise<GetAllVariationOptionsResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/variations/{variationID}/options',
    path: {
        variationID: data.variationId
    },
    query: {
        'page[offset]': data.pageOffset,
        'page[limit]': data.pageLimit
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get a variation option
 * @param data The data for the request.
 * @param data.variationId A unique identifier for the variation.
 * @param data.optionId A unique identifier for the option.
 * @returns single_option Successfully returns the variation option
 * @throws ApiError
 */
export const getVariationOption = (data: GetVariationOptionData): CancelablePromise<GetVariationOptionResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/variations/{variationID}/options/{optionID}',
    path: {
        variationID: data.variationId,
        optionID: data.optionId
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Update a variation option
 * @param data The data for the request.
 * @param data.variationId A unique identifier for the variation.
 * @param data.optionId A unique identifier for the option.
 * @param data.requestBody
 * @returns single_option Successfully returns the updated variation option
 * @throws ApiError
 */
export const updateVariationOption = (data: UpdateVariationOptionData): CancelablePromise<UpdateVariationOptionResponse> => { return __request(OpenAPI, {
    method: 'PUT',
    url: '/pcm/variations/{variationID}/options/{optionID}',
    path: {
        variationID: data.variationId,
        optionID: data.optionId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Delete a variation option
 * @param data The data for the request.
 * @param data.variationId A unique identifier for the variation.
 * @param data.optionId A unique identifier for the option.
 * @returns void No Content
 * @throws ApiError
 */
export const deleteVariationOption = (data: DeleteVariationOptionData): CancelablePromise<DeleteVariationOptionResponse> => { return __request(OpenAPI, {
    method: 'DELETE',
    url: '/pcm/variations/{variationID}/options/{optionID}',
    path: {
        variationID: data.variationId,
        optionID: data.optionId
    },
    errors: {
        403: 'Forbidden',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Create a modifier
 * @param data The data for the request.
 * @param data.variationId A unique identifier for the variation.
 * @param data.optionId A unique identifier for the option.
 * @param data.requestBody
 * @returns created_modifier Successfully returns the created modifier
 * @throws ApiError
 */
export const createModifier = (data: CreateModifierData): CancelablePromise<CreateModifierResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/variations/{variationID}/options/{optionID}/modifiers',
    path: {
        variationID: data.variationId,
        optionID: data.optionId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get all modifiers
 * @param data The data for the request.
 * @param data.variationId A unique identifier for the variation.
 * @param data.optionId A unique identifier for the option.
 * @param data.pageOffset The number of records to offset the results by.
 * @param data.pageLimit The number of records per page. The maximum limit is 100.
 * @returns multi_modifiers Successfully returns all variation modifiers
 * @throws ApiError
 */
export const getAllModifiers = (data: GetAllModifiersData): CancelablePromise<GetAllModifiersResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/variations/{variationID}/options/{optionID}/modifiers',
    path: {
        variationID: data.variationId,
        optionID: data.optionId
    },
    query: {
        'page[offset]': data.pageOffset,
        'page[limit]': data.pageLimit
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get a modifier
 * @param data The data for the request.
 * @param data.variationId A unique identifier for the variation.
 * @param data.optionId A unique identifier for the option.
 * @param data.modifierId A unique identifier for the modifier.
 * @returns single_modifier Returns the specified modifier.
 * @throws ApiError
 */
export const getModifier = (data: GetModifierData): CancelablePromise<GetModifierResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/variations/{variationID}/options/{optionID}/modifiers/{modifierID}',
    path: {
        variationID: data.variationId,
        optionID: data.optionId,
        modifierID: data.modifierId
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Update a modifier
 * Specify whichever attributes you want to change. The values of the other attributes remain the same. If the attributes section is empty, the modifier is not updated.
 * @param data The data for the request.
 * @param data.variationId A unique identifier for the variation.
 * @param data.optionId A unique identifier for the option.
 * @param data.modifierId A unique identifier for the modifier.
 * @param data.requestBody
 * @returns single_modifier Successfully returns the updated modifier
 * @throws ApiError
 */
export const updateModifier = (data: UpdateModifierData): CancelablePromise<UpdateModifierResponse> => { return __request(OpenAPI, {
    method: 'PUT',
    url: '/pcm/variations/{variationID}/options/{optionID}/modifiers/{modifierID}',
    path: {
        variationID: data.variationId,
        optionID: data.optionId,
        modifierID: data.modifierId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        409: 'Write conflict detected',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Delete a modifier
 * You cannot delete a modifier if it is in use. Deleting a modifier in us returns a `422 Failed Validation` error.
 * @param data The data for the request.
 * @param data.variationId A unique identifier for the variation.
 * @param data.optionId A unique identifier for the option.
 * @param data.modifierId A unique identifier for the modifier.
 * @returns void No Content
 * @throws ApiError
 */
export const deleteModifier = (data: DeleteModifierData): CancelablePromise<DeleteModifierResponse> => { return __request(OpenAPI, {
    method: 'DELETE',
    url: '/pcm/variations/{variationID}/options/{optionID}/modifiers/{modifierID}',
    path: {
        variationID: data.variationId,
        optionID: data.optionId,
        modifierID: data.modifierId
    },
    errors: {
        403: 'Forbidden',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Create a hierarchy
 * Create a hierarchy
 * @param data The data for the request.
 * @param data.requestBody
 * @returns single_hierarchy Returns a created hierarchy with the following attributes.
 * @throws ApiError
 */
export const createHierarchy = (data: CreateHierarchyData): CancelablePromise<CreateHierarchyResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/hierarchies',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get all hierarchies
 * Get all hierarchies
 * @param data The data for the request.
 * @param data.pageOffset The number of records to offset the results by.
 * @param data.pageLimit The number of records per page. The maximum limit is 100.
 * @returns multi_hierarchy Returns a list of all hierarchies.
 * @throws ApiError
 */
export const getHierarchy = (data: GetHierarchyData = {}): CancelablePromise<GetHierarchyResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/hierarchies',
    query: {
        'page[offset]': data.pageOffset,
        'page[limit]': data.pageLimit
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get a hierarchy
 * Retrieves the specified hierarchy.
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @returns single_hierarchy Returns a hierarchy with the following attributes.
 * @throws ApiError
 */
export const getHierarchyChild = (data: GetHierarchyChildData): CancelablePromise<GetHierarchyChildResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/hierarchies/{hierarchyID}',
    path: {
        hierarchyID: data.hierarchyId
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Update a hierarchy
 * Specify whichever attributes you want to change. The values of the other attributes remain the same. If the attributes section is empty, the hierarchy is not updated.
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @param data.requestBody
 * @returns single_hierarchy Successfully returns the updated hierarchy
 * @throws ApiError
 */
export const updateHierarchy = (data: UpdateHierarchyData): CancelablePromise<UpdateHierarchyResponse> => { return __request(OpenAPI, {
    method: 'PUT',
    url: '/pcm/hierarchies/{hierarchyID}',
    path: {
        hierarchyID: data.hierarchyId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Delete a hierarchy
 * Deletes the specified hierarchy and all its children.
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @returns void No Content
 * @throws ApiError
 */
export const deleteHierarchy = (data: DeleteHierarchyData): CancelablePromise<DeleteHierarchyResponse> => { return __request(OpenAPI, {
    method: 'DELETE',
    url: '/pcm/hierarchies/{hierarchyID}',
    path: {
        hierarchyID: data.hierarchyId
    },
    errors: {
        403: 'Forbidden',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Create a node
 * Creates a node in the specified hierarchy.
 *
 * ### Sorting Nodes in a Hierarchy
 *
 * You can sort the order of your nodes, regardless of where the nodes are in the hierarchy.
 *
 * You can do this by adding a `meta` object to the body of your request and specifying a `sort_order` value.
 *
 * The node with the highest value of `sort_order` is displayed first. For example, a node with a `sort_order` value of `3` appears before a node with a `sort_order` value of `2`.
 *
 * - If you dont provide `sort_order` when creating nodes, all child nodes in the response for Get a Nodes Children request are ordered by the `updated_at` time in descending order, with the most recently updated child node first.
 * - If you set `sort_order` for only a few child nodes, the child nodes with a `sort_order` value appear first and then other child nodes appear in the order of `updated_at` time.
 *
 * You can also specify a `sort_order` when creating a node relationship.
 *
 * - If you create a node (**Node A**) with a `sort_order` and then you create a relationship for **Node A** with another node (**Node B**), the `sort_order` you specified when creating **Node A** is overwritten.
 * - If you create **Node A** and then you create a relationship with **Node B** but do not configure a `sort_order`, the `sort_order` you specified when you created **Node A** is not overwritten.
 *
 * ### Curating Products in a node
 *
 * You can curate the products in a node. Product curation allows you to promote specific products within each node of your hierarchies, enabling you to create unique product collections in your storefront. For example, you may find you have an abundance of cotton T-Shirts and you want to promote these products to the top of the product list. When a shopper navigates to T-shirts, the cotton T-Shirts are displayed first.
 *
 * You can do this by adding a `curated_products` attribute to the body of your request and adding an array of product IDs to the attribute. You should add the products IDs in the order you want them to be displayed in your node. The first product ID is displayed first in the product list.
 *
 * You can only curate 20 products or less. You cannot have more than 20 curated products.
 *
 * - The product IDs you provide must exist in the specified node.
 * - If a curated product is removed from a node, the product is also removed from the curated_products list.
 * - Once you have curated the products in a node, you can use the get node products endpoint to retrieve a list of curated products.
 *
 * You can then display your curated products in your catalogs using the following catalog endpoints.
 *
 * - Get a node in your latest catalog release.
 * - Get a node in a catalog.
 * - Get all nodes in your latest catalog release.
 * - Get all nodes in a catalog.
 * - Get node children in your latest catalog release.
 * - Get node children in a catalog.
 *
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @param data.requestBody
 * @returns single_node Successfully returns the created node
 * @throws ApiError
 */
export const createNode = (data: CreateNodeData): CancelablePromise<CreateNodeResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/hierarchies/{hierarchyID}/nodes',
    path: {
        hierarchyID: data.hierarchyId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get all nodes in a hierarchy
 * A fully paginated view of all nodes in a hierarchy regardless of depth.
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @param data.pageOffset The number of records to offset the results by.
 * @param data.pageLimit The number of records per page. The maximum limit is 100.
 * @returns multi_nodes Successfully returns the node's children
 * @throws ApiError
 */
export const getAllNodesInHierarchy = (data: GetAllNodesInHierarchyData): CancelablePromise<GetAllNodesInHierarchyResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/hierarchies/{hierarchyID}/nodes',
    path: {
        hierarchyID: data.hierarchyId
    },
    query: {
        'page[offset]': data.pageOffset,
        'page[limit]': data.pageLimit
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get a node
 * Retrieves a node from a hierarchy.
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @param data.nodeId A unique identifier for the node.
 * @returns single_node Returns a node with the following attributes.
 * @throws ApiError
 */
export const getHierarchyNode = (data: GetHierarchyNodeData): CancelablePromise<GetHierarchyNodeResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}',
    path: {
        hierarchyID: data.hierarchyId,
        nodeID: data.nodeId
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Update a node
 * Updates the specified node in a hierarchy. You can do a partial update, where you specify only the field value to change.
 *
 * ### Sorting Nodes in a hierarchy
 *
 * You can sort the order of your nodes, regardless of where the nodes are in the hierarchy.
 *
 * The node with the highest value of sort_order is displayed first. For example, a node with a `sort_order` value of `3` appears before a node with a `sort_order` value of `2`.
 *
 * - If you dont provide `sort_order` when creating nodes, all child nodes in the response for Get a Nodes Children request are ordered by the `updated_at` time in descending order, with the most recently updated child node first.
 * - If you set `sort_order` for only a few child nodes or not all, the child nodes with a `sort_order` value appear first and then other child nodes appear in the order of `updated_at` time.
 *
 * You can also specify a sort_order when creating a node relationship.
 *
 * - If you update a node (**Node A**) with a `sort_order` and then you create a relationship for **Node A** with another node (**Node B**), the `sort_order` you specified when updating **Node A** is overwritten.
 * - If you have updated **Node A** and then you create a relationship with **Node B** but do not configure a `sort_order`, the `sort_order` you specified when you updated **Node A** is not overwritten.
 *
 * ### Curating Products in a node
 *
 * You can curate the products in a node. Product curation allows you to promote specific products within each node of your hierarchies, enabling you to create unique product collections in your storefront. For example, you may find you have an abundance of cotton T-Shirts and you want to promote these products to the top of the product list. When a shopper navigates to T-shirts, the cotton T-Shirts are displayed first.
 *
 * You can do this by adding a `curated_products` attribute to the body of your request and adding an array of product IDs to the attribute. You should add the products IDs in the order you want them to be displayed in your node. The first product ID is displayed first in the product list.
 *
 * You can only curate 20 products or less. You cannot have more than 20 curated products.
 *
 * - The product IDs you provide must exist in the specified node.
 * - If a curated product is removed from a node, the product is also removed from the curated_products list.
 * - Once you have curated the products in a node, you can use the get node products endpoint to retrieve a list of curated products.
 *
 * You can then display your curated products in your catalogs using the following catalog endpoints.
 *
 * - Get a node in your latest catalog release.
 * - Get a node in a catalog.
 * - Get all nodes in your latest catalog release.
 * - Get all nodes in a catalog.
 * - Get node children in your latest catalog release.
 * - Get node children in a catalog.
 *
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @param data.nodeId A unique identifier for the node.
 * @param data.requestBody
 * @returns single_node Successfully returns the updated node
 * @throws ApiError
 */
export const updateNode = (data: UpdateNodeData): CancelablePromise<UpdateNodeResponse> => { return __request(OpenAPI, {
    method: 'PUT',
    url: '/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}',
    path: {
        hierarchyID: data.hierarchyId,
        nodeID: data.nodeId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Deletes a node
 * Deletes a node by the node ID
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @param data.nodeId A unique identifier for the node.
 * @returns void No Content
 * @throws ApiError
 */
export const deleteNode = (data: DeleteNodeData): CancelablePromise<DeleteNodeResponse> => { return __request(OpenAPI, {
    method: 'DELETE',
    url: '/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}',
    path: {
        hierarchyID: data.hierarchyId,
        nodeID: data.nodeId
    },
    errors: {
        403: 'Forbidden',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get a hierarchy's children
 * Get a hierarchy's children
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @param data.pageOffset The number of records to offset the results by.
 * @param data.pageLimit The number of records per page. The maximum limit is 100.
 * @returns multi_nodes Returns the hierarchy's children.
 * @throws ApiError
 */
export const getAllChildren = (data: GetAllChildrenData): CancelablePromise<GetAllChildrenResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/hierarchies/{hierarchyID}/children',
    path: {
        hierarchyID: data.hierarchyId
    },
    query: {
        'page[offset]': data.pageOffset,
        'page[limit]': data.pageLimit
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Create relationships between a node and child nodes
 * Use this endpoint to create relationships between a single parent node and one or more child nodes. You can create a relationship only if:
 *
 * - The parent node already exists.
 * - All child nodes already exist.
 * - Every child node in the body of the request exists in the same hierarchy as the parent node.
 * - A node is not a parent of itself. An array of child nodes request body must not contain the ID of the parent node in the path.
 * - All siblings in a hierarchy must have a unique `slug`. Siblings are the child nodes that are related to the same parent.
 *
 * ### Sort Order
 *
 * You can also provide `sort_order` information when you create a relationship by adding a `meta` object to the array of node reference objects for each child node that requires sorting.
 *
 * The node with the highest value of `sort_order` appears at the top of the response. For example, a node with a `sort_order` value of `3` appears before a node with a `sort_order` value of `2`.
 *
 * - If you dont provide `sort_order` when creating relationships, all child nodes in the response for Get a Nodes Children request are ordered by the `updated_at` time in descending order. The most recently updated child node appears at the top of the response.
 * - If you set `sort_order` for only a few child nodes or not all, the child nodes with `sort_order` value appear first in the response and then other child nodes appear in the order of `updated_at` time.
 *
 * You can also specify a `sort_order` when creating and updating a node.
 *
 * - If you create or update a node (**Node A**) with a `sort_order` and then you create a relationship for **Node A** with another node (**Node B**), the `sort_order` you specified when creating\updating **Node A** is overwritten.
 * - If you create\update **Node A** and then you create a relationship with **Node B** but do not configure a `sort_order`, the `sort_order` you specified when you created\updated **Node A** is not overwritten.
 *
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @param data.nodeId A unique identifier for the node.
 * @param data.requestBody
 * @returns single_node Successfully returns the node's children
 * @throws ApiError
 */
export const createNodeChildRelationships = (data: CreateNodeChildRelationshipsData): CancelablePromise<CreateNodeChildRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/relationships/children',
    path: {
        hierarchyID: data.hierarchyId,
        nodeID: data.nodeId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get a node's children
 * Retrieves the child nodes for a specified node.
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @param data.nodeId A unique identifier for the node.
 * @param data.pageOffset The number of records to offset the results by.
 * @param data.pageLimit The number of records per page. The maximum limit is 100.
 * @returns multi_nodes Successfully returns the node's children
 * @throws ApiError
 */
export const getAllNodeChildren = (data: GetAllNodeChildrenData): CancelablePromise<GetAllNodeChildrenResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/children',
    path: {
        hierarchyID: data.hierarchyId,
        nodeID: data.nodeId
    },
    query: {
        'page[offset]': data.pageOffset,
        'page[limit]': data.pageLimit
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Update a node's parent
 * Changes the parent of the specified node. The new parent node must be located within the same hierarchy as the specified node.
 *
 * You cannot move a node to another hierarchy. If you want to put the specified node into another hierarchy, create the node in the target hierarchy and delete it from the current hierarchy.
 *
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @param data.nodeId A unique identifier for the node.
 * @param data.requestBody
 * @returns void No Content
 * @throws ApiError
 */
export const updateNodeParent = (data: UpdateNodeParentData): CancelablePromise<UpdateNodeParentResponse> => { return __request(OpenAPI, {
    method: 'PUT',
    url: '/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/relationships/parent',
    path: {
        hierarchyID: data.hierarchyId,
        nodeID: data.nodeId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Delete a node's parent
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @param data.nodeId A unique identifier for the node.
 * @returns void No Content
 * @throws ApiError
 */
export const deleteNodeParent = (data: DeleteNodeParentData): CancelablePromise<DeleteNodeParentResponse> => { return __request(OpenAPI, {
    method: 'DELETE',
    url: '/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/relationships/parent',
    path: {
        hierarchyID: data.hierarchyId,
        nodeID: data.nodeId
    },
    errors: {
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Create a node's product relationships
 * Creates relationships between the specified node and one or more products in a specified hierarchy.
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @param data.nodeId A unique identifier for the node.
 * @param data.requestBody
 * @returns single_node Successfully returns the updated node
 * @throws ApiError
 */
export const createNodeProductRelationship = (data: CreateNodeProductRelationshipData): CancelablePromise<CreateNodeProductRelationshipResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/relationships/products',
    path: {
        hierarchyID: data.hierarchyId,
        nodeID: data.nodeId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Deletes a node's product relationships
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @param data.nodeId A unique identifier for the node.
 * @param data.requestBody
 * @returns single_node Successfully returns the updated node
 * @throws ApiError
 */
export const deleteNodeProductRelationships = (data: DeleteNodeProductRelationshipsData): CancelablePromise<DeleteNodeProductRelationshipsResponse> => { return __request(OpenAPI, {
    method: 'DELETE',
    url: '/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/relationships/products',
    path: {
        hierarchyID: data.hierarchyId,
        nodeID: data.nodeId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get a node's products
 * Returns the products associated with the specified hierarchy node from a published catalog. Products must be in a live status. If the products have been curated using the update a hierarchy node endpoint, then the products are returned in the order specified in the `curated_products` attribute in the body of the update a hierarchy node request. A product that is curated has the "curated_product": true attribute displayed.
 *
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @param data.nodeId A unique identifier for the node.
 * @param data.pageOffset The number of records to offset the results by.
 * @param data.pageLimit The number of records per page. The maximum limit is 100.
 * @returns multi_product_response Successfully returns the node's products
 * @throws ApiError
 */
export const getNodeProducts = (data: GetNodeProductsData): CancelablePromise<GetNodeProductsResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/hierarchies/{hierarchyID}/nodes/{nodeID}/products',
    path: {
        hierarchyID: data.hierarchyId,
        nodeID: data.nodeId
    },
    query: {
        'page[offset]': data.pageOffset,
        'page[limit]': data.pageLimit
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Duplicate a hierarchy
 * Using this option, you can duplicate an existing hierarchy. This is useful because it enables you to quickly and easily create multiple hierarchies with the same node structure.
 *
 * When you duplicate a hierarchy, you can specify a new name and/or a new description for the duplicated hierarchy. All other attributes, such as slug and locales, stay the same.
 *
 * Any nodes in the existing hierarchy are also replicated in the duplicated hierarchy. In addition, you can optionally use the `include_products` attribute to specify whether you want products associated with the nodes in an existing hierarchy to be associated with the nodes in the duplicated hierarchy. By default, product associations in an existing hierarchy are not duplicated in a duplicate hierarchy.
 *
 * Duplicating a hierarchy is an asynchronous operation. When you duplicate a hierarchy, a job is created. The jobId of the job is displayed in the response. When the job is complete, the duplicate hierarchy operation is also complete. You can use the jobId to see the status of your job using Get a Job.
 *
 * Jobs are processed one at a time. You can continue to send duplicate hierarchy requests, but those jobs are queued. In other words, Commerce looks for any jobs that have a status of PENDING and starts the job with the earliest created date. This process is repeated until all jobs are processed.
 *
 * Once the job is complete, run:
 *
 * - Get all hierarchies to retrieve the HierarchyId of your duplicated hierarchy.
 * - Get a hierarchy to retrieve the nodes and (if applicable) products associated with the duplicated hierarchy.
 *
 * @param data The data for the request.
 * @param data.hierarchyId A unique identifier for the hierarchy.
 * @param data.requestBody
 * @returns single Successfully returns the duplicate hierarchy job ID
 * @throws ApiError
 */
export const duplicateHierarchy = (data: DuplicateHierarchyData): CancelablePromise<DuplicateHierarchyResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/hierarchies/{hierarchyID}/duplicate_job',
    path: {
        hierarchyID: data.hierarchyId
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get All Product Tags
 * Retrieves all product tags for a store. A store can view the tags associated with the organization to which the store belongs. However, an organization can only view the tags associated with the organization.
 *
 *
 * @returns multi_tag Returns all the product tags.
 * @throws ApiError
 */
export const getAllProductTags = (): CancelablePromise<GetAllProductTagsResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/tags',
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Get a Product Tag
 * Retrieves a product tag for a store. A store can view the tags associated with the organization to which the store belongs. However, an organization can only view the tags associated with the organization.
 * @param data The data for the request.
 * @param data.tagId A unique identifier for the tag.
 * @returns single_tag Returns a product tag with the following attributes.
 * @throws ApiError
 */
export const getProductTag = (data: GetProductTagData): CancelablePromise<GetProductTagResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/pcm/tags/{tagID}',
    path: {
        tagID: data.tagId
    },
    errors: {
        400: 'Bad request. The request failed validation.',
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Create a custom relationship
 * Create a custom relationship
 * @param data The data for the request.
 * @param data.requestBody
 * @returns single_custom_relationship Returns a created custom relationship with the following attributes.
 * @throws ApiError
 */
export const createCustomRelationship = (data: CreateCustomRelationshipData): CancelablePromise<CreateCustomRelationshipResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/pcm/custom_relationships',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };

/**
 * Update a custom relationship
 * Specify whichever attributes you want to change. The values of the other attributes remain the same. If the attributes section is empty, the custom relationship is not updated.
 * @param data The data for the request.
 * @param data.customRelationshipSlug A custom relationship slug.
 * @param data.requestBody
 * @returns single_custom_relationship Successfully returns the updated custom relationship
 * @throws ApiError
 */
export const updateCustomRelationship = (data: UpdateCustomRelationshipData): CancelablePromise<UpdateCustomRelationshipResponse> => { return __request(OpenAPI, {
    method: 'PUT',
    url: '/pcm/custom_relationships/{customRelationshipSlug}',
    path: {
        customRelationshipSlug: data.customRelationshipSlug
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        403: 'Forbidden',
        404: 'Bad Request. Not Found.',
        422: 'Bad request. The request failed validation.',
        500: 'Internal server error. There was a system failure in the platform.'
    }
}); };